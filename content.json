{"pages":[{"title":"About","date":"2025-04-20T05:50:42.956Z","path":"about/index.html","text":""},{"title":"Categories","date":"2025-04-20T05:50:42.956Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2025-04-20T05:50:42.956Z","path":"tags/index.html","text":""}],"posts":[{"title":"小笔记","date":"2025-04-20T05:50:42.956Z","path":"tech/index/","text":"","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"}]},{"title":"","date":"2025-04-20T05:50:42.956Z","path":"tech/iOS/未分类/iOS 状态栏/","text":"Info.plist 中设置 View controller-based status bar appearance 控制 App 状态栏显隐接受全局配置（NO）或者各控制器各自配置（YES） View controller-based status bar appearance = NO 时，使用 [[UIApplication sharedApplication] setStatusBarHidden:hidden] 来控制全局状态栏的显隐 View controller-based status bar appearance = YES 时，重写 ViewController 的 prefersStatusBarHidden 方法来决定当前 Controller 的状态栏显隐 设置 Status bar is initially hidden -&gt; YES 可以隐藏启动页展示过程的状态栏；默认不隐藏 ViewController 的相关方法 1234567891011121314// 样式- (UIStatusBarStyle)preferredStatusBarStyle&#123; return [self.visibleViewController preferredStatusBarStyle];&#125;// 显隐- (BOOL)prefersStatusBarHidden &#123; return [self.visibleViewController prefersStatusBarHidden];&#125;// 标记状态栏需要更新，同 setNeedsLayout[self setNeedsStatusBarAppearanceUpdate];","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.956Z","path":"tech/iOS/未分类/iOS 触摸机制/","text":"原理iOS 把用户触摸事件打包成一个 UIEvent 对象，作为事件传递的消息载体，放入当前活跃的 APP 的消息队列中，然后通过 Hit-Test 机制 来找到响应者，响应者通过响应链（Responder Chain）的传递做出响应，这就是 iOS 事件分发机制的实现原理 UIEvent 有哪些UIEvent 包含最常见的三种事件：Touch Events(触摸事件)、Motion Events(运动事件，比如重力感应和摇一摇等)、Remote Events(远程事件，比如用耳机控制手机)。这里我们只讨论触摸事件 Hit-Test 机制如图，我点击了 E，Hit-Test 机制是如何找到这个 View 呢？ 1234567891011121314151617181920212223- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 1. 判断能否接受事件 if (!self.userInteractionEnabled || self.hidden || self.alpha &lt;= 0.01) return nil; // 2. 判断是否在当前 View 内 if ([self pointInside:point withEvent:event] == NO) return nil; // 3. 逆序遍历子视图 for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; // 坐标转换，将当前坐标系的点转化为子视图的坐标系的点 CGPoint childP = [self convertPoint:point toView:subview]; UIView *hitView = [subview hitTest:childP withEvent:event]; if (hitView) &#123; return hitView; &#125; &#125; // 4. 不在子视图，则返回自己 return self;&#125; 其中 UIView 的 pointInside:withEvent: 方法的作用是，判断当前的点是否在当前 View 的 bounds 中 1234- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event&#123; return CGRectContainsPoint(self.bounds, point);&#125; 注意，以下情况，Hit-Test 函数返回 nil view.isHidden = YES view.alpha &lt;= 0.01 view.userInterfaceEnable=NO control.enable = NO（如果是 UIControl） 其次注意，子视图的遍历是逆序的，为了保证相同层级下的子视图，离用户越近的优先得到响应 Responder Chain（响应链）在 UIKit 中，UIApplication、UIView、UIViewController 这几个类都是直接继承自 UIResponder 类；而响应链是由 UIResponder 组合而成的数组，起始于 FirstResponder，结束于 UIApplication 用户触摸屏幕后，系统通过 Hit-Test 机制找到响应的 UIView，即 FirstResponder；如果该 UIResponder 不处理该事件，则会交给它 的下一个 UIResponder，如果该 UIResponder 处理则停止，否则继续递归直到响应链结束 UIView 的 nextResponder 属性，如果有管理此 view 的 UIViewController 对象，则为此 UIViewController 对象；否则 nextResponder 即为其 superview UIViewController 的 nextResponder 属性为其管理 view 的 superview UIWindow 的 nextResponder 属性为 UIApplication 对象 UIApplication 的 nextResponder 属性为 nil。 应用寻找 UIView 所在的 Controller123456789101112131415@implementation UIView (Controller)- (UIViewController *)viewController&#123; UIResponder *responder = [self nextResponder]; while (responder) &#123; if ([responder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)responder; &#125; responder = [responder nextResponder]; &#125; return nil;&#125;@end 扩大按钮点击区域重写以下方法即可 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; CGRect relativeFrame = self.bounds; // 上下左右扩大 15 像素 UIEdgeInsets hitTestEdgeInsets = UIEdgeInsetsMake(-15, -15, -15, -15); CGRect hitFrame = UIEdgeInsetsInsetRect(relativeFrame, hitTestEdgeInsets); return CGRectContainsPoint(hitFrame, point);&#125; 子 view 超出了父 view 的 bounds 响应事件正常情况下，子 View 超出父 View 的 bounds 的那一部分是不会响应事件的 解决方法1：重写父 View 的 pointInside 方法 这种方法会导致如果点击在父 View （而不是其子 View）上时，不会再响应任何事件，父 View 就像变透明了一样 1234567891011121314- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 这是默认实现 // return CGRectContainsPoint(self.bounds, point); for (UIView *view in self.subviews) &#123; if (CGRectContainsPoint(view.frame, point)) &#123; return YES; &#125; &#125; return NO;&#125; 解决方法2：重写父 View 的 hitTest 方法（推荐） 1234567891011121314151617181920- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; UIView *view = [super hitTest:point withEvent:event]; if (view == nil) &#123; // 如果默认返回 nil，说明此次点击确实不在父 View 范围内 // 此时我们再多加一层判断是否在子 View 内，如果满足则返回子 View for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; CGPoint childP = [self convertPoint:point toView:subview]; UIView *hitView = [subview hitTest:childP withEvent:event]; if (hitView) &#123; return hitView; &#125; &#125; &#125; return view;&#125; 实现一个透明的 View，点击子 View 有效，点击自身无效1234567891011// 播放器中用到的 QNBPlayerIntellectView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; UIView *hitTestView = [super hitTest:point withEvent:event]; // 如果点击的对象是自己，则当没事发生 if (hitTestView == self) &#123; hitTestView = nil; &#125; return hitTestView;&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.956Z","path":"tech/iOS/未分类/启动/","text":"App 的启动流程分为两个阶段：pre-main 和 main 脑图 pre-main 阶段 读取 App 的可执行文件（Mach-O 文件），从里面获得 dyld 的路径 加载 dyld dyld 加载动态库 加载动态库 dyld 从主执行文件的 header 中获取到需要加载的所依赖动态库列表，然后它需要找到每个 dylib，而应用所依赖的 dylib 文件可能会再依赖其他 dylib，最终递归加载所有动态库 rebase 和 binding rebase 修正镜像内部的指针 binding 修正镜像外部的指针 objc setup 注册 objc 类（class registration） 将分类的方法插到类的方法列表里（category registration） 确保 selector 的唯一性（selector uniquing） initializer 调用 objc 类和分类的 load 方法 C++ 的构造函数属性函数 非基本类型的 C++ 静态全局变量的创建（即类 or 结构体） 以上整个过程由 dyld 主导，结束后，dyld 调用真正的 main 函数 小问题：那什么是 Mach-O 呢 Mach-O 是 OSX 和 iOS 系统中可执行文件的格式，主要包括以下几种类型： Executable：应用的主要二进制 Dylib：动态链接库 Bundle：不能被链接，只能在运行时使用 dlopen 加载 Image：镜像文件，包含 Executable、Dylib 和 Bundle Framework：包含 Dylib、资源文件和头文件的文件夹 小问题：dyld 是什么？ dyld（dynamic loader），是苹果的动态链接器，用于加载动态链接库 小问题：为什么需要 rebase 和 binding iOS 采用 ASLR 技术来保证 App 的安全。 ASLR（Address Space Layout Randomization）：地址空间布局随机化，是操作系统中使用的一种安全技术。可执行文件的地址空间有一个起始地址，而 ASLR 使得这个起始地址在 App 每次启动后是随机的。如果是固定的，那么黑客很容易就可以由起始地址+偏移量找到函数的地址 一个 Mach-O 文件内部有很多符号，有指向当前 Mach-O 的，也有指向其他 dylib 的，由于 ASLR 的存在，这些符号的地址都是不对的。 比如在运行时，代码如何准确的找到 printf 函数的地址或者 NSObject 类的地址呢？ rebase 的作用把 Mach-O 文件读入内存，然后在当前 Mach-O 的起始地址添加一个偏移量，以此修正当前可执行文件内部符号的地址，解决可执行文件内部的符号引用。注意 rebase 的意思就是变基，顾名思义，修改的是起始地址 binding 的作用是使用字符串匹配的方式去查找符号表，以修正可执行文件外部符号的地址，解决可执行文件外部的符号引用。这个过程相对于 rebase 会略慢。比如当前的 Mach-O 文件没有 NSObject 这个符号，它是属于 Foundation 框架的，那么 binding 的作用就是将 NSObject 这个符号与其真正的地址进行绑定 小问题：什么是确保 selector 的唯一性 分类有可能有和本类同名的方法，对于普通方法，会优先调用分类的方法；如果不同的分类实现了相同的方法，则编译顺序靠后的会被调用 确保 selector 唯一性就是找到同名方法的真正调用地址 小问题：什么是热启动和冷启动 冷启动是指 app 进程不存在的情况下启动 App，需要创建和初始化进程 热启动是指 app 进程就驻在内存中，进程状态可能是激活的，可能是睡着的，系统将该进程激活，并放到前台。也就是没有了创建和初始化的过程，只有状态的切换 main 阶段dyld 调用 main -&gt; 调用 UIApplicationMain -&gt; 最终调用 didFinishLaunchingWithOptions 优化方法见脑图 参考 iOS启动优化 美团外卖iOS App冷启动治理 关于 rebase 和 binding 的参考","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.956Z","path":"tech/iOS/未分类/弱引用集合对象/","text":"NSPointerArray特性介绍NSPointerArray 是 NSArray 的通用版本，和 NSArray/NSMutableArray 不同的是，NSPointerArray 具有下面这些特性 与 NSArray/NSMutableArray 相对应，NSArray/NSMutableArray 强引用集合对象 NSPointerArray 可以弱引用集合对象，一旦对象没人持有了，NSPointerArray 中对应的项会被变成 NULL NSPointerArray 是可变的，没有不可变的版本 NSPointerArray 可以存储 NULL，NULL 参与 count 计算 NSPointerArray 的 count 可以被设置，如果直接设置 count，多余的位置会使用 NULL 占位 NSPointerArray 存储的是指针类型 void * 而不是对象，所以需要 __bridge 进行转换 使用 addPointer 和 pointerAtIndex 来存取指针 初始化参数12- (instancetype)initWithOptions:(NSPointerFunctionsOptions)options;- (instancetype)initWithPointerFunctions:(NSPointerFunctions *)functions; 首先来看一下 NSPointerFunctionsOptions，它是个 option，主要分为三大类： 内存管理 NSPointerFunctionsStrongMemory：默认值，强引用集合对象 NSPointerFunctionsZeroingWeakMemory：废弃 NSPointerFunctionsMallocMemory 与 NSPointerFunctionsMachVirtualMemory： 用于 Mach 的虚拟内存管理 NSPointerFunctionsWeakMemory：弱引用集合对象 特性，用于标明对象判等方式 NSPointerFunctionsObjectPersonality：hash、isEqual、对象描述 NSPointerFunctionsOpaquePersonality：pointer 的 hash 、直接判等 NSPointerFunctionsObjectPointerPersonality：pointer 的 hash、直接判等、对象描述 NSPointerFunctionsCStringPersonality：string 的 hash、strcmp 函数、UTF-8 编码方式的描述 NSPointerFunctionsStructPersonality：内存 hash、memcmp 函数 NSPointerFunctionsIntegerPersonality：值的 hash 内存标识 NSPointerFunctionsCopyIn：根据第二类的选择，来具体处理。如果是 NSPointerFunctionsObjectPersonality，则根据 NSCopying 来拷贝 这里只关注弱引用，对象判别方式和 NSPointerFunctions 的初始化不展开 提供 compact 方法剔除 NULL 元素NSPointerArray 可以存储 NULL，作为补充，它也提供了 compact 方法，用于剔除数组中为 NULL 的成员。但是 compact 函数有个已经报备的 bug，每次 compact 之前需要添加一个 NULL，否则会 compact 失败 弱引用测试代码1234567891011121314151617NSPointerArray *pointerArray = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory];@autoreleasepool&#123; NSObject *obj = [NSObject new]; [pointerArray addPointer:(__bridge void *)obj]; NSLog(@&quot;NSPointerArray is: %p count: %@&quot;, [pointerArray pointerAtIndex:0], @(pointerArray.count)); // 输出 NSPointerArray is: 0x60000000e800 count: 1&#125;NSLog(@&quot;After Release NSPointerArray is: %p count: %@&quot;, [pointerArray pointerAtIndex:0], @(pointerArray.count));// 输出 After Release NSPointerArray is: 0x0 count: 1 // 每次 compact 之前需要添加 NULL，规避系统 Bug[pointerArray addPointer:NULL]; [pointerArray compact]; NSLog(@&quot;After Compact NSPointerArray count: %@&quot;, @(pointerArray.count));// 输出 After Compact NSPointerArray count: 0 与 NSArray/NSMutableArray 的区别 NSArray/NSMutableArray 配合 NSValue 可以实现数组的弱引用 1234567NSMutableArray *array = @[].mutableCopy;// 添加NSObject *obj = [NSObject new];[array addObject:[NSValue valueWithNonretainedObject:obj]];// 读取NSValue *value = array[0];NSObject *obj2 = [value nonretainedObjectValue]; 注意：使用 NSValue 的方式，确实可以实现对对象的弱引用（即被添加到集合中时，对象的引用计数不会+1），但是当对象被释放的时候，数组中对应的对象会变成野指针，因此需要手动删除 NSArray 中对应对象的值，否则会在执行 [value nonretainedObjectValue] 时崩溃；而使用 NSPointerArray 不会有这个问题，对象的释放会使得集合中的对象变为 NULL NSHashTable特性介绍NSHashTable 是 NSSet 的通用版本，和 NSSet / NSMutableSet 不同的是，NSHashTable 具有下面这些特性 与 NSSet/NSMutableSet 相对应，NSSet/NSMutableSet 强引用集合对象 NSHashTable 可以弱引用集合对象，一旦对象没人持有了，NSHashTable 中的值也会被移除 NSHashTable 是可变的，没有不可变的版本 除了存储对象，NSHashTable 也可以存储任意指针，比如 void * 初始化参数可以在初始化 NSHashTable 时指定 NSHashTableOptions 来确定其内存引用 1+ (NSHashTable&lt;ObjectType&gt; *)hashTableWithOptions:(NSPointerFunctionsOptions)options; NSHashTableOptions 的取值如下： NSHashTableStrongMemory: 默认值，强引用集合对象，与 NSSet 一样 NSHashTableWeakMemory: 弱引用集合对象 NSHashTableZeroingWeakMemory: 废弃，请使用 NSHashTableWeakMemory NSHashTableCopyIn: 在将对象添加到集合之前，会拷贝对象 NSHashTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等 弱引用测试代码12345678910NSHashTable *hashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];@autoreleasepool &#123; NSObject *obj = [NSObject new]; [hashTable addObject:obj]; NSLog(@&quot;hashTable is: %@&quot;, hashTable); // hashTable is: NSHashTable &#123;[3] &lt;NSObject: 0x6000035e3f60&gt;&#125;&#125; NSLog(@&quot;hashTable is: %@&quot;, hashTable);// hashTable is: NSHashTable &#123;&#125; NSMapTable特性介绍NSMapTable 是 NSDictionary 的通用版本，和 NSDictionary/NSMutableDictionary 不同的是，NSMapTable 具有下面这些特性 与 NSDictionary/NSMutableDictionary 相对应，NSDictionary/NSMutableDictionary 对 Key 拷贝，对 Value 强引用 key 和 value 的内存管理方式可以分开，如：key 是强引用，value 是弱引用 NSMapTable 可以弱引用 Key 和 Value，一旦 Key 或 Value 中的某一个没人持有了，NSMapTable 中对应的项也会被移除 NSMapTable 是可变的，没有不可变的版本 除了存储对象，NSMapTable 也可以存储任意指针，比如 void * 总结起来一共有 4 种可能： key 为 strong，value 为 strong key 为 strong，value 为 weak key 为 weak，value 为 strong key 为 weak，value 为 weak 当用 weak 修饰 key 或 value 时，有一方被释放，则该键值对移除。 初始化参数可以在初始化 NSMapTable 时指定 NSPointerFunctionsOptions 来分别确定对 Key 和 Value 的内存引用 1+ (NSMapTable&lt;KeyType, ObjectType&gt; *)mapTableWithKeyOptions:(NSPointerFunctionsOptions)keyOptions valueOptions:(NSPointerFunctionsOptions)valueOptions; NSMapTableStrongMemory: 默认值，强引用 Key/Value NSMapTableWeakMemory: 弱引用 Key/Value NSHashTableZeroingWeakMemory: 废弃，请使用 NSMapTableWeakMemory NSMapTableCopyIn: 在将对象添加到集合之前，会拷贝对象 NSMapTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等 弱引用测试代码123456789101112NSMapTable *mapTable = [NSMapTable weakToStrongObjectsMapTable];@autoreleasepool &#123; NSObject *key = [NSObject new]; NSObject *value = [NSObject new]; [mapTable setObject:value forKey:key]; NSLog(@&quot;mapTable is: %@&quot;, mapTable); // mapTable is: NSMapTable &#123;&lt;NSObject: 0x6000008df890&gt; -&gt; &lt;NSObject: 0x6000008df870&gt;&#125;&#125; NSLog(@&quot;mapTable is: %@&quot;, mapTable);// mapTable is: NSMapTable &#123;&#125;// key 是 weak 引用，所以析构之后 NSMapTable 就会移除对应的项 何时使用NSHashTable 和 NSMapTable 都比 NSSet 和 NSDictionary 都更加强大，但是大部分情况下，我们用 NSSet 和 NSDictionary 就已经足够，只有在对内存有特别要求的情况下，才使用 NSHashTable 和 NSMapTable 参考文章 NSHash​Table &amp; NSMap​Table Cocoa 集合类型：NSPointerArray，NSMapTable，NSHashTable","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.956Z","path":"tech/iOS/未分类/杂/","text":"NSNotification 接收通知时所在的线程取决于发送的线程还是注册的线程发送的线程。 如果是注册的线程，则 NSNotificationCenter 需要维护监听者和其注册时所在线程的表，实现较为复杂；其次注册时所在的线程有可能被销毁，等到接收通知时不一定存在 如果是子线程发送通知，如何在主线程接受通知1234567[[NSNotificationCenter defaultCenter] addObserverForName:@&quot;MyNoti&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@&quot;我在主线程接收到通知&quot;);&#125;];dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;MyNoti&quot; object:nil];&#125;); 多线程比较 Xcode 编译基本的编译过程分为四个步骤： 预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s 文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对.o 文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link） 内存分布 栈区 0x7 开头 通常存放局部变量、函数参数等。栈在运行时可动态地扩展和收缩 栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是一个编译时就确定的常数，如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 堆区 0x6 开头 那些由 new/alloc 创建的对象所分配的内存块，内存由开发者申请和销毁；堆在运行时可动态地扩展和收缩 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 静态区(未初始化数据) bss 段 存放未初始化的全局变量和静态变量，程序结束后由系统释放；如 int a; 常量区(已初始化数据) data 段 专门用于存放常量，程序结束后由系统释放；如 int a = 0; 代码区 用于存放程序运行时的代码，代码会被编译成二进制存进内存的程序代码区 全局区又可分为未初始化全局区：.bss 段和初始化全局区：data 段 栈区从上往下走，堆区会从下往上走，当两个相遇的时候，则会发生堆栈溢出 123456789101112int a = 10; // 全局初始化区char *p; // 全局未初始化区int main()&#123; int b; // 栈 char s[] = &quot;abc&quot; // 栈 char *p1; // 栈 char *p2 = &quot;123456&quot;; // 123456 在常量区，p2 在栈上。 static int c =0； // 全局（静态）初始化区 int array = new int[10]; // 堆&#125; 卡顿检测 方案一：基于RunloopMatrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。 子线程 Ping 锁 自旋锁 dispatch_semaphore 递归锁 NSLock NSConditionLock pthread_mutex 互斥锁 @synchronized dispatch_barrier_async atomic https://bestswifter.com/ios-lock/ 内存检测 hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法 调用以下代码，有误判，需要建立白名单 1234567- (BOOL)willDealloc &#123; __weak id weakSelf = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [weakSelf assertNotDealloc]; &#125;); return YES;&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.956Z","path":"tech/iOS/未分类/离屏渲染/","text":"layer.cornerRadius 不会触发离屏渲染，该属性只是对边框和背景颜色起作用，适用于内部没有其他控件的 view。 CAShapeLayer+UIBezierPath 会触发离屏渲染。 最好的方式就是使用 Core Graphics 的方式绘制圆角图片。 当然，还是那句话，根据场景来使用，如果界面中圆角的地方不多，第一种方式是最简单快捷，效率最高的。如果用到的圆角很多，那还是使用 Core Graphics 的方式 场景 cornerRadius+clipsToBounds shadow group opacity mask UIBlurEffect AsyncDisplayKit(Texture) 作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看我之前的一些介绍 对于图片的圆角，使用 CoreGraphics 为图片裁剪圆角 对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的 layer 盖住四个角，从视觉上制造圆角的效果 对于 view 的圆形边框，如果没有 backgroundColor，可以放心使用 cornerRadius 来做 对于所有的阴影，使用 shadowPath 来规避离屏渲染 对于特殊形状的 view，使用 layer mask 并打开 shouldRasterize 来对渲染结果进行缓存对于模糊效果，不采用系统提供的 UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果 https://zhuanlan.zhihu.com/p/72653360http://lemon2well.top/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/https://bestswifter.com/efficient-rounded-corner/","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/Runtime/weak 的实现原理/","text":"本文解决的问题 weak 的代码实现原理 当对象释放的时候，如何实现将 weak 指针置为 nil weak 指针的线程安全 阅读本文的前提1id __weak weakObj = obj; obj 在本文中称之为【被引用对象】，即 referent weakObj 在本文中称之为【弱引用对象】，即 referrer weak 的代码实现原理以上例子中的代码的 Clang 实现如下 12id weakObj;objc_initWeak(&amp;weakObj, obj); objc_initWeak 源码 12345id objc_initWeak(id *addr, id val) &#123; *addr = 0; // 初始化 weakObj = nil if (!val) return nil; // 判空 return objc_storeWeak(addr, val);&#125; 简化版 objc_storeWeak 源码 1234567891011121314151617181920id objc_storeWeak(id *location, id newObj) &#123; // 获取 oldObj(这个例子中应为 nil) id oldObj = *location; // 获取 oldObj 对应的 SideTable SideTable *oldTable = SideTable::tableForPointer(oldObj); // 获取 newObj 对应的 SideTable SideTable *newTable = SideTable::tableForPointer(newObj); // 从 SideTable 的 weak_table 中移除 oldObj 和它的 weak pointer weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); // 从 SideTable 的 weak_table 中添加 newObj 和它的 weak pointer newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj, location); // 给 weak 指针赋值 *location = newObj; // 这个例子中返回值外部没用到 return newObj;&#125; 相关类的简化版源码 12345678910111213141516// 全局有若干个 SideTable，并不是和 referent 一一对应，多个 referent 可能共享一个 SideTableclass SideTable &#123;private: static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];public: weak_table_t weak_table; RefcountMap refcnts; // 这个是负责引用计数的 static SideTable *tableForPointer(const void *p) &#123; uintptr_t a = (uintptr_t)p; int index = ((a &gt;&gt; 4) ^ (a &gt;&gt; 9)) &amp; (SIDE_TABLE_STRIPE - 1); return (SideTable *)&amp;table_buf[index * SIDE_TABLE_SIZE]; &#125;&#125;; SideTable *oldTable = SideTable::tableForPointer(oldObj); 可能看完这句代码，我们会错以为 SideTable 和 obj 是一一对应的，其实并不是 SideTable 有一个成员 table_buf，它是 static 的，全局唯一 由 tableForPointer 的源码我们可以知道，只是根据对象的地址来获取 table_buf 中的其中一张 SideTable 由此可见，SideTable 并不是和 obj 对象一一对应，而是全局有多份，多个对象可能共享同一个 SideTable 另外，可以看到 SideTable 还负责相关对象的引用计数 123456789101112131415161718192021// 全局的弱引用表，与 SideTable 一一对应，Key 是 referent，值是该对象相关的所有弱引用信息（即 weak_entry_t）struct weak_table_t &#123; weak_entry_t *weak_entries; // 所有 referent 对应的 weak_entry_t，这是一个数组 size_t num_entries; // 一共有多少个 referent，即 weak_entries 数组的长度 ...&#125;;// 负责维护和存储指向一个对象的所有弱引用 hash 表// 与 referent 一一对应struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; // 即被引用的对象 obj struct &#123; weak_referrer_t *referrers; // 所有弱引用该对象的指针的哈希表 ... &#125;&#125;;// The address of a __weak object reference// typedef struct objc_object *id;// 可以看到 weak_referrer_t 其实就是一个 id 的指针typedef objc_object ** weak_referrer_t; 为了更好的理解 weak_table_t 与 obj 之间的对应关系，我们看下 weak_register_no_lock 的实现 123456789101112131415161718192021222324252627282930313233343536// Adds an (object, weak pointer) pair to the weak table.id weak_register_no_lock(weak_table_t *weak_table, id referent, id *referrer) &#123; ... weak_entry_t *entry; // weak_entry_for_referent 的实现应该是，遍历 weak_entries 数组，寻找并返回与 referent 对应的 weak_entry_t if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; // 如果该 referent 已经存在 weak_entry_t（即在此之前已经有弱引用信息），则添加 referrer 到 weak_entry_t append_referrer(entry, referrer); &#125; else &#123; // 如果该 referent 没有 weak_entry_t（即在此之前没有弱引用信息），则新增 weak_entry_t 到 weak_table weak_entry_t new_entry(referent, referrer); weak_entry_insert(weak_table, &amp;new_entry); &#125; return referent_id;&#125;// Removes an (object, weak pointer) pair from the weak table.void weak_unregister_no_lock(weak_table_t *weak_table, id referent, id *referrer) &#123; if (!referent) return; weak_entry_t *entry; // weak_entry_for_referent 的实现应该是，遍历 weak_entries 数组，寻找并返回与 referent 对应的 weak_entry_t if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; // 如果该 referent 已经存在 weak_entry_t（即在此之前已经有弱引用信息），则从 weak_entry_t 中删除 referrer // remove_referrer 这个方法会把这个 referrer 置为 nil（这个就是 weak 指针自动变 nil 的原因哦） remove_referrer(entry, referrer); // 视情况从 weak_table 中删除 referent 对应的 weak_entry_t ... if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // 如果调用正确，理论上 weak_entries 数组应该会有 referent 的 weak_entry_t 信息&#125; 当对象释放的时候，如何实现将 weak 指针置为 nil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// NSObject.m- (void)dealloc &#123; _objc_rootDealloc(self);&#125;void _objc_rootDealloc(id obj) &#123; obj-&gt;rootDealloc();&#125;void objc_object::rootDealloc() &#123; ... object_dispose((id)this);&#125;id object_dispose(id obj) &#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125;void *objc_destructInstance(id obj) &#123; if (obj) &#123; bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); obj-&gt;clearDeallocating(); &#125; return obj;&#125;// 没找到 clearDeallocating 源码，但是大致实现如下void objc_object::clearDeallocating() &#123; SideTable *table = SideTable::tableForPointer(this); weak_clear_no_lock(&amp;table-&gt;weak_table, (id)this);&#125;void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; // 从 weak_table 中寻找该 referent 对应的 weak_entry_t weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); weak_referrer_t *referrers; size_t count; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); // 清除所有 referrer 的值 for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; // referrer 指向的值，不出意外应该与 referent 相等 if (*referrer == referent) &#123; // 置空，这个就是为什么 weak 会自动置 nil 的原因 *referrer = nil; &#125; &#125; &#125; // 从 weak_table 中删除对应的 weak_entry_t weak_entry_remove(weak_table, entry);&#125; 可以看到对象释放时会调用 dealloc， 一步步调用到了 clearDeallocating，然后调用 tableForPointer 寻找对应的 SideTable，拿到 weak_table_t 最终调用 weak_clear_no_lock，将所有的 referrer 指向的值（即 weak 指针），置为 nil，并从 weak_table_t 表中删除该对象的 weak_entry_t 通俗解释： 系统会把 weakObj 会放入一个 hash 表中。 用 obj 的内存地址作为 key，当 obj 的引用计数为 0 的时候会执行其 dealloc，此时会在这个 weak 表中搜索，找到所有以 &amp;obj 为 key 的对象，设置为 nil weak 指针的线程安全问题：当一个对象正在 delloc 时，如果在另一个线程获取了 weak 指针，这时获取到的 weak 指针有没有可能是野指针？ 以下的代码例子模拟了这样一个过程，多个线程正在访问 weakObj，其中一个线程对 self.obj 释放了 123456789101112131415161718// @property (nonatomic, strong) NSObject *obj;self.obj = [NSObject new];int n = 500;while (n--)&#123; __weak NSObject *weakObj = self.obj; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; if (n == 480) &#123; self.obj = nil; &#125; int m = 1000; while (m--) &#123; NSLog(@&quot;%@----%@&quot;, weakObj, @(n)); &#125; &#125;);&#125; 结论：不会挂，不可能是野指针。weak 的访问是线程安全的 123Person *obj = [[Person alloc] init];id __weak weakObj = obj;NSLog(@&quot;%@&quot;, weakObj); 通过 clang -rewrite-objc MyBlock.c 重写后得到的伪代码 1234567id weakObj;objc_initWeak(&amp;weakObj, obj);// 注意 NSLog(@&quot;%@&quot;, weakObj) 转为以下代码id tmp = objc_loadWeakRetained(&amp;obj);NSLog(@&quot;%@&quot;, tmp);objc_release(tmp); 当我们访问 weakObj 的时候，编译器会转为 objc_loadWeakRetained 123456789101112131415161718192021222324252627282930313233343536id objc_loadWeakRetained(id *location)&#123; id obj; id result; Class cls; SideTable *table; retry: obj = *location; if (!obj) return nil; if (obj-&gt;isTaggedPointer()) return obj; table = &amp;SideTables()[obj]; table-&gt;lock(); if (*location != obj) &#123; table-&gt;unlock(); goto retry; &#125; result = obj; cls = obj-&gt;ISA(); if (! cls-&gt;hasCustomRR()) &#123; // 一般情况下会走到这里 if (! obj-&gt;rootTryRetain()) &#123; result = nil; &#125; &#125; else &#123; // 此处省略不重要的代码... &#125; table-&gt;unlock(); return result;&#125; 获取 weak 指针时，会调用 objc_loadWeakRetained 不讨论 isTaggedPointer 这种特殊情况 hasCustomRR 在重写 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 等方法时会返回true，一般情况会返回 false。这里只讨论返回 false 的情况 rootTryRetain 会尝试对该对象进行 retain，里面会判断该对象是否正在 deallocating，如果是则返回 nil 通俗概括以上代码：获取 weak 时调用 objc_loadWeakRetained，获取过程会加锁。如果该对象已经释放或正在释放则返回 nil，否则对该对象进行 retain 并返回。因此我们得出结论：对 weak 指针的访问是线程安全的 那么问题来了，既然有 retian，那什么时候 release 呢？答案是 ARC 下会在 weak 指针访问完成后，自动插 release 代码，如下 1234// 注意 NSLog(@&quot;%@&quot;, weakObj) 转为以下代码id tmp = objc_loadWeakRetained(&amp;obj);NSLog(@&quot;%@&quot;, tmp);objc_release(tmp); 参考 Runtime如何实现weak属性？ objc-weak.h 源码 SiteTable 源码 详解获取weak对象的过程","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/Runtime/关联对象的实现原理/","text":"提问 关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？ 为什么 AssociationsHashMap 是使用 unordered_map，而 ObjectAssociationMap 使用 map 使用关联对象有什么需要注意的地方 为什么内存管理策略中没有 weak 选项，即 OBJC_ASSOCIATION_WEAK 阅读本文的前提1objc_setAssociatedObject(self, @selector(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 其中 self 我们称之为被关联对象，proxy 我们称之为 关联对象 关键数据结构理解好以下几个结构之后，几乎不需要看源码就能推测 set/get 的原理 AssociationsManager单例，全局唯一 AssociationsHashMapAssociationsManager 的属性，全局唯一 std::unordered_map，存放对象与 ObjectAssociationMap（这里的对象指的是添加属性的分类） ObjectAssociationMapstd::map，存放 key 与 ObjcAssociation ObjcAssociation存放 value 和 policy 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy)&#123; // 初始化一个旧值 ObjcAssociation old_association(0, nil); // acquireValue 会对新的值进行 retain or copy，可以看下下面的源码 id new_value = value ? acquireValue(value, policy) : nil; &#123; // 全局单例 AssociationsManager manager; // 全局的 unordered_map AssociationsHashMap &amp;associations(manager.associations()); // 将被关联对象转化一下，DISGUISE 仅仅对 object 做了位运算 disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // 新值不为空，则开始插入 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // 如果被关联对象已经在全局的 unordered_map 注册过，则找到对应的 map ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // map 找到了则记录旧值以备释放，并更新新值 old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; // map 找不到则直接插入 (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // 如果被关联对象没有在全局的 unordered_map 注册过，则创建 map 并注册 ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; // 将值插入到新的 map 中 (*refs)[key] = ObjcAssociation(policy, new_value); _class_setInstancesHaveAssociatedObjects(_object_getClass(object)); &#125; &#125; else &#123; // 新的值为空，准备删除旧值（如果有的话） AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // 记录旧值等待释放并从 map 中移除 old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // 释放旧值（如果需要的话） if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 1234567891011static id acquireValue(id value, uintptr_t policy) &#123; switch (policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); case OBJC_ASSOCIATION_SETTER_COPY: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy); &#125; return value;&#125; 12// DISGUISE 仅仅对 object 做了位运算inline disguised_ptr_t DISGUISE(id value) &#123; return ~uintptr_t(value); &#125; 解答 关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？ 关联对象并不是存放在被关联对象本身的内存中，而是存放在一个全局的 unordered_map 中 其中 unordered_map 存储着被关联的对象与 map，其中 map 存放着关联对象的 key 和关联对象 获取关联对象时，首先通过被关联对象的地址找到 map，然后通过关联对象的 key 找到关联对象并返回 为什么 AssociationsHashMap 是使用 unordered_map，而 ObjectAssociationMap 使用 map unordered_map 查找更加高效，大多数情况下应该选择 unordered_map，而 ObjectAssociationMap 使用 map 应该是出于内存考虑 详细可参考 unordered_map 与 map 的区别 为什么内存管理策略中没有 weak 选项，即 OBJC_ASSOCIATION_WEAK 可参考 如何为分类添加属性 关联对象如果真的有需要使用 weak 的话，怎么办？ 可参考 如何为分类添加属性 更多阅读 如何为分类添加属性 Objective-C Associated Objects 的实现原理 源码","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/Runtime/分类/","text":"分类的源码123456789struct category_t &#123; const char *name; // 原类名，而不是分类名 // 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象 classref_t cls; struct method_list_t *instanceMethods; // 分类中新增的对象方法列表 struct method_list_t *classMethods; // 分类中新增的类方法列表 struct protocol_list_t *protocols; // 分类中新增的协议列表 struct property_list_t *instanceProperties; // 分类中新增的属性列表&#125;; 分类为什么不能添加实例变量 从底层结构上看：没有实例变量的相关字段，所以分类是无法添加实例变量的（即分类在编译时无法保存实例变量的信息，而 instanceProperties 的存在说明属性是可以的） 从内存结构上看：在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局（即使分类保存了实例变量的信息，运行时也无法向本类添加实例变量） 如何理解在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局？ 那为什么添加方法就不会呢？还得从 objc_class 的结构说起 注：本文关于 objc_class 的源码都是基于老版本的源码，其结构更容易理解 1234567891011121314151617struct objc_class&#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 1234567891011struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE; /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; struct objc_ivar &#123; char *ivar_name OBJC2_UNAVAILABLE; char *ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;&#125; 可以看到，ivars 是一个一级指针，指向的是一个 objc_ivar_list 类，其中 ivar_list 的大小是可变的；这个可以在 class_addIvar 的实现中找到 123456789101112131415161718192021222324252627282930313233343536BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *type)&#123; ivar_list_t *oldlist, *newlist; if ((oldlist = (ivar_list_t *)cls-&gt;data()-&gt;ro-&gt;ivars)) &#123; size_t oldsize = oldlist-&gt;byteSize(); // 重新分配内存，影响的是 ivar_list 的大小 newlist = (ivar_list_t *)calloc(oldsize + oldlist-&gt;entsize(), 1); memcpy(newlist, oldlist, oldsize); free(oldlist); &#125; else &#123; newlist = (ivar_list_t *)calloc(sizeof(ivar_list_t), 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(ivar_t); &#125; uint32_t offset = cls-&gt;unalignedInstanceSize(); uint32_t alignMask = (1&lt;&lt;alignment)-1; offset = (offset + alignMask) &amp; ~alignMask; // 对这块内存进行复写 ivar_t&amp; ivar = newlist-&gt;get(newlist-&gt;count++); ivar.offset = (int32_t *)malloc(sizeof(int32_t)); *ivar.offset = offset; ivar.name = name ? strdupIfMutable(name) : nil; ivar.type = strdupIfMutable(type); ivar.alignment_raw = alignment; ivar.size = (uint32_t)size; // 重新指向这个新的 list ro_w-&gt;ivars = newlist; // 更新 instance_size cls-&gt;setInstanceSize((uint32_t)(offset + size)); return YES;&#125; 调用 class_addIvar 会添加一个实例变量，影响 instance_size 和 ivars 所指向的空间的大小。但是仍然无法解释为什么不能添加 ivars 此时还得知道一个 ivar 是如何被系统访问的，如果按照以下这种方式访问 ivar，整个流程要经过好多次指针转移： 12class -&gt; class.rw_data -&gt; class.rw_data.ro_data -&gt; class.rw_data.ro_data.ivars -&gt; -&gt; class.rw_data.ro_data.ivars.first[n] 如果是这样，那么动态添加 ivar 似乎变得可行，因为 ivar 是指针，往指针指向的内容扩充并不会影响类的大小，访问时只要遍历所有 ivar list 就可以找到对应的 ivar，但是这样访问，大量使用 ivar 肯定很耗时。事实上 Runtime 不是这样访问 ivar 的 那么，对于 ivar 的访问究竟是怎么样的呢？ 这篇 《谈谈 ivar 的直接访问》 提到，对 ivar 的访问，其实是在编译期将 ivar 相对于类本身的偏移量存储在一个全局变量里，全局变量的值在编译的时候就确定了，这个全局变量的地址就存在 objc_ivar 的 ivar_offset 即编译时，系统会将对这个 ivar 的读写访问的代码转为，本类地址加上对应的全局偏移量，就能访问到对应 ivar 的值。 12@property (nonatomic, assign) NSInteger myInt;self.myInt = 5; 编译后的代码为 12extern &quot;C&quot; unsigned long OBJC_IVAR_$_MyObject$_myInt;(*(NSInteger *)((char *)self + OBJC_IVAR_$_MyObject$_myInt)) = 5; 而正是由于这种关系，在运行时如果想添加一个 ivar，势必会导致所有全局偏移量不正确 有人会说，如果加在 ivar list 的前面会影响旧的 ivar 的全局偏移量，那加在 ivar list 后面不就影响不了吗？答案是，类是可以被继承的，给父类的 ivar list 尾部添加一个 ivar，尽管不影响父类自己的 ivar 偏移，却影响了子类的 ivar 偏移 这个就是所谓的在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局 对于方法的访问与 ivar 的访问不同，是通过 objc_msgSend 找到对应的方法列表，所以可以动态添加方法 那运行时如何给类添加实例变量呢？ 只能在 objc_allocateClassPair 与 objc_registerClassPair 两个函数之间为类添加变量 1234Class class = objc_allocateClassPair(NSObject.class, &quot;Sark&quot;, 0);class_addIvar(class, &quot;_girlFriend&quot;, sizeof(id), log2(sizeof(id)), @encode(id));class_addIvar(class, &quot;_company&quot;, sizeof(id), log2(sizeof(id)), @encode(id));objc_registerClassPair(class); 分类方法的加载与覆盖我们主要探究四个问题： 分类的方法什么时候被添加到本类 分类的方法在运行时会覆盖本类，那么在内存结构中是否覆盖了本类 分类在运行时是怎么覆盖本类方法 如果有多个分类有同名的方法，其调用顺序是怎样的 分类插入本类方法的源码启动时，_objc_init 里面的调用的 map_images 最终会调用 objc-runtime-new.mm 里面的 _read_images 方法有以下的代码片段，我们删除一些无用代码得到 注：如果一个类实现了 +load 方法，那么它就会在启动时被加载，会调用 realizeClass 进行加载，加载后 isRealized 将会返回 true；如果没实现 +load 方法，那么就会懒加载这个类，直到给这个类发送消息时才会去 realizeClass。懒加载和非懒加载处理分类的时机是不一样的，但是原理大致相同。我们这里只讨论类和分类都实现了 +load 的情况，更多情况请参考 iOS 底层探索 - 分类的加载 以下是处理分类的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// Discover categories. for (EACH_HEADER) &#123; // hi 表示 headerInfo // 从每一个 headerInfo 中获取分类列表以及分类个数 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); // 注意这里的 count 指的是一个头文件定义的分类个数 for (i = 0; i &lt; count; i++) &#123; // 获取分类实例 category_t *cat = catlist[i]; // 获取分类指向的本类 Class cls = remapClass(cat-&gt;cls); // 处理本类不存在的异常 if (!cls) &#123; // 此处省略... continue; &#125; // 开始处理分类 // 第一步，注册分类到本类（addUnattachedCategoryForClass） // 第二步，重建这个类的方法列表（remethodizeClass） // 处理实例方法、协议、属性 if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); &#125; &#125; // 按照同样的逻辑处理类方法、协议、类属性 if (cat-&gt;classMethods || cat-&gt;protocols) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; &#125; &#125;&#125; 这段代码主要告诉我们，在启动初始化 objc 的时候分类的方法列表会被插到本类的方法中 它主要实现了，遍历所有头文件获取所有分类列表，并对每个分类： 把 category 的实例方法、协议以及属性添加到类上 把 category 的类方法和协议添加到类的 metaclass 上 这里我们只研究实例方法的插入，其他项是同理的 addUnattachedCategoryForClass 只是负责把类和 category 做一个关联映射，并没有修改类的结构，我们暂不关心 真正生效的是 remethodizeClass，它负责重新对方法列表进行排列，但其实也是一个壳，主要调用了 attachCategories 注：由于我们对分类和类写了 +load，所以执行到这里的时候，类已经被加载过了，所以 isRealized 是 true 1234567891011// 重新对方法列表进行排列static void remethodizeClass(Class cls)&#123; category_list *cats; // unattachedCategoriesForClass，我们暂不关心 if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; attachCategories(cls, cats, true /*flush caches*/); free(cats); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; bool isMeta = cls-&gt;isMetaClass(); // 本类的所有分类的所有方法列表 method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); // 本类的所有分类的所有属性列表 property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); // 本类的所有分类的所有协议列表 protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // 方法个数 int mcount = 0; // 属性个数 int propcount = 0; // 协议个数 int protocount = 0; // 分类的个数，这里一般是 1 个，因为参数是每个头文件中的每个分类 int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; // 从后往前数，获取每一个分类 auto&amp; entry = cats-&gt;list[i]; // 处理方法 // 获取该分类的所有方法 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; // 并插到临时变量 mlists 的尾部 // 注意分类的遍历顺序，最终会导致分类列表中靠后的分类的方法排在 mlists 前面 mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 处理属性列表，同理 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 处理协议，同理 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; // rw 代表原类的信息 auto rw = cls-&gt;data(); // 这里会对同个分类的方法进行排序，比如 test2 排在 test 前面 prepareMethodLists(cls, mlists, mcount, NO, fromBundle); // 将获取到的分类的所有方法，添加到原类的方法前面 rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 这个方法主要做了两件事，以实例方法为例，属性和协议同理 注意这里虽然是数组，但是一般只有一个类，即 cats-&gt;count = 1 把所有分类的方法读取出来放到一个数组里，越靠后的分类的方法在数组中的位置越靠前 把这个方法数组添加到原类方法的首部，见 attachLists 12345678910111213141516171819202122232425262728293031void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; // void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1 memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125;&#125; 关于 attachLists 方法，就是分类方法覆盖本类方法的关键所在 首先，我们要明确，每次进入这个方法的参数 addedLists，是指一个分类的所有方法；这个方法实现的是将一个分类的所有方法添加到类结构的方法列表前面（虽然这里的参数可能是一个 method_list_t，不过实测下来这个数组只会有一个元素，因此暂时理解为一个元素） 然后我们看看这里是怎么实现的，这里主要处理如何将一个元素添加进数组，根据数组的情况分为 3 种情况 类的方法列表中没有 method_list_t 时，把单个新增元素这个赋值给指针（0 lists -&gt; 1 list） 类的方法列表中只有一个 method_list_t 时，重新申请内存，把老的第 0 个元素挪到最后，再把新增元素拷贝到最前 类的方法列表中有多个 method_list_t 时，重新申请内存，把老的元素通过 memmove 挪到最后，再把新增元素拷贝到最前 如果一个类自身没有声明方法时，当第一个分类进来的时候就会进到情况 1；再继续处理第二个分类或者本类已经有方法的时候回进入到情况 2，其他会进入情况 3。这一点还是很好理解的，主要看现在的类结构里面有没有方法列表 void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1 void *memcpy(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1 在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。 加载分类同名方法的源码我们先看看 objc_class 结构中 methodLists 这个二级指针。首先，**methodLists 是个二级指针，它指向的是一个数组，这个数组就是由 objc_method_list 构成，它是一个一维数组，即 *methodLists，如下图 注：在最新的 Runtime 源码中，objc_method_list 被替换为 method_list_t，所以 methodLists 也可以看是 method_list_t 的二级指针 假如本类有 a、b 方法，分类 1 有 a、c、d 方法，分类 2 有 a、e 方法，分类 1 先声明，则 methodLists 的方法列表应该如下 1*methodLists = [[a, e], [a, c, d], [a, b]]; 其中 [a, e]、[a, c, d] 和 [a, b] 都是一个 method_list_t。 从 category_t 的结构中我们可以看出，一个分类拥有一个 method_list_t，即分类本身的方法列表；而本类的方法列表存放的是一个指针，指向的是一个数组，这个数组的元素是 method_list_t 关于这个数据结构的证明我们除了从这篇文章可以得到 二级指针指向的数据结构是什么样的？，也可以从方法的调用中一探究竟 首先，我们看下方法调用的栈 1objc_msgSend -&gt; _class_lookupMethodAndLoadCache3 -&gt; lookUpImpOrForward lookUpImpOrForward 关键代码如下 12345678910111213141516171819IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)// 省略其他代码// 1. 找缓存imp = cache_getImp(cls, sel);if (imp) goto done;// 2. 找本类&#123; Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125;&#125;// 3. 找父类// 省略其他代码 可以看到先找缓存，再找本类，最后找父类，最关键的是 getMethodNoSuper_nolock，源码如下 12345678910111213141516static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123; runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) &#123; method_t *m = search_method_list(*mlists, sel); if (m) return m; &#125; return nil;&#125; 注意这里的 methods 是 objc_class 中的结构，是新版本源码，我们这里关于 objc_class 是老的源码，但这并不妨碍我们理解 objc_class 的 methods 是一个二级指针，其指向一个数组，数组的每个元素都是一个 method_list_t * cls-&gt;data()-&gt;methods.beginLists() 返回的是该数组的第一个元素的迭代器（类比 C++ STL 中的 list 的 begin()），对其解引用后可以得到一个 method_list_t *。这个也是 search_method_list 的入参 search_method_list 的源码可以直接简化如下，对这个一维数组进行顺序查找，找到立刻返回 1234567static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; return nil;&#125; 总结成一句话就是，方法查找时，从类的 method 列表中开始顺序查找，列表的每个元素是一个 method_list_t，这个结构里面存储着一个分类或本类的方法列表，遍历这个 method_list_t 与调用的方法的名字是否一致，一致则返回 结论 分类的方法什么时候被添加到本类 答：在启动的时候，objc_setup 阶段会进行 objc 类的注册，将分类的方法插到本类的方法列表 分类的方法在运行时会覆盖本类，那么在内存结构中是否覆盖了本类 答：对于 load 方法来说比较特殊，见下节；对于普通方法来说，内存结构中分类的方法并没有覆盖本类，而是插到了本类的方法列表前面 分类在运行时是怎么覆盖本类方法 答：objc_msgSend 时，会从类的方法列表中查找对应的 method，是从头往后查找的，由于分类的方法被插在了本类的方法前面，因此会优先找到，从而达到了覆盖的效果 如果有多个分类有同名的方法，其调用顺序是怎样的 答：分类的顺序是按照在编译选项中的顺序决定的，越靠后的分类的方法会被放到本类方法列表的越前面，会被优先调用到。 如何调试 Runtime可以下载源码 Xcode 11.4 无法编译成功，改为 11.3.1 才可。另外 10.15 系统版本的 Mac 需要选择 Deployment Target 为 10.14 才能编译成功 使用以下源码来判断正在处理哪一个类 1if (strcmp(cls-&gt;data()-&gt;ro-&gt;name, &quot;Person&quot;) == 0) 相关知识如何为分类添加属性关联对象 分类的 load 方法顺序父类 &gt; 本类 &gt; 分类 分类的 initialize 方法顺序父类 &gt; 本类 &gt; 分类 源码链接 objc_msgSend 汇编源码 objc_object 源码 objc_class 源码（老） 其他相关源码 category_t 定义源码","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/Runtime/如何为分类添加属性/","text":"Runtime 原理123456789struct category_t &#123; const char *name; // 原类名，而不是分类名 // 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象 classref_t cls; struct method_list_t *instanceMethods; // 分类中新增的对象方法列表 struct method_list_t *classMethods; // 分类中新增的类方法列表 struct protocol_list_t *protocols; // 分类中新增的协议列表 struct property_list_t *instanceProperties; // 分类中新增的属性列表&#125;; 可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，但不可以添加成员变量 instanceProperties 的存在是我们可以通过 objc_setAssociatedObject 和 objc_getAssociatedObject 向分类中增加实例变量的原因，不过这个和一般的实例变量是不一样的 所以，Category 可以使用 @property，但不会生成带下划线的成员变量，也不会生成 getter 和 setter（@property 只是帮助声明了 setter/getter，并没有提供实现）。我们可以使用 Runtime 为已有的类添加新的属性并生成 getter 和 setter 方法 语法123456void objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy);id objc_getAssociatedObject(id object, void *key);void objc_removeAssociatedObject(id object); // 移除 object 上的所有关联对象 参数说明 id object：被关联的对象（一般为 self） const void *key：关联的key，要求唯一，因此避免使用 @””（一般为新增属性的 getter） id value：关联的对象（一般为新增的属性） objc_AssociationPolicy policy：内存管理的策略 key关联的 key 值有三种推荐值 声明 static char kAssociatedObjectKey;，使用 &amp;kAssociatedObjectKey 作为 key 值 声明 static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey; ，使用 kAssociatedObjectKey 作为 key 值 用 selector ，使用 getter 方法的名称作为 key 值（推荐） 设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。 所以 key 值最好定义为一个全局静态变量，而不能每次都用 @”xxx” 推荐使用 selector，因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性 内存管理策略其中 objc_AssociationPolicy 是关联对象的属性，如下 12345OBJC_ASSOCIATION_ASSIGN --- assignOBJC_ASSOCIATION_RETAIN_NONATOMIC --- nonatomic, retainOBJC_ASSOCIATION_COPY_NONATOMIC --- nonatomic, copyOBJC_ASSOCIATION_RETAIN --- retain(strong)OBJC_ASSOCIATION_COPY --- copy 例子123@interface UIView (VN_ShortCut)@property (nonatomic, weak) UICollectionView *vn_cellCollectionView;@end 1234567891011@implementation UIView (VN_ShortCut)- (UICollectionView *)vn_cellCollectionView &#123; return objc_getAssociatedObject(self, @selector(vn_cellCollectionView));&#125;- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView &#123; objc_setAssociatedObject(self, @selector(vn_cellCollectionView), cellCollectionView, OBJC_ASSOCIATION_ASSIGN);&#125;@end 为什么内存管理策略中没有 weak 选项，即 OBJC_ASSOCIATION_WEAK如果真的有 weak 选项，我们期望的结果是当被关联对象被释放之后，从关联对象身上取出的“属性”是 nil 首先我们要搞懂 weak 属性的实现原理，简单来说，Runtime 在底层维护一个全局的 weak 表，每次当一个 weak 指针被赋值对象的时候，会将对象地址和 weak 指针地址注册到 weak 表中，其中对象地址作为 key；当对象被废弃时，可根据对象地址快速寻找到指向它的所有 weak 指针，并将 weak 指针置为 nil，同时移出 weak 表 所以，实现 weak 的前提是存在一个 weak 指针指向到被引用对象的地址，而通过对以上源码的研究，我们可以知道关联对象和被关联对象之间并没有这样一个 weak 指针，因此无法实现 OBJC_ASSOCIATION_WEAK 更具体的，如下代码，一个 weak 指针或属性，都会在编译时就变转化成 objc_initWeak，这样运行时才能正确往 weak 表里面添加变量。但是关联对象并没有实例变量，所以不能实现 weak 12345678910// 情况 1，weak 变量__weak typeof(self) weakSelf = self; // weakSelf 是指向原对象的指针，会被存进 weak 表// 情况 2，weak 属性@property (nonatomic, weak) id delegate;// 本质是转换为 setter- (void)setDelegate:(id)delegate &#123; if (_delegate != delegate) &#123; objc_initWeak(&amp;_delegate, delegate); &#125;&#125; p.s. 注意这篇文章的解释是错的 如何实现 weak 属性注意 OBJC_ASSOCIATION_ASSIGN 的作用是 assign 而不是 weak，所以当关联的对象被释放的时候并不会被自动置为 nil，因此获取到的对象将会是一个野指针。 直观的方法 1如果要实现 weak 的效果，解决方法是新建一个替身，weak 引用住该对象，然后使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 存储该替身。 以上面的例子为例，代码如下 1234567891011- (UICollectionView *)vn_cellCollectionView&#123; QVNWeakProxy *proxy = objc_getAssociatedObject(self, @selector(vn_cellCollectionView)); return (UICollectionView *)proxy.target;&#125;- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView&#123; QVNWeakProxy *proxy = [[QVNWeakProxy alloc] initWithTarget:cellCollectionView]; objc_setAssociatedObject(self, @selector(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 其中 QVNWeakProxy 只要继承自 NSObject 并拥有一个 weak 的 target 的属性即可 优雅的方法 2变量用 __weak 修饰，因此被 block 捕获的时候不会增加引用计数；block 使用 copy 修饰，可以将栈 block 转为堆 block，防止被释放 123456789101112- (UICollectionView *)vn_cellCollectionView&#123; id (^block)(void) = objc_getAssociatedObject(self, @selector(vn_cellCollectionView)); return (block ? block() : nil);&#125;- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView&#123; id __weak weakObject = cellCollectionView; id (^block)(void) = ^&#123;return weakObject;&#125;; objc_setAssociatedObject(self, @selector(vn_cellCollectionView), block, OBJC_ASSOCIATION_COPY);&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/Runtime/如何为协议添加属性/","text":"如果是协议中的属性，编译器不会自动合成实例变量，相当于只是声明了 setter/getter（注意是声明，没有实现） 第一步，声明协议 123@protocol QVNImageProtocol &lt;NSObject&gt;@property (nonatomic, weak) id&lt;QVNInnerImageLoadDelegate&gt; vn_imageDelegate;@end 第二步，实现协议的人需要自动合成实例变量 123456@interface QVNImageView &lt;QVNImageLoadDelegate&gt;@end@implementation QVNImageView@synthesize vn_imageDelegate;@end 问题来了，自动合成的属性会不会拥有 weak/assign/readonly 等属性呢 实测下来是会的，@synthesize 帮你合成的 setter/getter 会根据协议中 @property 的修饰词来确定 当然你也可以模仿 @synthesize 的作用，手动添加成员变量和 setter/getter 1234567891011121314151617181920@interface QVNImageView &lt;QVNImageLoadDelegate&gt;&#123; __weak id&lt;QVNInnerImageLoadDelegate&gt; _vn_imageDelegate;&#125;@end@implementation QVNImageView- (id&lt;QVNInnerImageLoadDelegate&gt;)vn_imageDelegate&#123; return _vn_imageDelegate;&#125;- (void)setVn_imageDelegate:(id&lt;QVNInnerImageLoadDelegate&gt;)vn_imageDelegate&#123; if (vn_imageDelegate != _vn_imageDelegate) &#123; _vn_imageDelegate = vn_imageDelegate; &#125;&#125;@end 问题：这种情况能否使用 @property 来代替 @synthesize 回答：可以但不建议。因为使用 @property 会有代码重复和歧义，原来协议中定义的修饰符会被你新增的 property 修饰符覆盖，并且后续协议中的属性修改后，这里的代码不会有任何报错","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/Runtime/方法交换/","text":"代码实现1234567891011121314151617181920212223242526void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)&#123; // 获取 Method Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 确保这两个方法一定存在（要么在本类，要么在其父类里） if (originalMethod &amp;&amp; swizzledMethod) &#123; // 如果本类没有 origin 方法，则给 originalSelector 添加 swizzled 实现（origin 方法在父类，因为 originalMethod 不为空），返回 YES // 如果本类有 origin 方法，则添加失败，返回 NO BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; // 添加成功，表示已实现 originalSelector -&gt; swizzledIMP // 接下来实现 swizzledSelector -&gt; originalIMP class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; // 添加失败，表示类里原本就有 originalIMP，只需要交换这两个方法的实现即可 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;&#125; 代码示例： 123456789101112131415161718+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzleMethod(self, @selector(viewDidLoad), @selector(my_viewDidLoad)); &#125;);&#125;- (void)viewDidLoad&#123; [super viewDidLoad];&#125;- (void)my_viewDidLoad&#123; NSLog(@&quot;View Did Load&quot;); [self my_viewDidLoad];&#125; 如何交换类方法 只要把 self 换成 object_getClass(self) 即可 1234567+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzleMethod(object_getClass(self), @selector(originClassMethod), @selector(swizzleClassMethod)); &#125;);&#125; 为什么不能直接调用 method_exchangeImplementations 比如 12345678void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)&#123; // 获取 Method Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125; 直接交换 IMP 是很危险的。因为如果这个类中没有实现这个方法，class_getInstanceMethod() 返回的是某个父类的 Method 对象，这样 method_exchangeImplementations() 就把父类的原始实现（IMP）跟这个类的 Swizzle 实现交换了。这样其他父类及其其他子类的方法调用就会出问题，最严重的就是 Crash。但如果这个类中实现了此方法，那么是没任何问题的 参见：方法交换的图示 方法交换为什么写在 +load 中而不是 initialze 方法交换为什么要 dispatch_once 中执行 参见：iOS 的 initialize 和 load 区别 class_getInstanceMethod1Method class_getInstanceMethod(Class cls, SEL name); 获取指定 SEL 的 Method 如果该类没有指定 SEL 的 Method，父类里面可能有 所以如果该类和其父类都没有该 SEL 的实现，才返回 NULL class_addMethod1BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); 给指定 SEL 添加新实现。如果添加成功则返回 YES，否则返回 NO（比如该类已经有对应 SEL 的 IMP） 注意，该方法会覆盖父类的实现，但不会替换本类原有的实现。如果要替换本类原有实现，使用 method_setImplementation class_replaceMethod1IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types); 替换指定 SEL 的实现，返回值为被替换掉的 IMP 如果本类不存在该 name 的 Method，则 class_addMethod 会被调用 如果本类存在该 name 的 Method，则 method_setImplementation 会被调用 method_exchangeImplementations1method_exchangeImplementations(Method m1, Method m2) 交换两个方法的实现 应用实例 AOP（Aspect of programming），给所有的 Controller 的 viewWillAppear 等生命函数添加数据上报、日志等 API 安全性保护，替换 NSArray 的 addObject 方法，防止插入 nil 对象，Debug 下报错，详见 Github Demo","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/内存管理/Weak-Strong Dance/","text":"Weak-Strong Dance1234__typeof(&amp;*self) __weak weakSelf = self;self.completionHandler = ^(NSInteger result) &#123; [weakSelf.property removeObserver:weakSelf forKeyPath:@&quot;pathName&quot;];&#125;; 假设 block 被放在子线程中执行，而且执行过程中 self 在主线程被释放了。由于 weakSelf 是一个弱引用，因此会自动变为 nil 而这个例子的 KVO 中，这会导致崩溃 解决以上问题的方法很简单，新增一行代码即可 12345__typeof(&amp;*self) __weak weakSelf = self;self.completionHandler = ^(NSInteger result) &#123; __typeof(&amp;*self) __strong strongSelf = weakSelf; [strongSelf.property removeObserver:strongSelf forKeyPath:@&quot;pathName&quot;];&#125;; self 所指向对象的引用计数变成 2，即使主线程中的 self 因为超出作用于而释放，对象的引用计数依然为 1，避免了对象的销毁 Q：下面这行代码，将一个弱引用的指针赋值给强引用的指针，可以起到强引用效果么？ __typeof(&amp;*self) __strong strongSelf = weakSelf; A：会的。引用计数描述的是对象而不是指针。strongSelf 会强引用 weakSelf 指向的那个对象。因此对象的引用计数会加一 Q：block 内部定义了 strongSelf，会不会因此强引用了 strongSelf？ A：不会。block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题 Q：如果在 block 内部没有强引用，而是通过 if 判断，是不是也可以，比如这样写： 1234567__typeof(&amp;*self) __weak weakSelf = self;wself.completionHandler = ^(NSInteger result) &#123; if (weakSelf) &#123; [weakSelf.property removeObserver:weakSelf forKeyPath:@&quot;pathName&quot;]; &#125;&#125;; A：不可以！考虑到多线程执行，也许在判断的时候，self 还没释放，但是执行 self 里面的代码时，就刚好释放了 Q：那按照这个说法，block 内部强引用也没用啊。也许 block 执行以前，self 就释放了 A：有用！如果在 block 执行以前，self 就释放了，那么 block 的引用计数降为 0，所以自己就会被释放。这样它根本就不会被执行 Q：如果在执行 block 的过程中，block 被释放了怎么办？ A：简单来说，block 还会继续执行，但是它捕获的指针会变成 nil 12345__weak ObjectA * weakSelf = self;self.completion = ^&#123; weakSelf.completion = nil; [weakSelf doSomethingElse];&#125;; 当我们这样调用时，执行到 weakSelf.completion = nil 时，block 会被释放但会继续执行，weakSelf 会变为 nil，因此 doSomethingElse 不会被执行 1_completion(); // 直接使用成员变量 如果这样调用就可以避免 block 的释放，这个会在栈上创建一个 block 的 copy，原始的 block 对象会被释放，但是新的对象会继续正常执行，weakSelf 也不会变 nil 1self.completion(); 使用系统 API 需不需要使用 weak正常情况下是不需要的，比如 123456789101112131415[UIView animateWithDuration:duration animations:^&#123; [self.superview layoutIfNeeded]; &#125;];[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.someProperty = xyz;&#125;];[[NSNotificationCenter defaultCenter] addObserverForName:@&quot;someNotification&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *notification) &#123; self.someProperty = xyz; &#125;]; 但是如果系统的 API 对 self 有引用的时候就要考虑，比如 1234567891011121314151617// self-&gt;operationsGroup/operationsQueue-&gt;block-&gt;self__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123; __typeof__(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doSomethingElse];&#125;);// self-&gt;observer-&gt;block-&gt;self__weak __typeof__(self) weakSelf = self;_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot; object:nil queue:nil usingBlock:^(NSNotification *note) &#123; __typeof__(self) strongSelf = weakSelf; [strongSelf dismissModalViewControllerAnimated:YES];&#125;]; 封装常用的宏12#define WS __typeof(&amp;*self) __weak weakSelf = self#define SS __typeof(&amp;*self) __strong strongSelf = weakSelf","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"内存管理","slug":"tech/iOS/内存管理","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/内存管理/autorelease/","text":"autorelease 的伪代码实现1[obj autorelease]; 等同于以下代码 12345// NSObject.m:- (id)autorelease &#123; [NSAutoreleasePool addObject:self];&#125; 123456789101112131415// NSAutoreleasePool. 类方法+ (void)addObject:(id)anObj &#123; NSAutoreleasePool *pool = 获取正在使用中的 pool； if (pool != nil) &#123; [pool addObject:anObj]; &#125;&#125;// NSAutoreleasePool.m 实例方法- (void)addObject:(id)anObj &#123; [array addObject:anObj];&#125; 其中关于获取正在使用中的 pool，以下例子的 obj 在调用 autorelease 时取到的 autoreleasepool 就是 poo2 12345678NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc] init];NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];NSObject *obj = [[NSObject alloc] init];[obj autorelease][poo1 drain];[poo2 drain]; 12345678910111213141516171819// drain 的实现- (void)drain&#123; [self dealloc];&#125;- (void)dealloc&#123; [self emptyPool]; [array release];&#125;- (void)emptyPool&#123; for (id obj in array) &#123; [obj release]; &#125;&#125; autorelease 苹果的实现12345678910111213141516171819202122232425262728293031323334353637383940class AutoreleasePoolPage &#123; static inline void *push() &#123; // 相当于生成或持有 NSAutoreleasePool 类对象 &#125; static inline id autorelease(id obj) &#123; // 相当于 NSAutoreleasePool 类的 addObject 类方法 AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的 AutoreleasePoolPage 实例； autoreleasePoolPage-&gt;add(obj); &#125; id *add(id obj) &#123; // 将对象追加到内部数组中 &#125; static inline void *pop(void *token) &#123; // 相当于废弃 NSAutoreleasePool 类对象 releaseAll(); &#125; void releaseAll() &#123; // 调用内部数组中对象的 release 实例方法 &#125;&#125;;void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt)&#123; AutoreleasePoolPage::pop(ctxt);&#125;id *objc_autorelease(id obj) &#123; return AutoreleasePoolPage::autorelease(obj);&#125; 123456789// 等同于 objc_autoreleasePoolPush()NSAutoreleasePool *pool=[[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];// 等同于 objc_autorelease(obj)[obj autorelease];// 等同于 obic_autoreleasePoolPop(pool)[pool drain]; AutoreleasePool 的底层实现 AutoreleasePool 是由一个个 AutoreleasePoolPage 组成的双向链表 AutoreleasePoolPage 内部维护一个栈；栈满的时候会新建一个 AutoreleasePoolPage 节点 AutoreleasePool Push 时会压入一个边界对象表示一个 AutoreleasePool 的开始，Pop 时会清理堆栈直到遇到一个边界对象；边界对象是界定 AutoreleasePool 的分割线 AutoreleasePool 与 RunLoopApp 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，区别是优先级不同 第一个 Observer 优先级最高，保证创建释放池发生在其他所有回调之前，监视了一个事件： Entry（即将进入 Loop），其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。 第二个 Observer 优先级最低，保证其释放池子发生在其他所有回调之后，监视了两个事件： BeforeWaiting（准备进入休眠）时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池； Exit(即将退出 Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了 参考文章 AutoreleasePool 底层实现原理","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"内存管理","slug":"tech/iOS/内存管理","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/内存管理/dealloc 探究/","text":"结论 dealloc 是在最后一次 release 执行后调用 ARC 下，对象的实例变量的释放时机是：编译器在 NSObject 插入的 .cxx_desctruct 方法释放 ARC 下 [super dealloc] 方法是由编译器自动插入，所以不需要手动调用 dealloc 主要干三件事： 释放对象的实例变量 释放对象的关联对象（即释放该类的分类里设置的关联属性） 将所有指向该对象的 weak 指针置为 nil 源码探讨通过 apple 的 runtime 源码，不难发现 NSObject 执行 dealloc 最后执行到 objc_destructInstance 12345678910111213141516171819void *objc_destructInstance(id obj)&#123; if (obj) &#123; Class isa_gen = _object_getClass(obj); class_t *isa = newcls(isa_gen); // Read all of the flags at once for performance. bool cxx = hasCxxStructors(isa); bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen); // 重点 if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); if (!UseGC) objc_clear_deallocating(obj); &#125; return obj;&#125; 简单明确的干了三件事： object_cxxDestruct：strong 修饰的变量执行 objc_storeStrong(&amp;ivar, nil) release 对象，ivar 赋值 nil；weak 修饰的变量执行 objc_destroyWeak(&amp;ivar) -&gt; storeWeak(&amp;ivar, nil ) -&gt; weak_unregister_no_lock，将变量指向 nil，且删除变量对象的 weak 相关信息（referrers 移除 weak 地址） 执行 _object_remove_assocations 去除和这个对象 assocate 的对象（常用于 category 中添加带变量的属性） 执行 objc_clear_deallocating，清空引用计数表并清除弱引用表，将所有 weak 引用指 nil（这也就是 weak 变量能安全置空的所在） 面试题：引用计数减为 0 会立即释放吗答案：会。dealloc 是在最后一次 release 执行后调用 参考文章 ARC 下 dealloc 过程及.cxx_destruct 的探究","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"内存管理","slug":"tech/iOS/内存管理","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/KVC/","text":"基本概念 KVC 是 Key-Value Coding 的缩写，让开发者可以通过 Key 直接访问或设置对象的属性/成员变量，而不需要调用存取方法 KVC 可以直接获取、修改类不想暴露的私有变量，所以会破坏面向对象的编程思想 UITextView 设置 _placeholderLabel 可用到 基础用法12345- (id)valueForKey:(NSString *)key; // 直接通过 Key 来取值- (void)setValue:(id)value forKey:(NSString *)key; // 通过 Key 来设值- (id)valueForKeyPath:(NSString *)keyPath; // 通过 KeyPath 来取值- (void)setValue:(id)value forKeyPath:(NSString *)keyPath; // 通过 KeyPath 来设值 通过 Key 来访问直接的属性 12// age 是 b 的属性[b setValue:@23 forKey:@&quot;age&quot;]; 通过 KeyPath 来访问属性的属性 12// b 是 a 的一个属性[a setValue:@23 forKeyPath:@&quot;b.age&quot;]; 实现原理KVC setter 的查找过程以 [b setValue:@23 forKey:@&quot;age&quot;]; 举例 查找 B 中的 setAge:、_setAge: 方法；找到则调用，结束 查看 B 的 + (BOOL)accessInstanceVariablesDirectly 返回值，若为 NO 则调用 B 的 setValue:forUndefinedKey: 并抛异常，结束（默认值为 YES） 查找 B 中的 _age、_isAge、age、isAge，找到则直接访问；否则调用 B 的 setValue:forUndefinedKey: 并抛异常 KVC getter 的查找过程以 [b valueForKey:@&quot;age&quot;]; 举例 查找 B 中的 getAge、age、isAge、_getAge、_age、_isAge 方法；找到则调用，结束 查找一些集合类的特有方法，比如 count/sum/average 等，这里不展开 查看 B 的 + (BOOL)accessInstanceVariablesDirectly 返回值，若为 NO 则调用 B 的 valueForUndefinedKey: 并抛异常，结束（默认值为 YES） 查找 B 中的 _age、_isAge、age、isAge，找到则直接访问；否则调用 B 的 valueForUndefinedKey: 并抛异常 accessInstanceVariablesDirectly 方法，顾名思义，是否允许直接访问成员变量，默认 YES","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/KVO/","text":"基本概念 KVO 是 Key-Value Observing 的缩写，用于监听对象的某一属性改变 KVO 是 Objective-C 对观察者模式的实现 基础用法我的博客园 实现原理KVO 是使用 isa 混写技术（isa-swizzing）实现 当一个对象使用了 KVO 监听，iOS 系统会修改这个对象的 isa 指针，使其指向通过 Runtime 动态创建的子类，该子类重写了 set 方法，内部实现会调用 willChangeValueForKey、父类的 setter、didChangeValueForKey。在 didChangeValueForKey 方法中又会调用监听器的监听方法 原理如图所示 重点如下： 动态创建了子类（修改了 isa 指针的指向） RuntimeAPI : objc_allocateClassPair 和 objc_registerClassPair，动态生成 NSKVONotifying_XXX 重写了 setter 方法 调用 willChangeValueForKey 调用 super 的 setter 调用 didChangeValueForKey didChangeValueForKey 中调用 observeValueForKeyPath:ofObject:change:context: 相关面试题1. 什么是 isa 混写 / KVO 的实现原理见上节 2. 如何手动触发 KVO手动调用 willChangeValueForKey 和 didChangeValueForKey，缺一不可 1234Person *p = [[Person alloc] init];[p addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil];[p willChangeValueForKey:@&quot;age&quot;];[p didChangeValueForKey:@&quot;age&quot;]; 3. 直接修改成员变量会触发 KVO 吗比如 _age = 20 这样的调用不会触发 KVO，因为没有调用 setter 方法 4. KVC 会触发 KVO 吗KVC 访问属性既可以通过 setter，也可能通过直接访问成员变量（+ (BOOL)accessInstanceVariablesDirectly 返回 NO 的时候就不会触访问成员变量）；会不会触发 KVO 本质上是取决于会不会触发 setter 函数 细节探究创建的子类的伪代码实现1234567891011121314151617181920212223@implementation NSKVONotifying_Person- (Class)class&#123; return [Person class]; // 而不是 return object_getClassName(self);&#125;- (void)setAge:(NSInteger)age&#123; _NSSetLongLongValueAndNotify();&#125;void _NSSetLongLongValueAndNotify()&#123; [self willChangeValueForKey:@&quot;age&quot;]; [super setAge:age]; [self didChangeValueForKey:@&quot;age&quot;];&#125;- (void)didChangeValueForKey:(NSString *)key&#123; [oberser observeValueForKeyPath:key ofObject:self change:nil context:nil];&#125;@end 动态创建子类以及重写 class 方法的代码验证1234Person *p = [[Person alloc] init];NSLog(@&quot;添加监听之前 %@, %@&quot;, object_getClass(p), [p class]);[p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];NSLog(@&quot;添加监听之后 %@, %@&quot;, object_getClass(p), [p class]); 输出 12添加监听之前 Person, Person添加监听之后 NSKVONotifying_Person, Person 可以看到 p 的 isa 指针已经被改变了，指向了一个 NSKVONotifying_ 开头的类，该类是动态生成的。 尽管如此，p 的 class 函数还是返回了用户的类，实际上是苹果重写了该方法，目的是不想让这个内部细节暴露给开发者；不重写的话，使用 [person class] 就会返回 NSKVONotifying_Person，这是苹果所不希望看到的，注意，class 方法的默认实现如下 1234- (Class)class&#123; return object_getClass(self); // 将会返回 isa 指针的实际指向，即 NSKVONotifying_Person&#125; 重写子类 set 方法的代码验证1234Person *p = [[Person alloc] init];NSLog(@&quot;添加监听之前的方法地址：%p&quot;, [p methodForSelector:@selector(setAge:)]);[p addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil];NSLog(@&quot;添加监听之后的方法地址：%p&quot;, [p methodForSelector:@selector(setAge:)]); 输出如下，可以使用 p 命令将地址强制转为函数 1234567添加监听之前的方法地址：0x10c9f0bc0添加监听之后的方法地址：0x7fff257228bc(lldb) p (IMP)0x10c9f0bc0(IMP) $0 = 0x000000010c9f0bc0 (ForTest`-[Person setAge:] at Person.h:14)(lldb) p (IMP)0x7fff257228bc(IMP) $1 = 0x00007fff257228bc (Foundation`_NSSetLongLongValueAndNotify) 因为 age 是 NSInteger，所以调用了 _NSSetLongLongValueAndNotify，如果是其他数据类型就会调用对应的方法 使用以下命令可以查看 Foundation 中包含 ValueAndNotify 的方法 1nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation | grep ValueAndNotify 输出 1234567891011121314151617181920212223242526272829303132333435363738000000000015ca93 t __NSSetBoolValueAndNotify00000000000553ab t __NSSetCharValueAndNotify00000000000c6bfb t __NSSetDoubleValueAndNotify0000000000101f6a t __NSSetFloatValueAndNotify00000000001321e9 t __NSSetIntValueAndNotify0000000000052c7b t __NSSetLongLongValueAndNotify00000000001c02c7 t __NSSetLongValueAndNotify0000000000070df9 t __NSSetObjectValueAndNotify00000000000cc7f1 t __NSSetPointValueAndNotify00000000001c07be t __NSSetRangeValueAndNotify0000000000092242 t __NSSetRectValueAndNotify00000000001c053f t __NSSetShortValueAndNotify00000000000cc624 t __NSSetSizeValueAndNotify00000000001c0183 t __NSSetUnsignedCharValueAndNotify00000000000d4d60 t __NSSetUnsignedIntValueAndNotify000000000008cd85 t __NSSetUnsignedLongLongValueAndNotify00000000001c0401 t __NSSetUnsignedLongValueAndNotify00000000001c0678 t __NSSetUnsignedShortValueAndNotify00000000001bf600 t __NSSetValueAndNotifyForKeyInIvar00000000001bf662 t __NSSetValueAndNotifyForUndefinedKey00000000001c091e t ____NSSetBoolValueAndNotify_block_invoke00000000000554eb t ____NSSetCharValueAndNotify_block_invoke00000000000c6d45 t ____NSSetDoubleValueAndNotify_block_invoke00000000001020b3 t ____NSSetFloatValueAndNotify_block_invoke0000000000136a41 t ____NSSetIntValueAndNotify_block_invoke0000000000052e23 t ____NSSetLongLongValueAndNotify_block_invoke00000000001c0989 t ____NSSetLongValueAndNotify_block_invoke0000000000091811 t ____NSSetObjectValueAndNotify_block_invoke0000000000125637 t ____NSSetPointValueAndNotify_block_invoke00000000001c0a4a t ____NSSetRangeValueAndNotify_block_invoke00000000000923db t ____NSSetRectValueAndNotify_block_invoke00000000001c09ed t ____NSSetShortValueAndNotify_block_invoke0000000000122c1a t ____NSSetSizeValueAndNotify_block_invoke00000000001c0958 t ____NSSetUnsignedCharValueAndNotify_block_invoke00000000000d4e9d t ____NSSetUnsignedIntValueAndNotify_block_invoke00000000000ab280 t ____NSSetUnsignedLongLongValueAndNotify_block_invoke00000000001c09b6 t ____NSSetUnsignedLongValueAndNotify_block_invoke00000000001c0a1a t ____NSSetUnsignedShortValueAndNotify_block_invoke 参考资料面试驱动技术 - KVO &amp;&amp; KVC","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/NSString 的坑/","text":"__NSCFConstantString12345678NSString *str1 = @&quot;ab&quot;;NSLog(@&quot;%p isa: %@&quot;, str1, [str1 class]);NSString *str2 = str1;NSLog(@&quot;%p isa: %@&quot;, str2, [str2 class]);NSString *str3 = [[NSString alloc] initWithString:@&quot;ab&quot;];NSLog(@&quot;%p isa: %@&quot;, str3, [str3 class]);NSString *str4 = [NSString stringWithFormat:@&quot;ab&quot;];NSLog(@&quot;%p isa: %@&quot;, str4, [str4 class]); 输出结果 12340x1097013f8 isa: __NSCFConstantString0x1097013f8 isa: __NSCFConstantString0x1097013f8 isa: __NSCFConstantString0xaeadd56e72cd6d4d isa: NSTaggedPointerString 其中 str1/str2/str3 的指向的内容地址相同，类都是 __NSCFConstantString 这是字符串常量，编译时分配内存，存储在常量区，引用计数是不会变的 而 str4 是一个 __NSTaggedPointerString __NSTaggedPointerString这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。 64 位环境下指针变量长达 8 位，苹果把指针指向的内容直接放在了指针变量的内存地址中 这种指针不通过解引用 isa 来获取其所属类（通过其地址的部分保留字段），因此可以当作一种伪对象 这是一个单例常量，不会被释放。 对于 NSString 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 NSTaggedPointerString 类型 如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 __NSCFString 类型 123456NSString *str5 = [NSString stringWithFormat:@&quot;abcdedfgh&quot;]; // 长度&lt;=9NSLog(@&quot;%p isa: %@&quot;, str5, [str5 class]);NSString *str6 = [NSString stringWithFormat:@&quot;abcdedfghi&quot;]; // 长度&gt;9NSLog(@&quot;%p isa: %@&quot;, str6, [str6 class]);NSString *str7 = [NSString stringWithFormat:@&quot;你&quot;]; // 非 ASCIINSLog(@&quot;%p isa: %@&quot;, str7, [str7 class]); 输出结果 1230x8166d7f2baa92699 isa: NSTaggedPointerString0x600002be0240 isa: __NSCFString0x600002e128c0 isa: __NSCFString NSString 与引用计数 __NSCFConstantString 的引用计数无限大 __NSTaggedPointerString 的引用计数无限大 __NSCFString 的引用计数正常，对一个 __NSCFString 进行 copy 操作会使得该对象的引用计数 +1 可以通过 po @(CFGetRetainCount((__bridge CFTypeRef)(s))) 查看其引用计数 一道面试题123456789@property (nonatomic, copy) NSString *str;int n = 100000;while (n--)&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; self.str = [NSString stringWithFormat:@&quot;abcdedfghi&quot;]; &#125;);&#125; 可能挂在这里 1234567#0 0x00007fff51a9033a in __pthread_kill ()#1 0x00007fff51b3ae60 in pthread_kill ()#2 0x00007fff51a1fb7c in abort ()#3 0x00007fff51b1ba63 in malloc_vreport ()#4 0x00007fff51b1bde6 in malloc_zone_error ()#5 0x00007fff23d9f945 in _CFRelease ()#6 0x000000010dcd4e0f in -[ViewController setStr:] 原因是多个线程调用 string 的 setter 时，当 _str 引用计数为 1 时，release 被调用了，过度释放造成 crash 12345678- (void)setStr:(NSString *)str&#123; if (_str != str) &#123; [_str release]; // arc 自动加上 _str = [str copy]; &#125;&#125; 改为 self.str = [NSString stringWithFormat:@&quot;abcdedfgh&quot;]; 就不会挂了，因为 __NSTaggedPointerString 的引用计数无限大，多次 release 也没事 同理，改为 self.str = @&quot;abcdedfgh&quot; 也不会挂，因为 __NSCFConstantString 的引用计数无限大 改为 atomic 也可以防止 crash 另外在 autoreleasepool pop 的时候也会调用 release，也可能会挂，堆栈如下 12345678#0 0x00007fff50aed94b in objc_release ()#1 0x00007fff50aef077 in AutoreleasePoolPage::releaseUntil(objc_object**) ()#2 0x00007fff50aeef96 in objc_autoreleasePoolPop ()#3 0x0000000101ed1e77 in _dispatch_last_resort_autorelease_pool_pop ()#4 0x0000000101ee3825 in _dispatch_root_queue_drain ()#5 0x0000000101ee3ca6 in _dispatch_worker_thread2 ()#6 0x00007fff51b379f7 in _pthread_wqthread ()#7 0x00007fff51b36b77 in start_wqthread ()","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/Native 与 JS 交互/","text":"UIWebView/WKWebView 拦截请求 Native 调用 JS 1[webView stringByEvaluatingJavaScriptFromString:@&quot;Math.random();&quot;]; JS 调用 NativeNative 拦截 UIWebView 的所有请求，判断 Scheme，如果是约定好的 Schema 就拦截请求、解析参数并调用 Native 相应的逻辑 JS 发起请求有两种方式：1. 通过 localtion.href；2. 通过 iframe 方式 前者如果短时间内连续多次修改 localtion.href 的值，Native 只会收到最后一次请求，因此 JS 侧采用 iframe 的方式发起请求 12345678910var url = &#x27;jsbridge://doAction?title=标题&#x27;;var iframe = document.createElement(&#x27;iframe&#x27;);iframe.style.width = &#x27;1px&#x27;;iframe.style.height = &#x27;1px&#x27;;iframe.style.display = &#x27;none&#x27;;iframe.src = url;document.body.appendChild(iframe);setTimeout(function() &#123; iframe.remove();&#125;, 100); 1234567891011- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; if (request.URL 是自定义的 Schema) &#123; 解析 URL 的参数 处理函数 return NO; // 不发起请求 &#125; return YES; // 正常发起请求&#125; 优点：不需要等到整个 HTML 页面加载完成就能调用 Native？ 缺点：需要繁琐地解释字符串得到相应的方法名和传值，且调用的方法也不能传递返回值； UIWebView 获取 JSContext在 webViewDidFinishLoad 通过 KVC 的方法获取 JSContext 123456789- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; self.jsContext[@&quot;NativeBridge&quot;] = self; self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; context.exception = exceptionValue; NSLog(@&quot;异常信息：%@&quot;, exceptionValue); &#125;;&#125; JSContext 属于 JSCore，见下节 优点：需要等到整个 HTML 页面加载完成才能调用 JS？ 缺点：WKWebView 无法使用 JSCore WKWebView 使用 userContentControllerWKWebView 无法使用 JSCore Native 调用 JS 1@property (nonatomic, strong) WKUserContentController *userContentController; Native 和 H5 交互基本全靠这个对象， 在 WKWebVeiw 中，我们使用我们有两种方式来调用 JS， 使用 WKUserScript 直接调用 JS 字符串 1.1 使用 WKUserScript 1234// source 就是我们要调用的 JS 函数或者我们要执行的 JS 代码// injectionTime 这个参数我们需要指定一个时间，在什么时候把我们在这段 JS 注入到 WebVeiw 中，它是一个枚举值，WKUserScriptInjectionTimeAtDocumentStart 或者 WKUserScriptInjectionTimeAtDocumentEnd// MainFrameOnly 因为在 JS 中，一个页面可能有多个 frame，这个参数指定我们的 JS 代码是否只在 mainFrame 中生效- initWithSource:injectionTime:forMainFrameOnly: 至此，我们已经构建了一个 WKUserScript，然后呢，我们要做的就是要把它添加进来 1- addUserScript: 至此使用 WKUserScript 调用 JS 完成 1.2 直接调用 JS 字符串 在 WKWebView 中，我们也可以直接执行 JS 字符串 1- (void)evaluateJavaScript:completionHandler: 我们通过调用这个方法来执行 JS 字符串，然后在 completionHandler 中拿到执行这段 JS 代码后的返回值。 至此，Native 调用 JS 完成 JS 调用 Native 2.1 向 JS 注入一个字符串 1[_webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeMethod&quot;]; 我们向 JS 注入了一个方法，叫做 nativeMethod 2.2 JS 调用 Native 1window.webkit.messageHandlers.nativeMethod.postMessage(value); 一句话调用，我们就可以在 Native 中接收到 value 2.3 接收 JS 调用 上边我们调用 addScriptMessageHandler:name 的时候，我们要遵守 WKScriptMessageHandler 协议，然后实现这个协议。 123456- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; NSString * name = message.name // 就是上边注入到 JS 的哪个名字，在这里是 nativeMethod id param = message.body // 就是 JS 调用 Native 时，传过来的 value // TODO: do your stuff&#125; 完了，Native 调用 JS 就这么简单 优点：简单易用缺点：JS 调用 Native 后回调较难，见 https://juejin.im/entry/59f6e836f265da431a427a57 JSCore Native 调用 JS 12345JSContext *context = [[JSContext alloc] init];NSString *js = @&quot;function add(a,b) &#123;return a+b&#125;&quot;;[context evaluateScript:js]; // 注入 JS 函数[context[@&quot;add&quot;] callWithArguments:@[@&quot;2&quot;, @&quot;3&quot;]];//[mJsValue invokeMethod:@&quot;printHello&quot; withArguments:@[@&quot;1&quot;]]; JS 调用 Native 借助 JSCore，我们并不一定要写 JS，可以直接使用 JSCore 模拟 JS 调用 1234JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;var a = 1;var b = 2;&quot;];JSValue *ret = [context evaluateScript:@&quot;a + b&quot;];NSInteger sum = [ret toInt32]; // sum=3 Native 注入函数到 JS 12JSContext *context = [[JSContext alloc] init];context[@&quot;NativeBridge&quot;] = [QLJSInterface new]; Native 实现 JSExport 123456789101112@protocol QLJSProtocol &lt;JSExport&gt;JSExportAs(open, - (void)open:(NSString *)url);@end@interface QLJSInterface : NSObject&lt;QLJSProtocol&gt;@end@implementation QLKTH5Interface- (void)open:(NSString *)url&#123; NSLog(@&quot;URL is %@&quot;: url);&#125;@end JS 调用 Native，可以使用 JSCore 模拟，也可以在 JS 侧调用（需要把 JS 文件注入到 JSContext） 123JSContext *context = [[JSContext alloc] init];context[@&quot;NativeBridge&quot;] = [QLJSInterface new];[context evaluateScript:@&quot;NativeBridge.open(&#x27;HomePage&#x27;)&quot;]; or 1234function f()&#123; NativeBridge.open(&#x27;HomePage&#x27;);&#125; 优点：不依赖 WebView","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/Property/","text":"@property 的本质1@property = ivar(实例变量) + getter/setter（存取方法）; ARC 下，property 中有哪些属性关键字？ 原子性 (atomic, nonatomic) 读写权限 (readonly, readwrite) 内存管理 (strong, weak, unsafe_unretained, retain, assign, copy) 存取方法 (getter, setter) atomic 与 nonatomic 区别 atomic 性能不佳，可保证 setter/getter 的多线程安全；但是保证不了对集合类的访问的线程安全 atomic 保证 setter/getter 安全，也保证不了数据的准确性（线程 A 写，线程 B 写，线程 A 读，读的是线程 B 写入的值） 什么是线程安全？ weak 和 assign 的区别 都是弱引用，不能使引用计数+1 对象销毁后， weak 修饰的指针会自动变成 nil，而 assign 会成为野指针 weak 只能修饰 OC 对象；assign 可以修饰基本数据类型和 OC 对象 weak 修饰的成员变量是用 __weak 修饰的；assign 生成的成员变量是用 __unsafe_unretained 默认属性是哪些 基本数据类型默认关键字是 atomic、readwrite、assign 普通的 Objective-C 对象默认关键字是 atomic、readwrite、strong 常见的修饰 NSString/NSArray: copy（why） NSMutableString/NSMutableArray: strong（why） block: copy/strong（如果是 MRC 只能用 copy） 声明 Block 时，使用 strong 和 retain 会有截然不同的效果。strong 会等于 copy，而 retain 竟然等于 assign 关于 copy 与 mutableCopy 非集合类 1234567NSString *s = @&quot;123&quot;;NSString *s1 = [s copy]; // 浅复制：s1 与 s 是同个对象NSString *s2 = [s mutableCopy]; // 深复制：s2 是新对象NSMutableString *m = [@&quot;123&quot; mutableCopy]; NSMutableString *m1 = [m copy]; // 深复制：m1 是新对象NSMutableString *m2 = [m mutableCopy]; // 深复制：m2 是新对象 结果，s1 是浅复制，没有生成新的对象；其他情况都是深复制，产生了新对象 集合类 1234567NSArray *a = @[@&quot;123&quot;];NSString *a1 = [a copy]; // 浅复制：a1 与 a 是同个对象NSString *a2 = [a mutableCopy]; // 单层深复制：a2 是新对象，但集合里的元素仍然是一样NSMutableString *b = [@[@&quot;123&quot;] mutableCopy]; NSMutableString *b1 = [b copy]; // 单层深复制：b1 是新对象，但集合里的元素仍然是一样NSMutableString *b2 = [mb mutableCopy]; // 单层深复制：b2 是新对象，但集合里的元素仍然是一样 结果，a1 是浅复制，没有生成新的对象；其他情况都是 单层深复制，产生了新对象；所谓单层深复制，指的是虽然该指针指向的对象是新产生的，但是集合内部的元素仍然是一样的 更多可以参考：iOS 集合的深复制与浅复制 MRC 与 ARC 下的 setter 实现123456789101112131415161718192021222324252627282930313233343536373839404142// ARC &amp; MRC 的 assign- (void)setName:(NSString *)name&#123; _name = name;&#125;// MRC：retain 的第一种写法- (void)setName:(NSString *)name&#123; if (_name != name) &#123; [_name release]; _name = [name retain]; &#125;&#125;// MRC：retain 的第二种写法- (void)setName:(NSString *)name&#123; [name retain]; // 先 retain，防止参数是自身 [_name release]; _name = name;&#125;// MRC：copy- (void)setName:(NSString *)name&#123; if (_name != name) &#123; [_name release]; _name = [name copy]; &#125;&#125;// ARC：copy- (void)setName:(NSString *)name&#123; if (_name != name) &#123; _name = [name copy]; &#125;&#125; @synthesize跟 @property 功能类似，告诉编译器自动添加 setter/getter，以及添加成员变量。现在开发中很少用到。 用途： 为实例变量重命名 @syntheszie var = _var2; 使用场景：协议中声明的属性，实现类里面编译器会提示使用 @synthesize 来消除警告 见 如何为协议添加属性 @dynamic@dynamic 告诉编译器：属性的实例变量、setter 与 getter 方法由用户自己实现，不自动生成；当然对于 readonly 的属性只需提供 getter 即可 如果一个属性被声明为 @dynamic，但是没你有提供 setter/getter，编译不会有问题，运行时会奔溃 而实例变量也需要自己声明 12345678910111213141516171819@interface Person ()&#123; NSInteger _age; // 这个不写会编译报错&#125;@property (nonatomic, assign) NSInteger age;@end@implementation Person@dynamic age;- (void)setAge:(NSInteger)age&#123; _age = age;&#125;- (NSInteger)age&#123; return _age;&#125;@end 什么情况不会自动合成 使用了 @dynamic 时（不再合成 setter/getter/实例变量，这 3 个需要全部自己实现） 在 @protocol 中定义的所有属性（不再合成实例变量，使用 @synthesize） 在 category 中定义的所有属性（不再合成实例变量和 getter/setter，使用关联对象） 重载的属性，当你在子类中重载了父类中的属性（不再合成实例变量，使用 @synthesize 来手动合成ivar）","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/UIView 与 CALayer 区别/","text":"联系 每一个 UIView 都有一个根 layer 两者都有树状层级结构，CALayer 有 subLayers, UIView 有 subViews 区别 触摸：最大的区别 CALayer 不能处理用户的触摸事件，而 UIView 可以 UIView 继承自 UIResponder，可以处理用户的触摸事件 CALayer 直接继承 NSObject，并没有相应的处理触摸事件的接口 坐标系统：CALayer 的属性更丰富 CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性 CALayer 具有以下属性：anchorPoint, position, bounds 和 transform 等 UIView 具有以下属性：bounds, frame 等 UIView 是由 CoreAnimation 来实现的。它真正的绘图部分，是由一个 CALayer 类来管理 UIView 本身更像是一个 CALayer 的管理器，访问它的 frame，bounds 等，实际上内部都是在访问它所包含的 CALayer 的相关属性 责任：UIView 侧重于对显示内容的管理，CALayer 侧重于对内容的绘制 UIView 和 CALayer 是相互依赖的关系，UIView 依赖 CALayer 绘制的内容，CALayer 依赖 UIView 提供的容器来显示绘制的内容 所以 CALayer 是基础，没有 CALayer，UIView 自身不会存在，然而，UIView 是 CALayer 的特殊实现，可响应触摸事件 动画：我们对 UIView 的属性修改时不会产生默认动画，而对单独 layer 属性直接修改会 更多详细 UIView 与 CALayer","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/block 和 delegate 的区别/","text":"特性对比 block delegate 安全性 容易产生循环引用 可读性 代码集中更连贯，代码更少 性能 性能开销比 delegate 多，因为 block 会涉及到栈区向堆区拷⻉等操作，时间和空间上的消耗都⼤于 delegate 如何选择 回调方法较少时使用 block，比如网络请求；有多个回调方法使用 delegate，比如 tableview 临时性的回调使用 block，比如数组的枚举；只调用一次的回调且需要存储的，使用 delegate/block 均可，比如网络；可能调用多次的回调，需要存储，使用 delegate 更好，比如按钮的点击","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/iOS 图片加载的坑/","text":"iOS 中有两种常用的图片加载方式： imageNamed 有缓存：这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回 适合使用频率高的小图片 系统会自动添加 @2x/@3x 去寻找图片 imageWithContentsOfFile 只是简单的加载图片，并不会将图片缓存起来 适合使用频率少的大图片 关于 @2x/@3x 的坑假如现在有 `image@2x.png和image@3x.png` 2张图片 以下代码可以正确找到图片，这种方法是直接寻找 image@2x.png 12NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;image@2x&quot; ofType:@&quot;png&quot;]; UIImage *image = [UIImage imageWithContentsOfFile:path]; 以下代码无法找到图片，这种方法是直接寻找 image.png 12NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;image&quot; ofType:@&quot;png&quot;]; //输出 nilUIImage *image = [UIImage imageWithContentsOfFile:path]; 以下代码可以正确找到图片，这种方法系统会帮助处理 @2x/@3x 12NSString *path = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@&quot;image.png&quot;];UIImage *image = [UIImage imageWithContentsOfFile:path]; 假如是一个 3x 设备，3x 图片实际宽度为 300x300，2x 图片实际宽度为 200x200，1x 图片实际宽度为 100x100 12NSString *path = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@&quot;image.png&quot;];UIImage *image = [UIImage imageWithContentsOfFile:path]; 在这个 3x 设备上，读到的 image 为 1&lt;UIImage: 0x283a09e30&gt; size &#123;100, 100&#125; orientation 0 scale 3.000000 如果 3x 图片缺失，会自动寻找 2x 图片，读到的 image 为 1&lt;UIImage: 0x283a09e30&gt; size &#123;100, 100&#125; orientation 0 scale 2.000000 如果 3x 和 2x 图片缺失，会自动寻找 1x 图片，读到的 image 为 1&lt;UIImage: 0x283a09e30&gt; size &#123;100, 100&#125; orientation 0 scale 1.000000 image.png 和 image@1x.png 是等价的 Framework 的图片加载提供 Framework 提供给业务方时，需要提供 .bundle 和 .framework 主 App 将 .bundle 放入自己的 bundle 中 Framework 使用以下代码访问图片资源 12NSBundle *bundle = [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:@&quot;VideoNativeFramework&quot; ofType:@&quot;bundle&quot;]];UIImage *img = [UIImage imageWithContentsOfFile:[[bundle resourcePath] stringByAppendingPathComponent:@&quot;image.png&quot;]];","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.955Z","path":"tech/iOS/未分类/iOS 沙盒目录结构/","text":"MyApp.app 说明 存放资源文件和可执行文件。整个目录只可读，不可更改。为了防止篡改里面的内容，应用在安装的时候会将该目录进行签名。在非越狱的情况下，该目录中的内容是无法更改的。在越狱设备上如果更改了目录内容，对应的签名就会被改变，这种情况下应用程序将无法启动。 iTunes同步 该文件不会被 iTunes 同步 路径获取 12[[NSBundle mainBundle] bundlePath]// Output is: /var/containers/Bundle/Application/556BDC9D-1881-48DC-BA34-9A5032621795/MyApp.app&quot; 注意这个 MyApp.app 不是在沙盒的主目录下 沙盒主目录路径 沙盒主目录的文件结构图如下 . ├── Documents ├── Library │ ├── Caches │ └── Preferences ├── SystemData └── tmp 路径获取 12NSHomeDirectory()// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85 Documents 说明 开发者可以将应用程序的数据文件保存在这个目录下 iTunes 同步 该目录下的文件会被 iTunes 同步。 路径获取 12[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Documents Library 说明 存放一些偏好设置 iTunes 同步 除这个 Library/Caches 之外，Library 下的其他文件会被 iTunes 同步 路径获取 12[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Library Library/Caches 说明 存放缓存数据 iTunes 同步 该目录下的数据不会被 iTunes 同步 路径获取 12[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Library/Caches Library/Preferences 说明 存放偏好设置文件。比如 NSUserDefaults 就是将数据保存在该目录下的一个plist文件中 iTunes 同步 该目录下的数据会被 iTunes 同步 路径获取 12[NSUserDefaults standardUserDefaults]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Library/Preferences Temp 说明 临时文件，保存应用再次启动时就可以不需要的文件数据。并且开发者不需要这些文件的时候应该要主动将其删除掉，因为该目录下的文件随时可能被系统清理掉，比如当系统磁盘存储空间不足的时候，系统会自动清除这个目录下的文件。 iTunes 同步 该目录不会被 iTunes 同步 路径获取 12NSTemporaryDirectory()// Output is : /private/var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/tmp/","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"未分类","slug":"tech/iOS/未分类","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/Block/Block_面试题/","text":"block 用什么修饰符修饰对于这个问题，得区分 MRC 环境 和 ARC 环境；首先，通过上面小节可知，block 引用了普通外部变量，都是创建在栈区的；对于分配在栈区的对象，我们很容易会在释放之后继续调用，导致程序奔溃，所以我们使用的时候需要将栈区的对象移到堆区，来延长该对象的生命周期。 对于 MRC 环境，使用 copy 修饰 block，会将栈区的 block 拷贝到堆区 对于 ARC 环境，使用 strong、copy 修饰 block，都会将栈区的 block 拷贝到堆区 以下代码输出12345678910- (void)blockDemo3&#123; NSMutableString *strM= [NSMutableString stringWithString:@&quot;hello&quot;]; void (^block)() = ^ &#123; [strM appendString:@&quot;123&quot;]; &#125;; block();&#125; 输出 hello123，详细请看截获对象小节 随着 ARC 的完善，考察 Block 的类型判断跟考察 MRC 一样，越来越没有意义了，以下面试题可能过期 下面代码在 MRC 环境 和 ARC 环境运行的情况1234567void exampleA() &#123; char a = &#x27;A&#x27;; ^&#123; printf(&quot;%cn&quot;, a); &#125;();&#125;//调用：exampleA(); 首先这个 Block 引用了普通外部变量，所以这个 Block 是在栈上面创建的；Block 是在 exampleA() 函数内创建的，然后创建完马上调用，这个时候 exampleA() 并没有执行完，所以这个栈 Block 是存在的，不会被 pop 出栈。故在 MRC 和 ARC 上面都可以正确执行 下面代码在 MRC 环境 和 ARC 环境运行的情况123456789101112131415void exampleB_addBlockToArray(NSMutableArray *array) &#123; char b = &#x27;B&#x27;; [array addObject:^&#123; printf(&quot;%cn&quot;, b); &#125;];&#125; void exampleB() &#123; NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();&#125; //调用：exampleB() ARC 正常，MRC 崩溃。修复方法就是加 copy，如果不懂点这里 下面代码在 MRC 环境 和 ARC 环境运行的情况1234567891011121314void exampleC_addBlockToArray(NSMutableArray *array) &#123; array addObject:^&#123; printf(&quot;Cn&quot;); &#125;];&#125; void exampleC() &#123; NSMutableArray *array = [NSMutableArray array]; exampleC_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();&#125; //调用：exampleC(); 全局 Block，没有任何问题 下面代码在 MRC 环境 和 ARC 环境运行的情况1234567891011typedef void (^dBlock)();dBlock exampleD_getBlock() &#123; char d = &#x27;D&#x27;; return ^&#123; printf(&quot;%cn&quot;, d); &#125;;&#125;void exampleD() &#123; exampleD_getBlock()();&#125;//调用：exampleD(); MRC 编译器可检查出来，会编译失败；ARC 没问题 下面代码在 MRC 环境 和 ARC 环境运行的情况12345678910111213typedef void (^eBlock)();eBlock exampleE_getBlock() &#123; char e = &#x27;E&#x27;; void (^block)() = ^&#123; printf(&quot;%cn&quot;, e); &#125;; return block;&#125;void exampleE() &#123; eBlock block = exampleE_getBlock(); block()&#125;//调用：exampleE(); MRC 编译通过，调用异常；ARC 没问题 ARC 环境下输入结果123456789101112131415 __block NSString *key = @&quot;AAA&quot;;objc_setAssociatedObject(self, &amp;key, @1, OBJC_ASSOCIATION_ASSIGN);id a = objc_getAssociatedObject(self, &amp;key);void (^block)(void) = ^ &#123; objc_setAssociatedObject(self, &amp;key, @2, OBJC_ASSOCIATION_ASSIGN);&#125;;id m = objc_getAssociatedObject(self, &amp;key);block();id n = objc_getAssociatedObject(self, &amp;key);objc_setAssociatedObject(self, &amp;key, @3, OBJC_ASSOCIATION_ASSIGN);id p = objc_getAssociatedObject(self, &amp;key);NSLog(@&quot;%@ --- %@ --- %@ --- %@&quot;,a,m,n,p); 答：输入结果：1 — (null) — 2 — 3，代码执行过程如下： __block 修饰的 key，创建在栈区，访问变量 key 为：&amp;(结构体-&gt;forwarding-&gt;key) ，key 在栈区，此时利用栈区地址作为 Key 来存值 变量 a 使用栈区地址取值，故 a 的值为 1 声明一个 block，引用到了外部变量 key，此时将 block 从栈拷贝堆，访问变量 key 为：&amp;(结构体-&gt;forwarding-&gt;key) ，key 在堆区 变量 m 用堆区地址来取值，故为 null 执行 block，用堆区地址将 2 存进去 变量 n 用堆区地址来取值，故为 2 再用堆区地址将 3 存进去 变量 p 用堆区地址来取值，故为 3 使用block和使用delegate完成委托模式有什么优点委托模式在设计模式中是适配器模式中的对象适配器，Objective-C 中使用 id 类型指向一切对象，使委托模式在 iOS 中的实现更为方便 使用block实现委托模式，其优点是回调的 block 代码块定义在委托对象函数内部，使代码更为紧凑 适配对象不再需要实现具体某个 protocol，代码更为简洁 以下代码有问题吗12345int a = 7;void (^myBlock)(void) = ^() &#123; a = 8;&#125;;printf(&quot;%d&quot;, myBlock()); 有问题，会出现 2 处编译错误，第一处是 a 不能被赋值，除非添加 __block；第二处是 myBlock 没有返回值，无法被打印 以下代码有问题吗12345id ret;dispatch_sync(self.concurrentQueue, ^&#123; ret = @&quot;1&quot;;&#125;);NSLog(@&quot;%@&quot;, ret) 会有编译错误，必须添加 __block，这样对象才可以在 block 中被重新赋值","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Block","slug":"tech/iOS/Block","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Block/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/GCD/GCD/","text":"GCD 脑图 GCD 队列和任务队列（Dispatch Queue） 串行队列：只开启一个线程，一个任务执行完毕后，再执行下一个任务 并发队列：可以开启多个线程，并且同时执行任务 任务执行任务的两种方式： 同步执行 会卡当前线程 不具备开启新线程的能力 异步执行 异步添加任务到指定的队列中，不卡当前线程 具备开启新线程的能力（有能力不代表一定会开启新线程） 队列的创建/获取dispatch_queue_create1234// 串行队列的创建方法dispatch_queue_t queue = dispatch_queue_create(&quot;com.norcy.serial&quot;, DISPATCH_QUEUE_SERIAL);// 并发队列的创建方法dispatch_queue_t queue = dispatch_queue_create(&quot;com.norcy.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); 第一个参数是线程名称，推荐使用逆序全程域名，用于调试 第二个参数用于区别串行或并发，串行时填 DISPATCH_QUEUE_SERIAL 或者 NULL 都可以，并发填 DISPATCH_QUEUE_CONCURRENT 串行队列 可以使用 dispatch_queue_create 创建多个串行队列，它们之间将互不影响，可以并行执行。每创建一个串行队列，系统就会生成一个线程，如果线程数过多，就会引发大量的上下文切换降低性能 串行队列的使用场景：多个线程更新相同资源导致数据竞争时使用 并发队列 不管生成多少并发队列，系统内核只会使用有效管理的线程，不会出现串行队列的线程过多的问题 内存管理 即使在 ARC 下，每次使用 dispatch_queue_create 都得配套使用 dispatch_release 来释放 12345dispatch_queue_t myConcurrentDispatchQueue = dispatch_queue_create(&quot;com.example.gcd.MyConcurrentDispatchQueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123;NSLog(@&quot;block on myConcurrentDispatchQueue&quot;);&#125;); dispatch_release(myConcurrentDispatchQueue); 以上代码不会出现问题，因为 Block 拷贝的时候会对 Dispatch Queue 执行 dispatch_retain 操作，在 Block 结束时会执行 dispatch_release 操作 优先级 无论是创建串行还是并发队列，其优先级都是 DISPATCH_QUEUE_PRIORITY_DEFAULT 主队列对于串行队列，GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue） 所有放在主队列中的任务，都会放到主线程中执行 通过 dispatch_get_main_queue() 获取 全局并发队列对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue） 可以使用 dispatch_get_global_queue 来获取。需要传入两个参数：第一个参数表示队列优先级。第二个参数暂时没用，传 0 即可 优先级有 4 种：High &gt; Default &gt; Low &gt; Background 12// 全局并发队列的获取方法dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 队列和任务的组合使用 同步执行一定不能开新线程 异步执行具备开启新线程的能力 串行队列最多只能开启一个线程 并行队列可开启多个线程 串行队列+同步执行会卡住当前线程，任务在当前线程顺序执行 12345cur start cur 1cur 2cur 3cur end 串行队列+异步执行不会卡住当前线程，开1个新线程，任务在新线程顺序执行 12345cur start cur endnew 1new 2new 3 并发队列+同步执行会卡住当前线程，任务在当前线程顺序执行 12345cur start cur 1cur 2cur 3cur end 并发队列+异步执行不会卡住当前线程，开3个新线程，任务在新线程并发执行 12345cur startcur endnew2 2new1 1new3 3 主队列+同步执行 如果当前是在主线程，则会死锁。主线程等待任务完成，而任务等待主线程 如果当前是在子线程，则会卡住当前线程，任务在主线程顺序执行 串行队列+同步执行，如果当前所在队列和目标队列是同一个，那么就会死锁 主队列+异步执行不会卡住当前线程，任务在主线程顺序执行 常用 APIdispatch_set_target_queue见 dispatch_set_target_queue dispatch_after注意 dispatch_after 并不是再指定时间后执行处理，而只是在指定时间追加任务到 Dispatch Queue 因为主队列在主线程的 RunLoop 中执行，比如该 RunLoop 每 1/60 秒执行一次，则 Block 最快在 3 秒后执行，最慢在 3+1/60 秒后执行，并且如果队列中有其他任务影响，则这个时间会功更长 dispatch_group dispatch_group_notify 使用 dispatch_group_async 添加任务，一旦检测到所有任务执行完毕，dispatch_group_notify 中的任务就被会追加到指定队列中并处理 经典场景：下载多张图片，等它们都下载后，再合成一张图片 12345678dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 合并图片&#125;); dispatch_group_wait 使用 dispatch_group_wait 可以阻塞当前线程，等待 Group 中的任务执行完成之后，才会解除阻塞 等待无限长时间，直到 Group 中的所有任务完成 1234567dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); // 合并图片 等待 5 秒，如果 5 秒后没完成或者 5 秒内完成，都会解除阻塞，继续执行；返回的 long 值为 0 则全部任务执行完毕，反之没完成 1234567891011121314dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); long result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC)); if (result == 0)&#123; // 成功，合并图片 &#125;else&#123; // 全部任务未执行完毕&#125; dispatch_barrier_asyncdispatch_barrier_async 会在两个操作组间形成栅栏，在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作 为了防止读写冲突，采取同步读取，异步写入，此时就可以使用该方法 1234567dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.forBarrier&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, reading1);dispatch_async(queue, reading2);dispatch_barrier_async(queue, writing1);dispatch_barrier_async(queue, writing2);dispatch_async(queue, reading3);dispatch_async(queue, reading4); 执行结果可能为：reading2 -&gt; reading1 -&gt; writing1 -&gt; writing2 -&gt; reading3 -&gt; reading4 writing 之前添加的 reading 任务顺序是不确定的；writing 一定会等到之前添加的所有 reading 任务结束之后才执行；writing 之后添加的任务一定会在 writing 结束之后再执行，如下图 dispatch_barrier_sync 与 dispatch_barrier_async 的区别在于，会等待其队列中的任务执行完毕再返回 writing1 一定先于 writing2，如果是两个写任务并发了，dispatch_barrier_async 也会保证同时只有一个生效，顺序是根据进入栅栏时的顺序决定的，并非由并发队列决定 注意 dispatch_barrier_async` 必须配合自定义的并发队列使用，才能达到写互斥的效果，如下例 123456789101112131415161718192021// dispatch_barrier_async 必须配合自定义的并发队列使用，才能达到写互斥的效果，以下输出是按顺序的dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.example.forBarrier&quot;, DISPATCH_QUEUE_CONCURRENT);// 如果搭配全局并发队列，会退化为 dispatch_async，导致任务的执行顺序是不确定的，以下输出是不按顺序的dispatch_queue_t queue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);int i = 9999;while (i--) &#123; dispatch_barrier_async(queue1, ^&#123; NSLog(@&quot;%@&quot;, @(i)); &#125;);&#125;```## `dispatch_apply`用于重复执行任务，类似 for 循环，参数 Block 是带有 index 参数信息的，注意是同步执行的```objcdispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);NSLog(@&quot;begin&quot;);dispatch_apply(3, queue, ^(size_t index) &#123; NSLog(@&quot;%@&quot;,index, [NSThread currentThread]);&#125;);NSLog(@&quot;end&quot;); 输出结果为 12345begin213end 可以看到，index 的运用和同步执行的性质 dispatch_suspend 和 dispatch_resume12dispatch_suspend(queue);dispatch_resume(queue); 挂起后，已经执行过的任务不会受到影响，而已经追加到队列中但尚未执行的任务将停止执行，直到队列被恢复 什么场景下使用？ 一般在内存警告后取消队列中的操作 为了保证 scorllView 在滚动的时候流畅，通常在滚动开始时，暂停队列中的所有操作，滚动结束后，恢复操作 dispatch_group_enter 和 dispatch_group_leave假如有一个耗时操作 A 和 2 个网络请求 B、C，现在需要等到 ABC 都完成后刷新页面 注意如果网络请求的代码不使用 dispatch_group_enter 而使用 dispatch_group_async 是有问题的 1234567// 错误的示例// B 网络请求dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [self sendRequestWithCompletion:^(id response) &#123; number += 2; &#125;];&#125;); 问题在于，加入队列中的任务是一个网络请求，它是异步的，因此这个任务会被立刻完成（尽管此时网络请求还没回来） 对于 group 多任务中的异步任务，我们需要使用 dispatch_group_enter 和 dispatch_group_leave 实现 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)testGCDEnter&#123; dispatch_group_t group = dispatch_group_create(); __block NSInteger number = 0; // A 耗时操作 dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(3); number += 1; &#125;); // B 网络请求 dispatch_group_enter(group); [self sendRequestWithCompletion:^(id response) &#123; number += 2; dispatch_group_leave(group); &#125;]; // C 网络请求 dispatch_group_enter(group); [self sendRequestWithCompletion:^(id response) &#123; number += 3; dispatch_group_leave(group); &#125;]; dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;%zd&quot;, number); &#125;);&#125;- (void)sendRequestWithCompletion:(void (^)(id response))completion&#123; //模拟一个网络请求 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_async(dispatch_get_main_queue(), ^&#123; if (completion) completion(nil); &#125;); &#125;);&#125; 当调用 dispatch_group_create 的时候，生成的 group 内部会维护一个信号量。 当调用 dispatch_group_enter 的时候，信号量会减 1； 当调用 dispatch_group_leave 的时候，信号量会加 1；此时会判断信号量是否恢复为初始值；如果是则调用 dispatch_group_notify 当调用 dispatch_group_async 的时候，其内部实际上也调用了 dispatch_group_enter 和 dispatch_group_leave 注意： dispatch_group_enter 必须在 dispatch_group_leave 之前出现 dispatch_group_enter 和 dispatch_group_leave 必须成对出现 更多资料可参考：深入理解GCD之dispatch_group dispatch_once单例 dispatch_semaphore少用，待补充 dispatch iO少用，待补充 相关链接 我的脑图 iOS多线程：『GCD』详尽总结","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"GCD","slug":"tech/iOS/GCD","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/GCD/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/GCD/GCD_实践/","text":"异步处理耗时任务后主线程更新 UI12345678// 获取全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; // 耗时操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 回主线程刷 UI &#125;);&#125;); 输出顺序123456789101112131415- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; NSLog(@&quot;1&quot;); [self performSelector:@selector(printLog) withObject:nil afterDelay:0]; NSLog(@&quot;3&quot;); &#125;);&#125; - (void)printLog&#123; NSLog(@&quot;2&quot;);&#125; 输出 1、3，因为子线程没有开启 RunLoop；注意即使是 afterDelay 为 0，也是会放到下个 RunLoop 去做 如何实现多读单写？123456789101112131415161718- (id)objectForKey:(NSString *)key&#123; __block id ret; // 注意 __block dispatch_sync(self.concurrentQueue, ^&#123; // 读操作 ret = [self.dic objectForKey:key]; &#125;); return ret;&#125;- (void)setObject:(id)object forKey:(NSString *)key&#123; key = [key copy]; dispatch_barrier_async(self.concurrentQueue, ^&#123; // 写操作 [self.dic setObject:object forKey:key]; &#125;);&#125; 多读单写的本质是，读读并发，读写互斥，写写互斥这三部分。其中读读并发确定了队列必须是并发队列，读写互斥和写写互斥都利用 dispatch_barrier_async 来实现 注意 __block 的使用 注意读的时候是同步；写的时候是异步。我们不需要使每次程序执行的时候都等待写操作完成，所以写操作异步执行，但是我们需要同步的执行读操作来保证程序能够立刻得到它想要的值 使用的队列是自己创建的而不是全局并发队列，经测试，使用全局并发队列会导致 dispatch_barrier_async 退化为 dispatch_async，失去栅栏效果 dispatch_barrier_async 的 block 运行时机是，在它之前所有的任务执行完毕，并且在它后面的任务开始之前，期间不会有其他的任务执行 写操作的时候需要对 key 进行 copy，防止传入的 key 是 NSMutableString，异步之后它被外部修改 两个 dispatch_barrier_async 任务也是互斥的，因此写与写之间也不会有多线程冲突问题 MRC 下的多读单写如果把 ARC 的代码转成以下 MRC 会有什么问题 1234567891011121314151617- (id)objectForKey:(NSString *)key&#123; __block id ret; dispatch_sync(self.concurrentQueue, ^&#123; ret = [self.dic objectForKey:key]; &#125;); return ret;&#125; - (void)setObject:(id)object forKey:(NSString *)key&#123; key = [key copy]; dispatch_barrier_async(self.concurrentQueue, ^&#123; [self.dic setObject:object forKey:key]; &#125;); [key release]; // MRC 添加&#125; 这样如果 A 线程正读取完一个值；而 B 线程随后对该值进行置 nil，那么 A 拿到的数据就会野指针 解决方案如下： 12345678- (id)objectForKey:(NSString *)key&#123; __block id ret; dispatch_sync(self.concurrentQueue, ^&#123; ret = [[self.dic objectForKey:key] retain]; &#125;); return [ret autorelease];&#125; 如何异步下载多张图片后并拼接见 dispatch_group_notify 如果需要按序下载图片呢？则使用串行队列即可","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"GCD","slug":"tech/iOS/GCD","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/GCD/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/GCD/dispatch_set_target_queue/","text":"基础用法dispatch_set_target_queue 的作用： 改变队列优先级 让多个串行队列之间也能串行地执行任务 改变队列优先级dispatch_queue_create 创建的队列，无论是串行还是并发，其优先级都是 DISPATCH_QUEUE_PRIORITY_DEFAULT，使用 dispatch_set_target_queue 可以改变队列优先级 1234567891011121314151617181920212223242526dispatch_queue_t serialQueue = dispatch_queue_create(&quot;&quot;, NULL);dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);//变更后 dispatch_async(serialQueue, ^&#123; NSLog(@&quot;1&quot;); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); &#125;); dispatch_set_target_queue(serialQueue, globalQueue);// 变更后dispatch_async(serialQueue, ^&#123; NSLog(@&quot;3&quot;); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;4&quot;); &#125;); // 输出如下// 1// 2// 4// 3 第一个参数如果是主队列或者是全局并发队列则后果未知 让多个串行队列之间也能串行地执行任务如果创建多个串行队列，它们之间其实是并行处理的。如果都对它们分别使用 dispatch_set_target_queue，指定为某一个串行队列，那么它们的任务将在目标串行队列上串行处理 123456789101112131415161718dispatch_queue_t mySerialDispatchQueue1 = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue1&quot;, NULL);dispatch_queue_t mySerialDispatchQueue2 = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue2&quot;, NULL);dispatch_queue_t targetDispatchQueue = dispatch_queue_create(&quot;com.example.gcd.TargetDispatchQueue&quot;, NULL);dispatch_set_target_queue(mySerialDispatchQueue1, targetDispatchQueue);dispatch_set_target_queue(mySerialDispatchQueue2, targetDispatchQueue);dispatch_async(mySerialDispatchQueue1, ^&#123; NSLog(@&quot;1 %@&quot;, [NSThread currentThread]);&#125;);dispatch_async(mySerialDispatchQueue2, ^&#123; NSLog(@&quot;2 %@&quot;, [NSThread currentThread]);&#125;);// Queue1 和 Queue2 之间有依赖关系，它们的人物会在目标串行队列上串行处理// 输出// 1 targetDispatchQueue 所在的线程// 2 targetDispatchQueue 所在的线程 进阶探究不同串行队列的任务顺序当我们创建队列时，队列会附加到某一个全局队列。默认情况下会附加到默认优先级队列上 当往我们创建的队列添加任务时，这个任务会放到该队列的队尾 当该任务到达队列的头时，会把该任务移动到目标队列进行执行；并继续处理该队列的下一个任务 12345678910111213141516dispatch_queue_t mySerialDispatchQueue1 = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue1&quot;, NULL);dispatch_queue_t mySerialDispatchQueue2 = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue2&quot;, NULL);dispatch_queue_t targetDispatchQueue = dispatch_queue_create(&quot;com.example.gcd.TargetDispatchQueue&quot;, NULL);dispatch_set_target_queue(mySerialDispatchQueue1, targetDispatchQueue);dispatch_set_target_queue(mySerialDispatchQueue2, targetDispatchQueue);dispatch_async(mySerialDispatchQueue2, ^&#123; NSLog(@&quot;1 %@&quot;, [NSThread currentThread]);&#125;);dispatch_async(mySerialDispatchQueue1, ^&#123; NSLog(@&quot;2 %@&quot;, [NSThread currentThread]);&#125;);dispatch_async(mySerialDispatchQueue2, ^&#123; NSLog(@&quot;3 %@&quot;, [NSThread currentThread]);&#125;); 执行结果： 1231 targetDispatchQueue所在的线程3 targetDispatchQueue所在的线程2 targetDispatchQueue所在的线程 注意即使任务 3 是在任务 2 之后添加，但是却比任务 2 先执行 以上这个例子中，队列 1 和队列 2 的目标队列都是一个串行队列，主线程执行完毕后，队列 2 有任务 1 和任务 3，队列 1 有任务 2。GCD 开始会优先处理了队列 2 的任务 1，继而继续处理了任务 3；处理完队列 2 之后再处理队列 1 的任务 2 如何利用 GCD 实现一个优先队列123456789101112131415161718192021dispatch_queue_t low = dispatch_queue_create(&quot;low&quot;,DISPATCH_QUEUE_SERIAL);dispatch_queue_t high = dispatch_queue_create(&quot;high&quot;,DISPATCH_QUEUE_SERIAL);// low 队列的目标队列指定为 highdispatch_set_target_queue(low, high);// 执行一个 low 任务dispatch_async(low,^&#123; NSLog(@&quot;Low&quot;);&#125;);// 要分派到高优先级队列，暂停低优先级队列，并且在高优先级块结束后恢复低优先级队列：dispatch_suspend(low);dispatch_async(high,^&#123; NSLog(@&quot;High1&quot;); dispatch_resume(low);&#125;);dispatch_suspend(low);dispatch_async(high,^&#123; NSLog(@&quot;High2&quot;); dispatch_resume(low);&#125;); dispatch_set_target_queue(low, high) 可以实现将所有的 low 队列的任务全部移到 high 队列处理，因此可以保证，处理 low 队列任务的时候，high 队列中现存的任务一定是优先于 low 队列。解决的是执行 low 的时候，high 的存量问题，保证了 low 一定要排队尾。 dispatch_suspend 保证添加 high 任务时，会暂停 low 队列，直到该任务完成才恢复。解决的是 high 任务的增量问题，保证了 high 可以插队 参考资料 如何利用 GCD 实现一个优先队列","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"GCD","slug":"tech/iOS/GCD","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/GCD/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/RunLoop/RunLoop 源码分析/","text":"本文对应的源码地址——CFRunLoop.h本文对应的源码地址——CFRunLoop.c 数据结构CFRunLoop12345678struct __CFRunLoop &#123; pthread_t _pthread; // RunLoop 对应的线程 CFMutableSetRef _commonModes; // CommonMode 的集合 CFMutableSetRef _commonModeItems; // CommondModeItem 的集合 CFRunLoopModeRef _currentMode; // 当前的 Mode CFMutableSetRef _modes; // 该 RunLoop 包含的 Mode ...&#125;; RunLoop 与线程一一对应 CommonModes 是一个集合，CommondModeItem 也是一个集合 虽然 RunLoop 可以包含多个 Modes，但是 currentMode 只能有一个，即在同一个时间只能指定一种 Mode 运行 CFRunLoopMode12345678910typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFStringRef _name; // Mode 的名称 CFMutableSetRef _sources0; // Source0 集合 CFMutableSetRef _sources1; // Source1 集合 CFMutableArrayRef _observers; // Observer 数组 CFMutableArrayRef _timers; // Timer 数组 ...&#125;; CFRunLoopModeRef 是指向 __CFRunLoopMode 的指针，我们只需要研究 __CFRunLoopMode 即可 CFRunLoop 管理了 CFRunLoopModeRef 的集合 CFRunLoopModeRef 包含了 Source0/Source1 的集合；以及 Observer/Timer 的数组（为什么 Source 是集合，Observer/Timer 是数组？） Source0/Source1 的类型是 CFRunLoopSource（虽然上面代码看不出来） CFRunLoopSource12345678910111213141516171819202122struct __CFRunLoopSource &#123; CFMutableBagRef _runLoops; // 一个 Source 可以被加入到多个 RunLoop union &#123; CFRunLoopSourceContext version0; // Source0 CFRunLoopSourceContext1 version1; // Source1 &#125; _context;&#125;;typedef struct &#123; CFIndex version; // 区分是 Source0 还是 Source1 void (*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode); void (*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode); void (*perform)(void *info); ...&#125; CFRunLoopSourceContext;typedef struct &#123; CFIndex version; // 区分是 Source0 还是 Source1 mach_port_t (*getPort)(void *info); // Source1 是基于 Port void * (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info); ...&#125; CFRunLoopSourceContext1; 一个 Source 可以被加入到多个 RunLoop CFRunLoopSource 包含了 Source0/Source1，union 中所有成员变量的起始地址都是一样的，Source0 和 Source 共占同一段内存的结构，_context 变量的大小取决于 Source0 和 Source1 的最大大小 Source0 比 Source1 多了 schedule 和 cancle 方法？；而 Source1 比 Source0 多了接受 Port 消息的方法。所以说 Source1 是基于 Port 的 CFRunLoopObserver123456struct __CFRunLoopObserver &#123; CFRunLoopRef _runLoop; // Observer 所在的 RunLoop CFIndex _rlCount; // Observer 当前监测的 RunLoop 数 CFOptionFlags _activities; // Observer 可以回调给监听者的时间点 ...&#125;; 一个 Observer 只能监听一个 RunLoop 其中 rlCount 是用来更新 runloop 的值（如果 Observer 添加到 A，B，再从 A 中移除，此时是有问题的，Observer 的 runloop 仍然指向 A？） 12345678910111213141516171819static void __CFRunLoopObserverSchedule(CFRunLoopObserverRef rlo, CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; __CFRunLoopObserverLock(rlo); // 如果一个 Observer 被添加到多个 RunLoop，则只有第一个会生效 if (0 == rlo-&gt;_rlCount) &#123; rlo-&gt;_runLoop = rl; &#125; rlo-&gt;_rlCount++; __CFRunLoopObserverUnlock(rlo);&#125;static void __CFRunLoopObserverCancel(CFRunLoopObserverRef rlo, CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; __CFRunLoopObserverLock(rlo); rlo-&gt;_rlCount--; // 如果一个 Observer 没有监听任何 RunLoop，则重置 _runLoop if (0 == rlo-&gt;_rlCount) &#123; rlo-&gt;_runLoop = NULL; &#125; __CFRunLoopObserverUnlock(rlo);&#125; CFOptionFlags 是枚举值，包含以下时间点 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 开始进入 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 休眠唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 结束退出 kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; CFRunLoopTimer12345678910struct __CFRunLoopTimer &#123; uint16_t _bits; // Timer 的状态(firing、fired-during-callout、waking) CFRunLoopRef _runLoop; // 所在的 RunLoop CFMutableSetRef _rlModes; // 所在的 Mode 集合 CFAbsoluteTime _nextFireDate; // 下一次触发时机=当前时间+interval CFTimeInterval _interval; // 理想的触发间隔 CFTimeInterval _tolerance; // 时间偏差 CFRunLoopTimerCallBack _callout; // Timer 的回调 ...&#125;; 一个 Timer 可以被添加到多个 Mode bits 字段表示 Timer 的状态，主要有 0:firing、1:fired-during-callout、2:waking？ nextFireDate 和 interval：一个 Timer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点，这里 interval 就是 10 秒。nextFireDate 依次是 10:00, 10:10, 10:20 tolerance：RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行 CFRunLoopDoTimers123456789101112131415161718192021222324252627282930313233/*limitTSR：终止时间，如果 timer 下一次触发时间超过这个值，则 timer 不会生效*/static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR)&#123; Boolean timerHandled = false; CFMutableArrayRef timers = NULL; // 1. 遍历 rlm 的所有 Timer，取出下一次触发时间小于当前系统时间的 Timer 组成数组 for (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) &#123; CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx); if (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) &#123; if (rlt-&gt;_fireTSR &lt;= limitTSR) &#123; if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks); CFArrayAppendValue(timers, rlt); &#125; &#125; &#125; // 2. 对该数组的 Timer 进行遍历，调用 __CFRunLoopDoTimer(rl, rlm, rlt); for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123; CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx); Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt); timerHandled = timerHandled || did; &#125; if (timers) CFRelease(timers); return timerHandled;&#125; limitTSR 这里传的是 mach_absolute_time()，该函数返回一个基于系统启动后的时钟嘀嗒数，表示当前系统时间 精简伪代码 12345static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR)&#123; 1. 遍历 rlm 的所有 Timer，取出下一次触发时间小于当前系统时间的 Timer 组成数组 2. 对该数组的 Timer 进行遍历，调用 __CFRunLoopDoTimer(rl, rlm, rlt);&#125; CFRunLoopDoTimer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt)&#123; Boolean timerHandled = false; uint64_t oldFireTSR = 0; if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) &#123; // interval = 0 的 Timer 都是一次性的 Boolean doInvalidate = (0.0 == rlt-&gt;_interval); // 设置正在 fire 的标志位 __CFRunLoopTimerSetFiring(rlt); // 记录本次的调用时间，待会用到 oldFireTSR = rlt-&gt;_fireTSR; // 计算下一次 Timer 应该触发的时机并注册对应的 timer（mk_timer or GCD Timer） __CFArmNextTimerInMode(rlm, rl); // 调用 timer 的回调 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info); // 如果 timer 如果 interval 为 0，则移除 timer（无论是不是 repeat，只要 interval 为 0 就只调用一次） if (doInvalidate) &#123; CFRunLoopTimerInvalidate(rlt); &#125; timerHandled = true; // 取消 fire 的标志位 __CFRunLoopTimerUnsetFiring(rlt); &#125; // 非一次性 Timer 在执行回调之后需要更新 fireTSR 和 nextFireDate if (__CFIsValid(rlt) &amp;&amp; timerHandled) &#123; if (oldFireTSR &lt; rlt-&gt;_fireTSR) &#123; // 如果刚刚在 Timer 的回调期间，调整了该 Timer（调整的结果就是这个 timer 的 fireTSR 一定会变大） // 这种情况下如果此时该 Timer 依然是最小的，那么刚刚的 __CFArmNextTimerInMode 的计算就是错的 // 因为该 Timer 被设置了 fire 而被忽略，没有纳入计算 // 所以这里补充一次重新计算 __CFArmNextTimerInMode(rlm, rl); &#125; else &#123; uint64_t nextFireTSR = 0LL; uint64_t intervalTSR = 0LL; // 确保 intervalTSR 不会超过最大值 if (rlt-&gt;_interval &lt;= 0.0) &#123; // 如果在 Timer 回调期间修改了 interval，可能会走到这里，do nothing &#125; else if (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) &#123; intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT); &#125; else &#123; intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval); &#125; // 计算下一次触发时间 if (LLONG_MAX - intervalTSR &lt;= oldFireTSR) &#123; // 如果 interval 很大很大，超过上限 nextFireTSR = LLONG_MAX; &#125; else &#123; if (intervalTSR == 0) &#123; // 一般不可能走到，只是为了防止死循环 CRSetCrashLogMessage(&quot;A CFRunLoopTimer with an interval of 0 is set to repeat&quot;); HALT; &#125; uint64_t currentTSR = mach_absolute_time(); nextFireTSR = oldFireTSR; // 确保下次触发的时间一定大于当前时间（每次增加 interval 的倍数） while (nextFireTSR &lt;= currentTSR) &#123; nextFireTSR += intervalTSR; &#125; &#125; // 更新 fireTSR 和 nextFireDate CFRunLoopRef rlt_rl = rlt-&gt;_runLoop; if (rlt_rl) &#123; // 如果 Timer 是在 RunLoop 里，则更新了 fireTSR 和 nextFireDate 之后 // 需要对 RunLoop 的每个包含该 Timer 的 Mode 的 Timers 重新排序 CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes); STACK_BUFFER_DECL(CFTypeRef, modes, cnt); CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes); // 寻找包含了该 Timer 的 Mode for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123; CFStringRef name = (CFStringRef)modes[idx]; modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false); &#125; // 更新自己 rlt-&gt;_fireTSR = nextFireTSR; rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR); // 排序 for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123; CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx]; if (rlm) &#123; // 对 mode 中的 timer 重新排序 __CFRepositionTimerInMode(rlm, rlt, true); &#125; &#125; &#125; else &#123; // 没有 RunLoop，更新自己即可 rlt-&gt;_fireTSR = nextFireTSR; rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR); &#125; &#125; &#125; return timerHandled;&#125; 触发 Timer 的回调；更新此 Timer 的下一次触发时间；同时对包含该 Timer 的 Mode 的 Timers 重新排序 对于重复的 Timer，其多次触发的时刻不是一开始算好的，而是 Timer 触发后计算的。但是计算时参考的是上次应当触发的时间 _fireTSR（而不是当前时间），因此计算出的下次触发的时刻不会有误差。这保证了 Timer 不会出现误差叠加。比如本来 5 秒触发一次，第一次却延迟到第 7 秒才触发，但是第二次依然在 10 秒触发，而不是 12 秒。具体可以看 _fireTSR 的赋值是由 nextFireTSR 决定，而 nextFireTSR 是由上一次的 _fireTSR 决定 对于重复的 Timer，如果 RunLoop 很忙，那么 Timer 的一些回调可能被忽略。当 RunLoop 不忙了，开始处理 Timer 的时候，即上述函数，此时因为 nextFireTSR 的是一定要比当前时间晚，所以小于当前时间的触发时机都会被忽略，比如本来 5 秒触发一次，第一次在第 5 秒时正常触发，第二次却延迟到了第 16 秒才触发，那么第 15 秒的触发就会被取消，第三次应该触发的时机是 20 秒，如下图和代码 1234while (nextFireTSR &lt;= currentTSR)&#123; nextFireTSR += intervalTSR;&#125; CFArmNextTimerInMode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl)&#123; uint64_t nextHardDeadline = UINT64_MAX; uint64_t nextSoftDeadline = UINT64_MAX; if (rlm-&gt;_timers) &#123; // Timers 是按照 softDeadline 排序 // 遍历 Timers，计算 Mode 的 softDeadLine 和 hardDeadLine // softDeadline 是理应触发的时间；hardDeadline 是理应触发的时间加上 tolerance // 即计算下一次应该触发 Timer 的精准时机和模糊时机（这两个时机不一定来自同一个 Timer） for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) &#123; CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx); // 如果正在调用则过滤，详见 __CFRunLoopDoTimer if (__CFRunLoopTimerIsFiring(t)) continue; int32_t err = CHECKINT_NO_ERROR; // softDeadline 是理应触发的时间；hardDeadline 是理应触发的时间加上 tolerance uint64_t oneTimerSoftDeadline = t-&gt;_fireTSR; uint64_t oneTimerHardDeadline = check_uint64_add(t-&gt;_fireTSR, __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;err); if (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX; // Timers 是按照 softDeadline 排序，如果此时 softDeadline 已经很大 // 说明下一次的触发时机一定跟这个 Timer 无关，因此可以跳过 // oneTimerSoftDeadline &gt; nextHardDeadline &gt;= nextSoftDeadline if (oneTimerSoftDeadline &gt; nextHardDeadline) &#123; break; &#125; // 找最小的那个 if (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123; nextSoftDeadline = oneTimerSoftDeadline; &#125; if (oneTimerHardDeadline &lt; nextHardDeadline) &#123; nextHardDeadline = oneTimerHardDeadline; &#125; &#125; if (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;_timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123; // leeway = tolerance（这个 tolerance 可能是两个 Timer 的 deadline 相减得到） uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline); dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline); if (leeway &gt; 0) &#123; // 如果有 tolerance，则取消 mk_timer if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123; AbsoluteTime dummy; mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy); rlm-&gt;_mkTimerArmed = false; &#125; // 底层通过 dispatch_source_set_timer 注册 timer _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway); rlm-&gt;_dispatchTimerArmed = true; &#125; else &#123; // 如果没有 tolerance，则取消 dispatch timer if (rlm-&gt;_dispatchTimerArmed) &#123; // Cancel the dispatch timer _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888); rlm-&gt;_dispatchTimerArmed = false; &#125; // 注册 mk_timer if (rlm-&gt;_timerPort) &#123; mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline)); rlm-&gt;_mkTimerArmed = true; &#125; &#125; &#125; else if (nextSoftDeadline == UINT64_MAX) &#123; // nextSoftDeadline &lt;= nextHardDeadline，因此 nextHardDeadline 也是 UINT64_MAX // 走到这里说明没有合法的 Timer 可以被下次 RunLoop 调用 // 取消所有类型的 Timer if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123; AbsoluteTime dummy; mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy); rlm-&gt;_mkTimerArmed = false; &#125; if (rlm-&gt;_dispatchTimerArmed) &#123; _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333); rlm-&gt;_dispatchTimerArmed = false; &#125; &#125; &#125; rlm-&gt;_timerHardDeadline = nextHardDeadline; rlm-&gt;_timerSoftDeadline = nextSoftDeadline;&#125; 首先要知道 Mode 的 Timers 是按照 softDeadline 排序； 该函数通过遍历 Mode 下的所有 Timer，计算出下一次应该触发 Timer 的 softDeadline 和 hardDeadline（这两个时机不一定来自同一个 Timer）； 如果有 tolerance ，则注册一个 GCD Timer；否则注册一个 mk_timer RunLoop 的入口在 Core Foundation 中我们可以通过以下2个 API 来让 RunLoop 运行 在默认的 mode 下运行当前线程的 RunLoop 123456void CFRunLoopRun(void) &#123; int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125; 在指定 mode 下运行当前线程的 RunLoop 123SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; 虽然 RunLoop 有很多个 mode，但是 RunLoop 在 run 的时候必须只能指定其中一个 mode，运行起来之后，被指定的 mode 即为 currentMode CFRunLoopRunSpecific123456789101112131415161718192021222324252627282930313233SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)&#123; // 是否已经析构 if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished; CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); // 判断指定的 Mode 存不存在，或者 ModeItem 是不是空的 if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123; return kCFRunLoopRunFinished; &#125; // 备份上一个 Mode 的数据 volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl); CFRunLoopModeRef previousMode = rl-&gt;_currentMode; rl-&gt;_currentMode = currentMode; int32_t result = kCFRunLoopRunFinished; // 如果注册了对应的 Observer，则通知即将进入 RunLoop if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 真正处理 RunLoop result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 如果注册了对应的 Observer，则通知即将结束 RunLoop if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); // 恢复上一个 Mode 的数据 __CFRunLoopPopPerRunData(rl, previousPerRun); rl-&gt;_currentMode = previousMode; return result;&#125; 如果一个 RunLoop Mode 是空的，则 __CFRunLoopModeIsEmpty 这一步就会返回 true 而导致 RunLoop 退出 通知 Observer 即将进入和即将退出的代码可以在这里找到 CFRunLoopModeIsEmpty12345678910111213141516171819202122232425262728293031323334353637static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode)&#123; if (NULL == rlm) return true; // 如果是主线程，直接 return false Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) return false; // 如果 source0/source1/timer 有一个，则 return false if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) return false; if (NULL != rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) return false; if (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) return false; // 传入的 mode 是否存在于当前的 RunLoop 的 Block Mode 中，或者存在于当前 RunLoop 的 CommonModes 中 struct _block_item *item = rl-&gt;_blocks_head; while (item) &#123; struct _block_item *curr = item; item = item-&gt;_next; Boolean doit = false; // 判断 Mode 是不是一个 string 类型 // 比较传入的 mode 是否存在于当前的 RunLoop，或者存在于当前 RunLoop 的 CommonModes 中 if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123; doit = CFEqual(curr-&gt;_mode, rlm-&gt;_name) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)); &#125; else &#123; doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, rlm-&gt;_name) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)); &#125; if (doit) return false; &#125; return true;&#125; 几乎网上所有的文章都说，如果没有 Source0/Source1/Timer，则 RunLoop Mode 是空的，但是其实不尽然，这里还有一个 Block 类型的判断在别的文章里没有被提到，从 macOS 10.6/iOS 4 开始，可以使用 CFRunLoopPerformBlock 函数往 run loop 中添加 blocks。正确的说法应该是，如果没有 Source0/Source1/Timer 以及该 RunLoop 的 _blocks_head 链表中也找不到该 Mode，才能判断该 Mode 是空的 注意我们说的不是 RunLoop 是空的，准确的说应该是 RunLoop Mode 是空的，由于一个 RunLoop 一次只能运行一个 Mode，所以这两种说法在某种意义上是等价的 CFRunLoopRun123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260/** RunLoop 的主流程，无限运行的秘密就在此 @param rl RunLoop @param rlm RunLoop Mode @param seconds RunLoop 超时时间 @param stopAfterHandle 处理后是否结束 @param previousMode 上一个 RunLoop Mode @return */static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123; // 记录当前时间 uint64_t startTSR = mach_absolute_time(); // 处理一些异常情况 if (__CFRunLoopIsStopped(rl)) &#123; __CFRunLoopUnsetStopped(rl); return kCFRunLoopRunStopped; &#125; else if (rlm-&gt;_stopped) &#123; rlm-&gt;_stopped = false; return kCFRunLoopRunStopped; &#125; // 声明用于和 mach_port 通信的端口 mach_port_name_t dispatchPort = MACH_PORT_NULL; // 如果是主线程，给端口赋值 Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); // dispatch_get_main_queue_handle_4CF 返回的是主线程 RunLoop 所关联的的端口 if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF(); // 处理 Timer 相关 dispatch_source_t timeout_timer = NULL; struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context)); if (seconds &lt;= 0.0) &#123; // 不超时 seconds = 0.0; timeout_context-&gt;termTSR = 0ULL; &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123; // 正常限制内的超时 // 根据是否是主线程来取主队列 or 后台队列 dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground(); // 创建 GCD Timer timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // Retain，防止释放 dispatch_retain(timeout_timer); // 记录在超时上下文 timeout_context-&gt;ds = timeout_timer; timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl); timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds); // 超时上下文记录在 Timer dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context // 设置超时回调 dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout); // 设置超时取消回调 dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel); uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL); dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL); // 启动定时器 dispatch_resume(timeout_timer); &#125; else &#123; // 无限超时 seconds = 9999999999.0; timeout_context-&gt;termTSR = UINT64_MAX; &#125; Boolean didDispatchPortLastTime = true; int32_t retVal = 0; // 让我们开启无限循环的秘密 do &#123; voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED; voucher_t voucherCopy = NULL; uint8_t msg_buffer[3 * 1024]; mach_msg_header_t *msg = NULL; mach_port_t livePort = MACH_PORT_NULL; __CFPortSet waitSet = rlm-&gt;_portSet; // 取消 RunLoop 的忽略唤醒信号，从此在线接收唤醒（可以接收 port 消息） __CFRunLoopUnsetIgnoreWakeUps(rl); // 通知即将处理 Timer if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知即将处理 Source if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 处理 Blocks __CFRunLoopDoBlocks(rl, rlm); // 处理 Source0（非 port） Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); if (sourceHandledThisLoop) &#123; // 如果处理了 Source0 之后还有 Block 要处理，则再次处理 Block __CFRunLoopDoBlocks(rl, rlm); &#125; // poll = 是否处理 Source0 或没有超时 Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR); // 如果是主线程的队列里有未处理的消息且上一次循环的睡眠不是 dispatch 唤醒的 if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123; msg = (mach_msg_header_t *)msg_buffer; // timeout 为 0，不会休眠，直接处理消息 if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123; goto handle_msg; &#125; &#125; didDispatchPortLastTime = false; // 通知即将休眠 if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); // 设置睡眠标志 __CFRunLoopSetSleeping(rl); // 每次循环都将 dispatchPort 加入监听端口集合中 __CFPortSetInsert(dispatchPort, waitSet); // 开始睡眠时间 CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent(); if (kCFUseCollectableAllocator) &#123; memset(msg_buffer, 0, sizeof(msg_buffer)); &#125; msg = (mach_msg_header_t *)msg_buffer; // 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 // • 一个基于 port 的 Source 的事件。 // • 一个 Timer 到时间了 // • RunLoop 自身的超时时间到了 // • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); // 睡了多久 rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart)); // 每次循环都移除刚刚的 dispatchPort __CFPortSetRemove(dispatchPort, waitSet); // 设置 RunLoop 的忽略唤醒信号，从此下线不接收唤醒（不再接收 port 消息） __CFRunLoopSetIgnoreWakeUps(rl); // 取消睡眠标志 __CFRunLoopUnsetSleeping(rl); // 通知结束休眠 if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); // 处理消息 handle_msg:; // 设置 RunLoop 的忽略唤醒信号，从此下线不接收唤醒（不再接收 port 消息） __CFRunLoopSetIgnoreWakeUps(rl); if (MACH_PORT_NULL == livePort) &#123; CFRUNLOOP_WAKEUP_FOR_NOTHING(); // handle nothing &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123; CFRUNLOOP_WAKEUP_FOR_WAKEUP(); // do nothing on Mac OS &#125; else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123; CFRUNLOOP_WAKEUP_FOR_TIMER(); if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; // Re-arm the next timer __CFArmNextTimerInMode(rlm, rl); &#125; &#125; else if (livePort == dispatchPort) &#123; CFRUNLOOP_WAKEUP_FOR_DISPATCH(); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL); __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL); sourceHandledThisLoop = true; didDispatchPortLastTime = true; &#125; else &#123; CFRUNLOOP_WAKEUP_FOR_SOURCE(); voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release); CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); if (rls) &#123; mach_msg_header_t *reply = NULL; sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; if (NULL != reply) &#123; (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply); &#125; &#125; // Restore the previous voucher _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release); &#125; // 处理 Blocks __CFRunLoopDoBlocks(rl, rlm); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; // 进入该函数时参数说处理完事件就返回 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123; // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(rl)) &#123; // 被外部调用者强制停止了 __CFRunLoopUnsetStopped(rl); retVal = kCFRunLoopRunStopped; &#125; else if (rlm-&gt;_stopped) &#123; // Mode 已经被标记为 Stop rlm-&gt;_stopped = false; retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; // source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; voucher_mach_msg_revert(voucherState); os_release(voucherCopy); &#125; while (0 == retVal); // 释放 timer if (timeout_timer) &#123; // 如果有 timer，timeout_context 是被 timer 内部管理，不需要手动释放 dispatch_source_cancel(timeout_timer); dispatch_release(timeout_timer); &#125; else &#123; // 手动管理 timeout_context free(timeout_context); &#125; return retVal;&#125; mach_msg 1234567mach_msg_return_t mach_msg(mach_msg_header_t msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t receive_limit, mach_port_t receive_name, mach_msg_timeout_t timeout, mach_port_t notify); 详细可参考 源码 mach_msg 是系统内核在某个 port 收发消息所使用的函数，收消息与发消息都是调用这个函数，只是 mach_msg_option_t 参数不同，发送为 MACH_SEND_MSG，接收为 MACH_RCV_MSG 可以简单的将 mach_msg 理解为多进程之间的一种通信机制，不同的进程可以使用同一个消息队列来交流数据，当使用 mach_msg 从消息队列里读取 msg 时，可以在参数中 timeout 值，在 timeout 之前如果没有读到 msg，当前线程会一直处于休眠状态。这也是 runloop 在没有任务可执行的时候，能够进入 sleep 状态的原因。如果 timeout = 0，则不会进入休眠；如果 timeout = TIMEOUT_INFINITY，则在没消息之前一直休眠 无限循环的真相 代码中一共出现了两处 __CFRunLoopServiceMachPort，注意 timeout 的值 12345// TimeOut 为 0__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL) // TimeOut 为 0 or 无限大__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); `__CFRunLoopServiceMachPort` 的实质是调用了 `mach_msg` 1234567ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : 0)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL); 第一处 `mach_msg` ，即如果主队列有任务执行，则不会进入睡眠，应该是为了保障 dispatch 到 main queue 的代码总是有较高的机会得以运行 可以看到 source0 是没有唤醒 RunLoop 的能力的，而 source1 有 可以看到并不是每次 RunLoop 如果处理了 source0 任务，那么 poll 值会为 true，会直接进入睡眠，而且不会告知 BeforeWaiting 和 AfterWaiting。所以有些情况下经过了几次循环，但注册的 observer 却不会收到回调","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"RunLoop","slug":"tech/iOS/RunLoop","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/RunLoop/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/RunLoop/RunLoop/","text":"RunLoop 脑图 RunLoop 流程 RunLoop 相关概念Event Loop事件循环模型，实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒 12345678910function loop() &#123; init(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束 RunLoop 就是 OSX/iOS 平台对事件循环模型的实现，在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI 刷新事件、定时器事件）和消息，从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省 CPU 资源，提高程序性能 NSRunLoop 和 CFRunLoopOSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoop CFRunLoop 是 Core Foundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的 NSRunLoop 是 Foundation 框架内的，提供了面向对象的 API，但是这些 API 不是线程安全的 其中 NSRunLoop 是对 CFRunLoop 的简单封装，需要着重研究的只有 CFRunLoop 更准确的说，代码里面是 CFRunLoopRef，本文统一简称为 CFRunLoop RunLoop 与线程的关系苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数： Core Foundation 框架中的获取方法：CFRunLoopGetMain() 和 CFRunLoopGetCurrent() Foundation 框架中的获取方法：[NSRunLoop mainRunLoop] 和 [NSRunLoop currentRunLoop] 代码逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里，但是不代表有线程就有 RunLoop 除了主线程，如果想要获取线程的 RunLoop，只能在当前线程内获取； 除了主线程，如果没有主动获取线程的 RunLoop，则 RunLoop 不会创建 RunLoop 会在线程销毁时销毁 CFRunLoop 是基于 pthread 来管理的 pthread_t 和 NSThread 是一一对应的 可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程； 也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。 RunLoop 的结构结构图 在 CoreFoundation 里面关于 RunLoop 有5个类： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer（这三个都被称为 Mode Item）。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个 Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响 每次 RunLoop 只会以一种 Mode 运行，以该 Mode 运行的时候，就只执行和该 Mode 相关的任务，只通知该 Mode 注册过的 Observer Mode ItemSource/Timer/Observer 都被称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的 CFRunLoopSourceCFRunLoopSource 是事件产生的地方。 Source有两个版本：Source0 和 Source1 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件 Source1 是基于 port 的，包含了一个 mach_port 和一个回调（函数指针），可以接收内核消息并触发回调。这种 Source 能主动唤醒 RunLoop 的线程，比如触摸/锁屏/摇晃/点击 CFRunLoopTimerCFRunLoopTimer 是基于时间的触发器，它和 NSTimer 是 toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调 CFRunLoopObserverCFRunLoopObserver 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 事件源 种类图中展现了 RunLoop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件 Run Loop 的处理两大类事件源： Timer Source Input Source performSelector 的方法簇 Port 自定义的 Input Source 事件源缺失的后果如果一个 mode 没有 Source0/Source1/Timer（不管有没有 Observer），则 RunLoop 会直接退出，不进入循环。详搜 __CFRunLoopModeIsEmpty RunLoop Mode种类苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode NSDefaultRunLoopMode(kCFRunLoopDefaultMode) NSConnectionReplyMode NSModalPanelRunLoopMode NSEventTrackingRunLoopMode(UITrackingRunLoopMode) NSRunLoopCommonModes(kCFRunLoopCommonModes) 其中比较重要的模式如下，其他 Mode 不需要管 NSDefaultRunLoopMode：App的默认 Mode，通常主线程是在这个 Mode 下运行的 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 NSRunLoopCommonModes：实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common” Common Modes12345678910111213141516struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;;struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; 其中 _commonModes 其实并不是一个真正的模式，可以看到它是 Modes 而不是 Mode，是一个模式的集合 一个 Mode 可以将自己标记为 “Common” 属性，对应的方法是 CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); 添加 Source/Observer/Timer 时，如果指定的模式为 kCFRunLoopCommonModes，则会被添加 _commonModeItems 中；每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里 kCFRunLoopDefaultMode 默认是 “Common” 的 RunLoop 内部逻辑 流程图源文件 对应源码 其中 poll = 处理了 source0 || 没有超时 此处最好看源码！！！ RunLoop 的底层实现RunLoop 进入休眠时调用的函数是 mach_msg()，实际上是调用了一个 Mach 陷阱 mach_msg_trap()，当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会休眠并监听端口等待唤醒 休眠的具体流程如下： 指定一个将来唤醒自己的mach_port端口 调用 mach_msg 来监听这个端口，保持mach_msg_trap状态 由另一个线程（比如有可能有一个专门处理键盘输入事件的 loop 在后台一直运行）向内核发送这个端口的msg后，mach_msg_trap 状态被唤醒，RunLoop 继续运行 RunLoop 的应用系统应用事件响应（重要）如果发生触摸/锁屏/摇晃/点击等事件，首先是由 Source1 接收 IOHIDEvent，唤醒 RunLoop；之后在 Source1 的回调 __IOHIDEventSystemClientQueueCallback() 内触发 Source0 回调，Source0 的回调内部调用 UIApplication 将事件封装为 UIEvent 并分发出去。所以 UIButton 的点击事件在堆栈中看到是在 Source0 内的 界面更新（重要）setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调执行一个函数：遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面 定时器（重要）一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 由于 NSTimer 的这种机制，因此 NSTimer 的执行必须依赖于 RunLoop，如果没有 RunLoop，NSTimer 是不会执行的 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行 CADisplayLink 是一个和屏幕刷新率一致的定时器，比 NSTimer 精度更高。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。通常情况下 CADisaplayLink 用于构建帧动画，看起来相对更加流畅，而 NSTimer 则有更广泛的用处 AutoreleasePool（重要） 进入之前，创建 AutoreleasePool（监听 kCFRunLoopEntry） 休眠之前，销毁当前再创建一个新的 AutoreleasePool（监听 kCFRunLoopBeforeWaiting） 退出之前，销毁 AutoreleasePool（监听 kCFRunLoopExit） RunLoop 的实践应用卡顿检测（重要）RunLoop 处理事件的时间主要出在两个阶段： kCFRunLoopBeforeSources 和 kCFRunLoopBeforeWaiting 之间 kCFRunLoopAfterWaiting 之后 我们可以向主线程注册 Observer 观察其 RunLoop 的回调，如果回调时间过长，则认为发生卡顿 这个例子中，RunLoop 的回调用来发送信号量（就像喂食）；子线程则不断等待 RunLoop 发送的信号量并消耗它，最多等待 5 秒（等吃，如果有则吃掉，如果等了太久则不等了，开始哭）；超时发生时，一般 lastActivity 是 kCFRunLoopBeforeSources or kCFRunLoopAfterWaiting（哭一般是因为等待着两个事件） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@interface RunLoopMonitor()&#123; CFRunLoopObserverRef _observer; // 观察者 dispatch_semaphore_t _semaphore; // 信号量 CFRunLoopActivity _lastActivity; // 状态&#125;@end@implementation RunLoopMonitor+ (instancetype)sharedInstance&#123; static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; // 开始监听 [self registerObserver]; &#125;); return sharedInstance;&#125;static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; RunLoopMonitor *instance = [RunLoopMonitor sharedInstance]; // 记录状态值 instance-&gt; _lastActivity = activity; // 发送信号 dispatch_semaphore_signal(instance-&gt;_semaphore);&#125;// 注册一个Observer来监测Loop的状态,回调函数是runLoopObserverCallBack- (void)registerObserver&#123; // 这是在主线程 // 设置Runloop observer的运行环境 CFRunLoopObserverContext context = &#123;0, (__bridge void *)self, NULL, NULL&#125;; // 创建Runloop observer对象，监听所有的状态 _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); // 将新建的observer加入到当前thread的runloop CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes); // 创建信号，初识信号量为 0 _semaphore = dispatch_semaphore_create(0); // 子线程监控时长 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 这里的 while 可以改进为创建一个常驻子线程 while (YES) &#123; // dispatch_semaphore_wait： // 如果信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1； // 如果为0，那么这个函数就阻塞当前线程等待 timeout // 如果等待期间信号量被 dispatch_semaphore_signal 加1了那么就继续向下执行并将信号量减1。 // 如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句 // 返回值为 0 则表示在规定时间内等到了 // 返回值不为 0 则代表在规定时间内也没收到信号，超时了 long ret = dispatch_semaphore_wait(self-&gt;_semaphore, dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_MSEC)); if (ret != 0) &#123; if (self-&gt; _lastActivity == kCFRunLoopBeforeSources || self-&gt; _lastActivity == kCFRunLoopAfterWaiting) &#123; NSLog(@&quot;超过 5 秒没有收到信号了&quot;); &#125; &#125; &#125; &#125;);&#125;@end RunLoop实战：实时卡顿监控 关于dispatch_semaphore的使用 滚动时延迟加载图片？（重要）当设置图片的时候，让其在 CFRunLoopDefaultMode 下进行 1[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;imgName&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]]; 上面的代码可以达到如下效果：用户点击屏幕，在主线程中，三秒之后显示图片。但是当用户点击屏幕之后，如果此时用户开始滚动，那么就算过了三秒，图片也不会显示出来，当停止滚动才会显示图片。 这是因为 setImage 只能在 NSDefaultRunLoopMode 模式下使用，当滚动 tableView 的时候，RunLoop 是在 UITrackingRunLoopMode 这个 Mode 下，就不会设置图片，当停止的时候才切回 NSDefaultRunLoopMode 另一个例子，怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作？ 当我们在子请求数据的同时滑动浏览当前页面，如果数据请求成功要切回主线程更新UI，那么就会影响当前正在滑动的体验。我们就可以将更新UI事件放在主线程的 NSDefaultRunLoopMode 上执行即可，这样就会等用户不再滑动页面，主线程 RunLoop 由 UITrackingRunLoopMode 切换到 NSDefaultRunLoopMode 时再去更新UI 1[self performSelectorOnMainThread:@selector(reloadData) withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]]; 但是这里的问题是 modes 不指定的时候，就是 DefaultMode 呀，引用官方文档 This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode) Timer 滚动没回调（重要）NSTimer 在 ScrollView 滚动的时候没有回调，如何解决呢 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 默认都是 Common Mode DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态 当你创建一个 Timer，默认是被加到 DefaultMode，Timer 正常情况下会得到重复回调，但此时滑动一个 ScrollView 时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调。因为 RunLoop 运行时只能指定一个 Mode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。TrackingRunLoopMode 下，处在 DefaultMode 的 Timer 是不会被通知到的 解决方法是将 Timer 加到 CommonModes 中去 123456789101112// 这种创建方法默认不会加到任何 RunLoopNSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(run) userInfo:nil repeats:YES];// 如果这样写，滚动时 NSTimer 不会回调// [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];// 滚动时 NSTimer 会回调// 解决方法 1：添加到 CommonModes[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 解决方法 2：手动添加到 TrackingMode[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];[[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; 也可以使用 GCD 定时器，它不会受 RunLoop 的影响 PerformSelector &amp;&amp; 子线程启动 Timer 失效（重要）当调用 NSObject 的 performSelector:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效 123456dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 如果只写以下一行代码不会生效，本质是生成一个 Timer 添加到 RunLoop [self performSelector:@selector(run) withObject:nil afterDelay:0]; // 必须手动开启 RunLoop Timer 才能生效 [[NSRunLoop currentRunLoop] run];&#125;); 子线程的 RunLoop 默认不开启，必须手动开启 123456789101112131415161718192021dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);// 在子线程中使用定时器dispatch_async(queue, ^&#123; // 第一种方式 // 创建的 timer 已经添加至当前的 runloop 中 [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(doSomething) userInfo:nil repeats:YES]; // 在线程中使用定时器，如果不启动run loop，timer的事件是不会响应的，而子线程中runloop默认没有启动 // 让线程执行一个周期性的任务，如果不启动run loop， 线程跑完就可能被系统释放了 [[NSRunLoop currentRunLoop] run];// 如果没有这句，doSomething将不会执行！！！ /*************************************************************/ // 第二种方式 // 创建的 timer 没有默认添加到 runloop 中 NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(doSomething) userInfo:nil repeats:NO]; // 将定时器添加到runloop中 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; // 在线程中使用定时器，如果不启动run loop，timer的事件是不会响应的，而子线程中runloop默认没有启动 // 让线程执行一个周期性的任务，如果不启动run loop， 线程跑完就可能被系统释放了 [[NSRunLoop currentRunLoop] run];// 如果没有这句，doSomething将不会执行！！！&#125;); 子线程常驻（重要）当我们使用 GCD 的方法创建了子线程，那么当子线程中的任务执行完毕后，子线程就会被销毁掉 如果我们需要经常在子线程中执行此任务，只使用 GCD 会导致线程的频繁创建和销毁，此时我们就需要保证一个子线程的常驻 12345678dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 通过访问 RunLoop 来创建子线程的一个 RunLoop NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环 [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; // 启动 RunLoop [runLoop run];&#125;; 此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息 以下是 AFNetWorking 的 RunLoop 示例代码 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; 深度好文我的脑图 深入理解RunLoop iOS RunLoop详解 RunLoop 源码剖析 关于runloop，好多人都理解错了！ RunLoop 源码","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"RunLoop","slug":"tech/iOS/RunLoop","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/RunLoop/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/Runtime/Runtime/","text":"Runtime 脑图 概念Class、id、objc_object 定义源码 objc_class、objc_method 定义源码 category_t 定义源码 实例对象（objc_object）1typedef struct objc_object *id; id 是一个指向 objc_object 的指针 123456789struct objc_object &#123; isa_t isa;&#125;union isa_t &#123; Class cls; // ... 省略其他&#125; 简单点说，objc_object 中包含了 Class 信息 类对象（objc_class）1typedef struct objc_class *Class; Class 是一个指向 objc_class 的指针 在 Objc2.0 之前，objc_class 源码如下 1234567891011121314151617struct objc_class&#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 然后在 2006 年苹果发布 Objc2.0 之后，objc_class 的定义就变成下面这个样子了 12345struct objc_class : objc_object &#123; Class superclass; cache_t cache; class_data_bits_t bits;&#125; 在 Objc2.0 中，所有的对象都会包含一个isa_t 类型的 isa 指针 objc_class 继承于 objc_object，所以 objc_class 也包含了 isa 指针，故类本身其实也是一个对象，称之为类对象 这意味着，可以像向实例对象发送消息一样，我们可以向类对象发送消息，比如 [Person alloc] class_data_bits_t 存储着类对象的相关数据（比如对象方法、对象成员等等），Objc2.0 之前存储在 objc_class 的信息都放到这里了 当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的class_data_bits_t 中去查找方法实现 但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类的概念 元类 上图可以看出： Superclass 实例对象之间没有父子关系，有父子关系的是类对象和元类 NSObject 类的父类是 nil 特殊：NSObject 元类的父类是 NSObject 类对象 isa 可以理解“是一个” 实例对象“是一个”类对象，类对象“是一个”元类 特殊：任何元类都“是一个” NSObject 元类 【消息发送】：当一个消息发送给任何一个对象时，将会由对象的 isa 指针开始查找方法，接着沿着 superclass 链向上去查找 【内存布局】：不同实例对象对应的类，父类，元类打印出来的地址相同，因为 main 方法执行之前，类对象和元类对象就被创建 理解好对象、类和元类的关系（为什么需要元类）1Person *p = [[Person alloc] init]; 其中，p 是对象，Person 是类。注意，类本身也是对象，所以我们可以把类叫做类对象 对象的实例方法存放在类对象中，对象是以类对象为模版进行创建 而类对象与元类的关系好比对象和类对象的关系，元类中保存了创建类对象以及类方法所需的所有信息 当你给对象发送消息时，消息是从这个对象的类的方法列表中查找 当你给类发消息时，消息是从这个类的元类的方法列表中查找 到此，我们可以理解，为什么类对象“是一个”元类；也可以理解为什么需要元类这个概念（为了和对象查找方法的机制一致） 类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，类对象和元类对象被创建 引申思考：究竟什么样的数据结构才算对象？每个对象都有一个类，这个是 Objective-C 中关于面向对象的内容 实际上，任何数据结构，只要其内存区域的第一块位置是以指向 Class 的指针都可以被称之为对象 比如 objc_object，Objc2.0 前的 objc_class， Objc2.0 后的 objc_class 123456789101112131415161718// isa_t 展开之后struct objc_object &#123; Class isa;&#125;// Objc2.0 前struct objc_class&#123; Class isa; ...&#125;// Objc2.0 后，继承关系展开之后struct objc_class : objc_object &#123; Class isa; Class superclass; ...&#125; 引申思考：类对象是一个对象，那么元类是对象吗？类对象是 objc_class，它的 isa 指针指向的是一个 objc_class，这就意味着元类是一个 objc_class 描述的结构。由于 objc_class 的第一个位置存放着 Class 指针，所以元类本身也是一个对象！所有的元类的 Class 指针指向的都是根元类 即所有元类的类都是根元类，这个是规则。由于这条规则，根元类（即 NSObject 类的元类）的 isa 指针指向了自己，也就是说根元类是它自己的一个实例 引申思考：objc_object 对应对象，objc_class 对应类对象，那是不是会有 objc_meta_class 对应元类id 是一个指向 objc_object 的指针，Class 是一个指向 objc_class 的指针，由此看，id 对应对象，Class 对应类对象确实没错，id 和 Class 都是开发者层面能接触到的，但是元类开发者并不会接触到，所以没有一个对应的“开发层面的概念”对应元类。 元类本身也是一个对象，是用 objc_class 来描述。 即对象用 objc_object 描述；类对象和元类都是用 objc_class 描述 引申思考：为什么所有元类的 isa 指针直接指向了根元类？这是规定（我猜：指向 nil 或其他地方都没有指向根元类合理），同时元类的 isa 指针不是很重要，因为在现实世界中没人向元类发送消息 引申思考：为什么 NSObject 元类的父类是 NSObject 类对象？因为 NSObject 定义了一系列“抽象方法”，这里面既有实例方法，又有类方法 class class isMemberOfClass isKindOfClass respondsToSelector conformsToProtocol conformsToProtocol methodForSelector instanceMethodForSelector 注意：这些方法中的类方法列表是存放在 NSObject 根元类的数据结构中，但是这些方法是“写”在 NSObject.m 中 定义 NSObject 元类的父类为 NSObject 类对象，导致了所有的实例对象、类对象和元类对象都是 NSObject 类对象的实例（除了 NSObject 类对象自己） NSObject 类对象是万物之根 意义在于，元类对象也能调用 NSObject 的实例方法? 如果一个类的类方法没有被实现，最终会去 NSObject 的实例方法中寻找 对于所有的实例对象，都能够调用到 NSObject 的实例方法 对于所有的类对象和元类对象，都能够调用到 NSObject 的类方法 For all instances, classes and meta-classes in the NSObject hierarchy, this means that all NSObject instance methods are valid. For the classes and meta-classes, all NSObject class methods are also valid. ——引自《What is a meta-class in Objective-C?》 Method（objc_method）12345struct objc_method &#123; SEL method_name; // 方法名（区分方法的标识） char *method_types; // 返回值类型 IMP method_imp; // 方法实现&#125; SEL 与 IMP 的关系类似于 key 与 value 的关系 SEL（objc_selector）123456typedef struct objc_selector *SEL;struct objc_selector &#123; char *name; // 方法名称 char *types; // 返回值类型&#125;; SEL 是一个指向 objc_selector 的指针，可以理解为方法（Method）的 ID IMP 可以理解为函数指针，指向了最终的实现 引申思考：关于重载Objective-C 中不支持函数重载就是因为 SEL 只记录了方法名而没有参数，同时一个类的方法列表中不能存在两个相同的 SEL 引申思考：关于重写不同的类可以有同一个 SEL，这些 SEL 对应着不同的实现 不同类的实例对象执行相同的 SEL 时，会在各自的方法列表中去根据 SEL 去寻找自己对应的 IMP 这使得 OC 可以支持函数重写 比如父类和子类都有 viewDidLoad，父类和子类是两个不同的类对象，同时有相同的 SEL，即 viewDidLoad，而其 IMP 又不一样 1@property SEL selector; Objective-C 中的 selector 是 SEL 的一个实例对象 我们可以用 @selector() 返回的是一个 SEL 类型的方法选择器 引申思考：关于声明一个类如果只是声明了方法但是没有实现，其 objc_class 的 methodLists 不会有。声明仅仅只是告诉编译器存在这样一个方法，并不会真正影响 objc_class 里面的内容 另一个角度看，methodLists 里面存的元素是 objc_method，而一个 objc_method 的构成是 SEL 和 IMP，只声明不实现，IMP 不会存在 方法实现（IMP）1typedef id (*IMP)(id, SEL, ...); 关于函数指针 先了解函数指针的概念 typedef 返回类型(*函数指针名)(参数表) 12345678typedef void (*funPointer)(int); funPointer pFun;void myFun(int a)&#123;print(&quot;Hello&quot;);&#125; void main() &#123; pFun = myFun; (*pFun)(2); &#125; 所以 IMP 是一个函数指针，指向类似 id FunName(id, SEL, ...)&#123;...&#125; 的函数实现 在 Runtime 中，IMP 指向着方法最终实现的内存地址 类缓存（objc_cache）Runtime 中，每当找到一个类的方法时，会放入它的缓存，即 objc_class 中的 objc_cache，以加快下次方法调用时的查找效率 分类（objc_category）123456789struct category_t &#123; const char *name; // 原类名，而不是分类名 // 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象 classref_t cls; struct method_list_t *instanceMethods; // 分类中新增的对象方法列表 struct method_list_t *classMethods; // 分类中新增的类方法列表 struct protocol_list_t *protocols; // 分类中新增的协议列表 struct property_list_t *instanceProperties; // 分类中新增的属性列表&#125;; 引申思考：如何在分类中添加属性可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，但不可以添加成员变量 instanceProperties 的存在是我们可以通过 objc_setAssociatedObject 和 objc_getAssociatedObject 向分类中增加实例变量的原因，不过这个和一般的实例变量是不一样的 消息发送（objc_msgSend）一个对象的方法像这样[obj foo]，编译器转成 objc_msgSend(obj, foo) 1id objc_msgSend(id self, SEL op, ...) 以实例方法为例，Runtime 时执行的流程是这样的： 通过 obj 的 isa 指针找到它的类对象（obj 是一个 id，即 objc_object 指针，有 isa 指针） 在类对象的方法列表中寻找 foo（objc_class 的 methodLists） 如果类对象中没到 foo，继续往它的 superclass 中找 一旦找到 foo 这个函数（objc_method），就去执行它的实现 IMP，并转发 IMP 的返回值 如果每次消息传递都沿着继承链，在每个类的 methodLists 查找方法其实效率很低，所以需要缓存，即 objc_class 中的 objc_cache，key 是 objc_method 中的SEL，value 是 objc_method 中的IMP 消息转发（_objc_msgforward）如果消息传递的过程中，沿着继承树查找到最终的根类（NSObject）还是没有对应的方法实现，则会进行消息转发，如果消息转发失败了就回执行 doesNotRecognizeSelector: 方法报unrecognized selector 错 什么是消息转发呢，主要分为以下三个阶段 动态方法解析第一个阶段 Runtime 会调用 +resolveInstanceMethod: 或者 +resolveClassMethod:（取决于是实例方法还是类方法），让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; [self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(foo:)) &#123; // 注意参数 fooMethod 这里是作为一个函数指针传递 class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123; NSLog(@&quot;Hello&quot;);&#125; 快速转发（替换消息接收者）如果你错过了第一阶段，则进入第二阶段。Runtime 会调用 forwardingTargetForSelector 给你把这个消息转发给其他对象的机会 123456789- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(foo)) &#123; return [Person new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 完整消息转发最后一步会发送 -methodSignatureForSelector: 消息获得函数的参数和返回值类型。 如果返回nil ，Runtime 则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了 如果返回了一个函数签名，Runtime 就会创建一个 NSInvocation 对象并发送 -forwardInvocation: 消息给目标对象 123456789101112131415161718192021222324- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;foo&quot;]) &#123; // 返回签名，进入 forwardInvocation return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL sel = anInvocation.selector; Person *p = [Person new]; if ([p respondsToSelector:sel]) &#123; [anInvocation invokeWithTarget:p]; &#125; else &#123; [self doesNotRecognizeSelector:sel]; &#125;&#125; 什么是 &quot;v@:&quot;，详细可参见Type Encodings 所以不同与第二阶段，在这个阶段你可以： 把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。 修改消息的 target，selector，参数等 多次转发这个消息，转发给多个对象 显然在这个阶段，你可以对消息做更多的事情，是第二个阶段的扩充 引申思考：消息转发为什么要三个阶段呢？第一阶段意义在于动态添加方法实现，第二阶段直接把消息转发给其他对象，第三阶段是对第二阶段的扩充，可以实现多次转发，转发给多个对象等 如果只是考虑消息转发的功能，那么只提供最后一个阶段就可以实现，所以这个问题的本质是，为什么要多提供前面两个阶段？ Objective-C 的消息机制与 C++ 等静态编译语言不同，提供动态性的同时必然也牺牲了调用的效率。消息转发的效率必然不如 C++ 的函数调用。 从效率上讲，完整的消息转发效率太低，提供前面两个阶段就是为了让消息能够尽快得到处理；因为三个阶段步骤越往后，处理消息累计开销就越大。 《Objective-C 与 Runtime：为什么是这样？》（R.I.P） Runtime 应用Swizzle Method自定义 KVO 实现给分类添加属性打印类的所有属性值123456789101112131415161718192021222324- (NSString *)description&#123; return [NSString stringWithFormat:@&quot;%@&quot;, [self properties_values]];&#125;- (NSDictionary *)properties_values&#123; NSMutableDictionary *props = [NSMutableDictionary dictionary]; unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList([self class], &amp;outCount); for (i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; const char *char_f = property_getName(property); NSString *propertyName = [NSString stringWithUTF8String:char_f]; id propertyValue = [self valueForKey:propertyName]; if (propertyValue) &#123; [props setObject:propertyValue forKey:propertyName]; &#125; &#125; free(properties); return props;&#125; 可以将 properties_values 方法，写到 NSObject 的分类里，就不需要每个人都写一份 实现 NSCoding 的自动归档和自动解档OC 中归档解档又称为序列化和反序列化 归档/解档需要实现 NSCoding 协议方法，在 NSCoding 协议方法中实现了对每个属性分别进行归档/解档，归档对属性值归档为相应的字段，解档依据相应的字段为对象属性赋值 可以使用 Runtime 的 Ivar *class_copyIvarList 方法获取某个类的属性个数和属性列表。遍历属性列表，可获取每个属性的名字，然后使用 KVC 获取或设置每个属性的值 1234567891011121314151617181920212223242526272829303132333435363738- (void)encodeWithCoder:(NSCoder *)coder&#123; [self code:YES coder:coder];&#125;- (instancetype)initWithCoder:(NSCoder *)coder&#123; if (self = [super init]) &#123; [self code:NO coder:coder]; &#125; return self;&#125;- (void)code:(BOOL)isEncode coder:(NSCoder *)coder&#123; unsigned int outCount = 0; Ivar *ivars = class_copyIvarList([UserModel class], &amp;outCount); for (int i = 0; i &lt; outCount; i++) &#123; Ivar ivar = ivars[i]; const char * name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; id value; if (isEncode) &#123; value = [self valueForKey:key]; [coder encodeObject:value forKey:key]; &#125; else &#123; value = [coder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; &#125; free(ivars);&#125; 实现字典和模型的自动转换（MJExtension）用 Runtime 提供的函数遍历 Model 自身所有属性，如果属性在 json 中有对应的值，则将其赋值 核心方法：在 NSObject 的分类中添加方法 12345678910111213141516171819202122232425262728- (instancetype)initWithDict:(NSDictionary *)dict &#123; if (self = [self init]) &#123; NSMutableArray *keys = [NSMutableArray array]; NSMutableArray *attributes = [NSMutableArray array]; unsigned int outCount; objc_property_t *properties = class_copyPropertyList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = properties[i]; NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [keys addObject:propertyName]; NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; [attributes addObject:propertyAttribute]; &#125; free(properties); for (NSString * key in keys) &#123; if ([dict valueForKey:key] == nil) continue; [self setValue:[dict valueForKey:key] forKey:key]; &#125; &#125; return self;&#125; 热更新（JSPatch）JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法 参考文章 iOS Runtime详解 神经病院 Objective-C Runtime 入院第一天—— isa 和 Class 《What is a meta-class in Objective-C?》","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/Runtime/Runtime_实践/","text":"super 的本质《Objective-C Runtime初探：self super》 123456789101112@interface A : NSObject- (void)f;@end@interface B : A- (void)f;- (void)g;@end@interface C : B- (void)f;@end 1234567891011121314151617181920212223242526272829@implementation A- (void)f&#123; NSLog(@&quot;A&quot;);&#125;@end@implementation B- (void)f&#123; NSLog(@&quot;B&quot;);&#125;- (void)g&#123; [self f]; [super f]; NSLog(@&quot;%@&quot;, [self class]); NSLog(@&quot;%@&quot;, [super class]);&#125;@end@implementation C- (void)f&#123; NSLog(@&quot;C&quot;);&#125;@end 请问，下面代码输出什么？ 12C *c = [[C alloc] init];[c g]; 答案：CACC NSObject 分类的 -test 与 Person 的无实现 +test问：假如 Person 类声明了 + (void)test 方法，但是没实现，而 NSObject 的分类实现了 - (void)test 方法；此时调用 Person 的 test 类方法，会发生什么事？ 1234567891011121314// Person.h@interface Person : NSObject+ (void)test; // 没有实现@end// NSObject+Runtime.m@implementation NSObject (Runtime)- (void)test&#123; NSLog(@&quot;NSObject&#x27;s test&quot;);&#125;@end[[Person class] test]; // 会发生什么？ 答：虽然 Person 没有实现这个类方法，但是最终会调用 NSObject 的 test 实例方法。 对于类方法，消息发送从 Person 类的 isa 指针指向的元类开始查找方法，沿着继承链向上查找，最终找到 NSObject 元类，找不到，继续查找 NSObject 的类对象，最终发现了 test 方法，进而进行调用 本题的考点是： NSObject 元类的父类就是 NSObject 类对象 查找方法的 Key 是 @selector，并不包括其是实例方法还是类方法；或者说实例方法和类方法的区别就在于查找的继承链，而不在于方法本身 Runtime 怎么添加属性、方法12345class_addIvar // 添加成员变量class_addMethod // 添加方法class_addProperty // 添加属性class_addProtocol // 添加协议class_replaceProperty // 替换属性 需要注意的是，成员变量和属性的区别，详见 方法交换 为什么 Category 中不能动态添加成员变量因为 category_t 的结构中没有含有成员变量的字段，但是含有属性相关的字段，因此虽然无法动态添加成员变量，但是可以动态添加属性 详见：如何为分类添加属性 能否在分类中增加属性不能添加成员变量；不能直接添加属性，但是可以通过 Runtime 的方法添加 因为方法和属性并不“属于”类实例，而成员变量“属于”类实例 因为 Category 在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。 详见：如何为分类添加属性 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？不能向编译后得到的类中增加实例变量；能向运行时创建的类中添加实例变量； 添加实例变量会影响类结构体中的 objc_ivar_list 和 instance_size 因为编译后的类已经注册在 Runtime 中，类结构体中的 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定，同时 Runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用，所以不能向存在的类中添加实例变量 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数，但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。 类和分类的同名方法 如果分类中有和原有类同名的方法, 会优先调用分类中的方法，即 分类 &gt; 原类 如果多个分类中都有和原类同名的方法, 那么各个分类的方法调用顺序由编译器决定，即 分类1 or 分类2 &gt; 原类 分类和扩展的区别 扩展我们天天使用，既可以添加 @property（一般用来声明私有变量），也可以添加方法（但是没必要） 分类只能添加方法，正确添加 @property 需要用 Runtime 的方法 类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中 项目中用过 Runtime 吗项目中用过的： Swizzle Method（API 安全性保护，防止崩溃；AOP，VideoReport 的埋点上报、日志） 给分类添加属性（给系统的类添加属性，如 VN 中为 UIView 添加 Cell 信息） 打印类的所有属性值 自己没用过但是知道的： Runtime 如何实现自定义 KVO Runtime 如何实现 weak 属性 实现 NSCoding 的自动归档和自动解档 简单描述下 Runtime 的消息机制分为两个阶段：消息发送和消息转发 消息发送： 当调用实例方法时：通过 isa 指针找到实例对应的类对象，并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy) 当调用类方法时：通过 isa 指针找到类对象对应的元类并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy) 如果没有找到对应的 IMP，则进入消息转发流程： 动态方法解析（+resolveInstanceMethod: 或者 +resolveClassMethod:），动态添加方法实现的机会 快速转发（替换消息接收者）（-forwardingTargetForSelector:），替换消息的接收者为其他对象的机会 完整消息转发（-methodSignatureForSelector: &amp;&amp; -forwardInvocation:），可以实现多次转发，转发给多个对象，是第二阶段的扩充 _objc_msgForward 是什么，直接调用它将会发生什么？ _objc_msgForward 是 IMP 类型，当向一个对象发送一条消息，会调用 methodForSelector 方法，但它并没有实现的时候，该方法会返回该 IMP，即 _objc_msgForward，这个 IMP 用于执行消息转发 直接调用会进入消息转发的三个流程 工作遇到的例子1234567SEL commonReceiveSEL = @selector(didReceiveBaseEvent:);if ([myDelegate respondsToSelector:commonReceiveSEL])&#123; void (*commonEventIMP)(id, SEL, id) = (void (*)(id, SEL, id))[self methodForSelector:]; commonReceiveIMP(myDelegate, commonReceiveSEL, nil);&#125; 这个例子中，self 没有实现这个 didReceiveBaseEvent:，应该把 self 改为 myDelegate 但是执行 commonReceiveIMP 时，居然 myDelegate 的方法被正确调用了，正常情况应该是抛错误：doesNotRecognizeSelector: methodForSelector 返回的是方法的 IMP，如果找不到该 IMP，则会返回 _objc_msgforward 这个 IMP _objc_msgforward 调用之后会进入 Runtime 的消息转发流程 项目中有一个 SDK hook 了消息转发流程的第三个阶段，即 methodSignatureForSelector 和 forwardInvocation:，使得 commonReceiveSEL 转发给了 myDelegate 当把这个 SDK 移除之后，果然就抛了 doesNotRecognizeSelector: 的错误 Runtime 如何实现 weak 属性weak 的实现原理 isKindOfClass、isMemberOfClassRuntime 源码 12345678910111213141516// isKindOf 和 isMemberOf 的基本用法和区别Person *person = [[Person alloc] init];BOOL res1 = [person isKindOfClass:[Person class]]; // YESBOOL res2 = [person isMemberOfClass:[Person class]]; // YESBOOL res3 = [person isKindOfClass:[NSObject class]]; // YESBOOL res4 = [person isMemberOfClass:[NSObject class]]; // NO// 由于类也是对象，所以 res5 和 res6BOOL res5 = [[Person class] isKindOfClass:[NSObject class]]; // YESBOOL res6 = [[Person class] isMemberOfClass:[NSObject class]]; // NOBOOL res7 = [[NSObject class] isKindOfClass:[NSObject class]]; // YESBOOL res8 = [[NSObject class] isMemberOfClass:[NSObject class]];// NOBOOL res9 = [[Person class] isKindOfClass:[Person class]]; // NOBOOL res10 = [[Person class] isMemberOfClass:[Person class]]; // NO 其中 res1-res4 展示了 isKindOf 和 isMemberOf 的基本用法和区别；res5、res6 展示了调用者是类对象时也是同理 按照我们的理解，isKindOf/isMemberOf 的调用者是实例对象时，参数应该是类对象；调用者是类对象时，参数应该是元类才比较合理 所以 res7 的输出有点奇怪，而 res8 和 res10 的输出也正常，然而 res9 却和 res7 不一致 我们看下源码 123456789101112131415161718192021222324252627282930313233// 实例方法中的 self 是对象，[self class] 取得的是类对象，所以 cls 只有可能是类对象才有可能相等- (BOOL)isMemberOfClass:(Class)cls&#123; return [self class] == cls;&#125;// 类方法中的 self 是类对象，object_getClass 取得的是类对象的isa指针指向的对象，也就是元类对象，所以 cls 只有是元类对象才有可能相等+ (BOOL)isMemberOfClass:(Class)cls&#123; return object_getClass((id)self) == cls;&#125;// 实例方法中的 self 是对象，[self class] 取得的是类对象// 从当前的类对象开始，向其父类方向查找，直到找到相等或尽头- (BOOL)isKindOfClass:(Class)cls&#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;// 类方法中的 self 是类对象，object_getClass 取得的是类对象的isa指针指向的对象，也就是元类对象// 从当前的元类对象开始，向其父类方向查找，直到找到相等或尽头+ (BOOL)isKindOfClass:(Class)cls&#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 关于 res7，当调用者是 [NSObject class] 时，调用的是 + (BOOL)isKindOfClass:(Class)cls；self 是 NSObject 的类对象，object_getClass 返回的是 NSObject 元类，而传入的 cls 是 NSObject 类对象。 第一次判断的时候，比较的对象是 NSObject 元类和 NSObject 类对象，不相等； 第二次判断的时候，取 NSObject 元类的父类，即 NSObject 类对象，与 cls 比较，相等，返回 YES 关于 res9，第一次比较的对象 Person 元类与 Person 类对象；第二次比较的是 NSObject 元类与 Person 类对象；第三次比较的是 NSObject 类对象与 Person 类对象；结束，返回 NO 关于 res8，当调用者是 [NSObject class] 时，调用的是 + (BOOL)isMemberOfClass:(Class)cls；self 是 NSObject 的类对象，object_getClass 返回的是 NSObject 元类，而传入的 cls 是 NSObject 类对象。不相等，返回 NO res10 与 res8 同理","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.954Z","path":"tech/iOS/Runtime/iOS 的 initialize 和 load 区别/","text":"load initialize 执行次数 1次 每个类会被系统只调用一次，但是由于继承的关系，子类未实现的情况下父类的方法会被多次调用 执行时机 所有运行时需要用到的类在main函数开始执行之前，与这个类是否被用到无关 懒加载，需要使用到具体类的时候才调用 （类或它的子类收到第一条消息之前被调用的，包括实例方法和类方法，如果没收到消息则永远不会调用） 作用 Runtime 交换方法 初始化全局 oc 对象 （普通对象可以在声明的时候初始化） 执行时环境 系统不稳定，许多东西尚未初始化，调用的时候其它类不一定准备好 系统处于正常状态，其他类的方法都能正常调用 （特殊情况：如果在 load 方法调用该类的方法会导致 initalize 提前调用，这种情况系统并不稳定） 调用顺序 1. 顺序：父类-&gt;本类-&gt;分类 2. 分类不会影响本类，分类之间的 load 顺序无法确定 3. 本类没写，系统在加载本类的时候不会调用其父类 4. 不同的类或者分类之间的顺序是按 Compile Sources 来确定 1. 顺序：父类-&gt;本类-&gt;分类 2. 分类的实现会覆盖本类 3. 本类没写，会自动调用父类，所以需要先判断类名 相同点 1. 代码要精简，避免处理复杂逻辑 2 线程安全，不必加锁 3. 开发者不能显式调用，也不能调用 super 4. 最好不要调用其他类的方法 同左 load 中最好不要调用其他类的方法，是因为调用的时候其他类不一定加载好 initialize 中最好不要调用其他类的方法，是因为如果这样做，可能产生循环依赖，比如 A 的 initialize 调用了 B 的方法，导致 B 的 initialize 被调用，而 B 的 initialize 也调用了 A 的方法，此时会有问题（而现实情况的互相依赖可能涉及多个类，一旦出现问题就难以定位） load父类的 load 优先于子类12345678910111213static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED);&#125; 可以看到，对 cls 的处理过程中，优先递归处理了父类，因此父类的 load 一定比子类的优先调用 本类的 load 优先于分类1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static BOOL loading = NO; BOOL more_categories; recursive_mutex_assert_locked(&amp;loadMethodLock); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&#x27;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 其中 call_class_loads 是调用本类的 load，而 call_category_loads 是调用分类的 load 系统加载本类的时候为什么不会调用父类这里有一点值得探讨：本类没写，系统在加载本类的时候不会调用其父类 探讨这个问题的前提是，父类的 load 方法是存在的，假如没有实现，讨论调用时机是没有意义的 这里可能会误解为，本类没写，其父类的 load 也不会被调用。加载子类的时候，如果子类没有实现 load 方法，那么系统是不会在此时自动调用父类的 load，因为 load 调用是直接获取函数指针来执行，不会像 objc_msgSend 一样会有方法查找的过程，也就不会沿着继承链往上寻找了。但是这个不意味着父类的 load 方法不会被调用，因为父类也是需要被加载的，所以 load 方法也会被调用，所以这里强调的是时机，本类没有写 load 的情况下，系统加载本类的时候不会调用其父类的 load 123456789101112131415161718192021222324static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; // 这里取到的就是 load 方法 load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) _free_internal(classes);&#125; (*load_method)(cls, SEL_load); 说明，load 方法不是通过 objc_msgSend 调用，而是直接通过函数指针调用，因此不会在此次调用中调用父类实现 initializeinitialize 的正确写法（重要！！！不然有子类的情况下可能会调用多次）假设我想要在 A 的 initialize 方法中打印出自己，如果这样写： 12345678910111213@interface A : NSObject@end@implementation A+ (void)initialize&#123; NSLog(@&quot;%@&quot;, self);&#125;@end@interface B : A@end@implementation B@end 此时创建一个B对象，输出是 AB 初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B 所以 A 的 initialize 方法应该这样写 1234567+ (void)initialize&#123; if (self == [A class]) &#123; NSLog(@&quot;%@&quot;, self); &#125;&#125; 此时创建一个B对象，输出是 B initialize 的调用顺序以下关键代码来自 objc-runtime-new.mm，当我们给某个类发送消息时，Runtime 会调用该函数。当类没有初始化会调用 void _class_initialize(Class cls) 对该类进行初始化 123456789101112IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; // 省略部分代码 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; // 省略部分代码 _class_initialize(_class_getNonMetaClass(cls, inst)); // 省略部分代码 &#125; // 省略部分代码&#125; _class_initialize 关键代码如下 可以看到优先递归处理了父类，因此父类的 initialize 一定优先于子类 除此之外，从 ((void (*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); 看到，本类的 initialize 是通过 objc_msgSend 进行调用，与普通方法的调用是一样的，如果子类没有实现，那么父类的实现会被调用；如果一个类的分类实现了 initialize 方法，那么就会对这个类中的实现造成覆盖 12345678910111213141516171819202122232425void _class_initialize(Class cls)&#123; // 省略部分代码 Class supercls; BOOL reallyInitialize = NO; supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls); &#125; if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123; cls-&gt;setInitializing(); reallyInitialize = YES; &#125; if (reallyInitialize) &#123; // 省略部分代码 ((void (*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); // 省略部分代码 &#125; // 省略部分代码&#125; 题目实战Compile Sources 中有以下类，顺序如下 12345678910Daughter.mOther.mFather+Category_2.mSon+Category.mSon.mmain.mOther+Category.mFather+Category_1.mFather.mAppdelegate.m 顾名思义，Father 有是 Son 和 Daughter 的父类，Other 与他们没有继承关系 其中除了 Daughter，其他类都写了 load 方法和 initialize 方法，如下 1234567891011121314151617181920+ (void)load&#123; NSLog(@&quot;%s %@&quot;, __FUNCTION__, [self class]);&#125;+ (void)initialize&#123; NSLog(@&quot;%s %@&quot;, __FUNCTION__, [self class]);&#125;// main.mint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Main 函数开始执行&quot;); Daughter *daugter = [[Daughter alloc] init]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 输出结果如下： 123456789101112+[Other(Category) initialize] Other+[Other load] Other+[Father(Category_1) initialize] Father+[Father load] Father+[Son(Category) initialize] Son+[Son load] Son+[Father(Category_2) load] Father+[Son(Category) load] Son+[Other(Category) load] Other+[Father(Category_1) load] FatherMain 函数开始执行+[Father(Category_1) initialize] Daughter 类的加载顺序由 Compile Sources 确定，即 Daughter &gt; Other &gt; Son &gt; Father，分类的加载是另外一个时机 第一个加载的类是 Daughter，由于没有实现 load，所以没有任何关于 Daughter 的输出，同时也可以看出，一个类没有实现 load，加载它时不会调用父类的 load 第二个加载的类是 Other，由于在其 load 的中向本类发送了消息，所以导致 initialzie 先于 load 被调用，可以看出，initialize 调用的时机不是在 main 函数之后，而是在向该类发送第一个消息之前；第一行输出是 Other 分类的 initialize 方法， Other 自己的 intialize 永远没机会被调用，是因为分类的 innitialize 会覆盖本类 第三个加载的类是 Son，加载 Son 的时候会优先加载 Father，说明子类的 load 一定是晚于父类；同 Other，Father 优先输出了分类的 initialize，再输出 load，那为什么是 Category_1 而不是 Category_2 的 initialze 呢，因为 Category_2 在 Compile Sources 中是晚于 Category_1，因此覆盖了本类和 Category_1 的方法。即分类的 initialzie 覆盖本类时，以 Compile Sources 中最后一个分类为准 接下来终于轮到 Son 自己加载了，可以看到 Son+Category 的 load 的方法并没有在此时执行，说明分类的 load 确实晚于主类 最后一个要加载的主类是 Father，而由于 Father 刚刚已经加载过了，因此不会再次调用 load 方法，说明一个类的 load 方法系统最多只会调用一次 主类加载完之后，终于轮到分类了，分类的加载顺序取决于其在 Compile Sources 的顺序，而与它们的主类在 Complie Sources 的顺序无关，本例中 Father(Category_2) &gt; Son(Category) &gt; Other(Category) &gt; Father(Category_1) 主类分类加载完毕，开始执行 main 函数。说明类的 load 都是在 main 函数之前 最后在 main 函数中向 Daughter 发送了一个消息，从而触发了 Daughter 的 initialize，可以看出 initialize 是懒加载的；其次，本类没实现 initialize 的时候，系统会自动调用父类的实现 延伸思考为什么分类的 load 方法不会被覆盖本类，而 innitialize 会呢因为 load 的时候 Runtime 还没有初始化完毕；load 的调用是直接函数调用，而 initialize 是属于消息发送，需要依赖 Runtime 分类实现的普通方法，是如何覆盖本类的为什么方法交换要写在 load我们可以从 load 的特点得到： 方法交换调用一次就够了，而 load 只会被系统调用一次 方法交换越早越好，而 load 方法在 main 函数之前就被调用了 但是有这两个原因仍然不足以说明为什么要写在 load，因为 initialize 方法也可以做到一次和越早越好 那么 load 为什么比 initialize 更适合呢，答案是不会有被覆盖的风险，写了就一定会被调用到 写在主类的 initialize 的方法可能被其分类的 initialize 覆盖，而 load 不会 为什么方法交换需要加 dispatch_once，不是说 load 只会执行一次吗load 是线程安全的，最多也被系统调用一次，添加 dispatch_once 完全是为了防止不合格的程序员手动调用 多次交换会有什么问题1234567891011121314151617181920212223242526272829// UIViewController+Category1.m+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzleMethod(self, @selector(viewWillAppear), @selector(viewWillAppear_1)); &#125;);&#125;- (void)viewWillAppear_1:(BOOL)animated&#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [self viewWillAppear_1:animated];&#125;// UIViewController+Category2.m+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzleMethod(self, @selector(viewWillAppear), @selector(viewWillAppear_2)); &#125;);&#125;- (void)viewWillAppear_2:(BOOL)animated&#123; NSLog(@&quot;%s&quot;, __FUNCTION__); [self viewWillAppear_2:animated];&#125; 假如 UIViewController+Category1 的 load 比 UIViewController+Category2 先执行，那么执行此时所有的 UIViewController 即将出现的时候将会调用哪些方法 答案：调用顺序如下 123viewWillAppear_2viewWillAppear_1viewWillAppear 交换之前 123@selector(viewWillAppear) -&gt; viewWillAppear&#x27;s IMP@selector(viewWillAppear_1) -&gt; viewWillAppear_1&#x27;s IMP@selector(viewWillAppear_2) -&gt; viewWillAppear_2&#x27;s IMP 第一次交换：UIViewController+Category1 的 load 123@selector(viewWillAppear) -&gt; viewWillAppear_1&#x27;s IMP@selector(viewWillAppear_1) -&gt; viewWillAppear&#x27;s IMP@selector(viewWillAppear_2) -&gt; viewWillAppear_2&#x27;s IMP 第二次交换：UIViewController+Category2 的 load 123@selector(viewWillAppear) -&gt; viewWillAppear_2&#x27;s IMP@selector(viewWillAppear_1) -&gt; viewWillAppear&#x27;s IMP@selector(viewWillAppear_2) -&gt; viewWillAppear_1&#x27;s IMP 调用 viewWillAppear，执行的是其对应的 IMP， 即 viewWillAppear_2 然后 viewWillAppear_2 的 IMP 里又调用了 @selector(viewWillAppear_2) ，执行的是 viewWillAppear_1 的 IMP 最后 viewWillAppear_1 的 IMP 里又调用了 @selector(viewWillAppear_1) ，执行的是 viewWillAppear 的 IMP load 方法中实现方法交换的时候采用 c 函数swizzleMethod 采用 C 函数，而不是 NSObject 的方法，是为了防止子类在 load 方法中向其自己发送消息，那样会导致其 +initialize 方法在 load 的时候被提前调用，而此时系统环境是不稳定的 参考文章 《Objective-C +load vs +initialize》 《一道题搞清楚Objective-C中load和initialize》 《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法》第 51 条","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Runtime","slug":"tech/iOS/Runtime","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/fork后与原仓库同步SOP/","text":"进入到本地仓库的目录，并切换到你关心的分支 执行 git remote -v 查看 upstream 的设置，正常情况下应该是只有你自己的远程仓库地址 12origin git@github.com:Norcy/react-native.git (fetch)origin git@github.com:Norcy/react-native.git (push) 添加被 fork 的原仓库地址 git remote add upstream @git/origin.git，再次执行 git remote -v 1234origin git@github.com:Norcy/react-native.git (fetch)origin git@github.com:Norcy/react-native.git (push)upstream git@origin.git (fetch)upstream git@origin.git (push) 抓取原仓库的改动，git fetch upstream 确保已经切到你关心的分支，比如 master；执行合并 git merge upstream/master push 新提交到你的仓库，git push 有时候也需要推送 Tags，git push --tags 清除 upstream 信息，等下次需要再设置，git remote remove upstream，清除后查看 git remote -v 12origin git@github.com:Norcy/react-native.git (fetch)origin git@github.com:Norcy/react-native.git (push) 参考：https://github.com/selfteaching/the-craft-of-selfteaching/issues/67","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/如何为 Github 设置代理/","text":"如果 Git 拉取很慢，可能是因为 Git 没有设置代理，出现以下报错1fatal: unable to access &#x27;https://github.com/ohmyzsh/ohmyzsh.git/&#x27;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 or 123kex_exchange_identification: read: Connection reset by peerConnection reset by 20.205.243.166 port 22fatal: Could not read from remote repository. 原因Git 默认不走翻墙协议，需要为 Git 配置下翻墙，方法如下 方法编辑 ~/.ssh/config，如果没有则新增 123Host github.com User git ProxyCommand nc -x 127.0.0.1:7891 %h %p 其中端口号需要根据你本地翻墙工具的端口号来修改 参考：https://ericclose.github.io/git-proxy-config.html 再次出错12kex_exchange_identification: Connection closed by remote hostConnection closed by UNKNOWN port 65535 方法123Host github.com Hostname ssh.github.com Port 443 命令行输入 1ssh -T -p 443 git@ssh.github.com 提示成功即可","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/如何完整迁移 Git 仓库/","text":"直接 Push 行不行123git clone https://github.com/username/old-repository.gitcd old-repository.gitgit push --all https://github.com/username/new-repository.git 上面做法的问题在于只能把本地存在的分支推送新仓库，丢失了所有 tag 和其他分支 其实 git 在 push 时会自动填充填充缺省参数，比如命令完整命令应该是下面这样 123456# 简写git push# 实际是自动填充源 origin 以及当前分支 branchgit push origin branch# git在push时除了自动填充参数，还会自动展开分支，上面的命令展开后如下git push origin refs/heads/branch:refs/heads/branch 查看下.git 下的 refs 目录，就会发现 git 会把远端的分支存放在 remotes 目录 那我们可以用下面的命令进行仓库迁移 1git push remote2 refs/remotes/origin/*:refs/heads/* 但这样做还有个问题不能解决，就是tag引用还是丢失了 方法123456# 在本地使用 bare 仓库克隆老仓库git clone --bare https://github.com/username/old-repository.git# 进入老仓库cd old-repository.git# 将 bare 仓库推送到新的目标仓库。git push --mirror https://github.com/username/new-repository.git 原理这种方法的原理是先使用 bare 克隆老仓库，这样会得到一个不包含工作区的 Git 仓库，所有的二进制数据、标签、分支、扩展属性、Git 配置信息、钩子等都将被复制到克隆出的 bare 仓库中。然后将克隆出的 bare 仓库推送到新的目标仓库中，由于使用了 --mirror 参数，所有的分支都会被完整地推送到目标仓库中。最终得到的新仓库与老仓库没有任何关系，但是包含老仓库的所有历史记录信息和元数据。 push --mirror 命令是 Git 提供的一种高级推送功能，它能够将一个 Git 仓库的完整状态（包括所有分支、标签、数据和元数据等）推送到另一个 Git 仓库中，从而实现仓库镜像的快速部署和备份。 具体来说，push --mirror 命令的原理如下：将本地分支推送到远程分支。--mirror 参数的作用是将本地所有分支、标签等推送到远程仓库中。同步远程分支后，Git 远程仓库中的分支、标签等都会与本地完全一致。因为 bare 已经把远程所有元信息都拉下来了，所以 mirror 推送的本地信息是完整的","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"查找日志技巧","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/查找日志技巧/","text":"将文本中带有 viewWillAppear 的所有行打印出来1cat test.log | grep -n -i &#x27;viewWillAppear&#x27; &gt; result.log 其中，-n:显示行号；-i 忽略大小写 将文本中带有 QLASIHTTPRequest 的所有行过滤掉1sed &#x27;/QLASIHTTPRequest/d&#x27; test.log &gt; result.log /QLASIHTTPRequest/d 表示对所有匹配到 QLASIHTTPRequest 的行执行 delete 命令 关于 sed 的更多用法，见 SED 简明教程 使用正则表达式查找 C++ 所有的复制构造函数以 QVNContext::QVNContext(const QVNContext &amp;context) 为例 1(.+)::\\1\\(.*\\1\\s.*","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"知识碎片","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/知识碎片/","text":"Tree命令行下展示目录结构的神器——tree，使用 brew install tree 来安装 使用 ll 作为 ls -l 的别名123456cd ~touch .bash_profileecho &quot;alias l=&#x27;ls -alhF&#x27;&quot; &gt;&gt;.bash_profileecho &quot;alias la=&#x27;ls -AFh&#x27;&quot; &gt;&gt;.bash_profileecho &quot;alias ll=&#x27;ls -lhAF&#x27;&quot; &gt;&gt;.bash_profilesource ~/.bash_profile 如何优雅地使用 KVO 如何优雅地使用 KVO Facebook/KVOController 使用 __kindof如果以下代码不加 __kindof 就会产生 Warning 1234567NSMutableArray&lt;__kindof UIView *&gt; *subviews = @[].mutableCopy;[subviews addObject:[[UIView alloc] init]]; // Works[subviews addObject:[[UIImageView alloc] init]]; // Also works UIView *sameView = subviews[0]; // No problemUIImageView *sameImageView = subviews[1]; // No complaints now! 预览 Github 的 html在 html 的源地址前面添加 http://htmlpreview.github.io/? 即可 return 前执行12#define OnExit \\__strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^ 尾调用优化 尾调用优化 iOS objc_msgSend尾调用优化机制详解 iOS Bug 定位 .dSYM + .app + .crash 的 UUID 必须一致 查看 app 的 UUID dwarfdump –uuid XXX.app/XXX https://www.cnblogs.com/ningxu-ios/p/4141783.html","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"新建工程移除StroyBoard","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/Xcode/新建工程移除StroyBoard/","text":"移除 Main.storyboard 文件 移除 LaunchScreen.storyboard 在 TARGETS 中，将 Main InInterface 选项中的值清空 AppDelegate.m 替换以下函数，并 #import &quot;ViewController.h&quot; 123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; ViewController *viewController = [[ViewController alloc] init]; self.window.rootViewController = viewController; self.window.backgroundColor = [UIColor whiteColor]; [self.window makeKeyAndVisible]; return YES;&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"}]},{"title":"Git","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/计算机基础/Git/","text":"Tag列出本地 Taggit tag 本地添加 Taggit tag v1.0.0 删除本地 Taggit tag -d v1.0.0 把本地 Tag 推送到远程git push --tags 删除远程 Taggit push origin -d tag 0.0.2 远程 Tag 删除，本地还在12git tag -l | xargs git tag -dgit fetch --tags 重命名远程 Tag1234git tag new oldgit tag -d oldgit push origin :refs/tags/oldgit push --tags 分支删除本地分支gbd &lt;branchName&gt; 删除远程分支gbdr &lt;branchName&gt; 即 git push origin --delete &lt;branchName&gt; History一个 Log 只占一行，用于快速浏览1git log --pretty=oneline 展示某个提交的具体细节1git show ace518d5172459d95cad6a21efe2ac6068011f2d 修改最后一次 Commit 信息1git commit --amend 撤销撤销所有文件的 add 操作123grh # 推荐使用别名# 或者git reset HEAD 撤销某个文件的 add 操作123grh model # 推荐使用别名# 或者git reset HEAD modal/a.ts 注意：如果该目录下只有这个文件，那么可以只传目录名 撤销所有文件的修改（无论是否 add）123grhh # 推荐使用别名# 或者git reset HEAD -- hard 撤销单个文件的修改（无论是否 add）1234grhh model # 推荐使用别名# 或者git reset HEAD modelgit restore model 注意：如果该目录下只有这个文件，那么可以只传目录名 其中别名的定义为 12345678grhf() &#123; targetFile=&quot;.&quot; if [ $# -gt 0 ] ; then targetFile=$* fi grh &quot;$targetFile&quot; g restore &quot;$targetFile&quot;&#125; git stauts 中文乱码1git config --global core.quotepath false","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"计算机基础","slug":"tech/Others/计算机基础","permalink":"https://norcy.github.io/wiki/categories/tech/Others/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/计算机基础/RESTful API/","text":"什么是 RESTREST：REpresentational State Transfer，直译就是 “表现层状态转移” 通俗地讲就是，URL 定位资源，用 HTTP 动词（GET,POST,PUT,DELETE）描述操作 Resource：资源，即数据 Representational：某种表现形式，比如用 JSON，XML，JPEG 等 State Transfer：状态变化。通过 HTTP 动词实现 REST 本身不实用，实用的是如何设计 RESTful API 什么是 RESTful APIRESTful API 就是 REST 风格的 API，它使用一套协议来规范多种形式的前端和同一个后台的交互方式 RESTful 是基于 HTTP 协议，设计原则如下： 对资源的操作。资源就是一段文本、一张图片或一段视频。资源总是要通过一种载体来反应它的内容，比如文本用 txt，图片用 png 或 jpg，而 JSON 是现在最常用的资源表现形式 使用 HTTP 动词来实现增删改查。RESTful API 对资源的 CRUD（create,read,update,delete）分别对应 HTTP 的方法：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源 使用 URI（统一资源定位符）。每个 URI 都对应一个特定的资源，最典型的 URI 就是 URL。每个网址代表一种资源，所以网址中不能有动词，只能有名词 无状态。所有的资源都可以 URI 定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化。比如查询工资的接口必须在员工请求登录接口之后才能查询，它就不属于无状态的 其他规范： 将 API 的版本号放入 URL，比如 https://api.example.com/v1/ 一般 API 中的名字都使用复数 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/posts For ExampleGET:http://api.example.com/posts/123 表示获取 ID 为 123 的帖子 GET:http://api.example.com/posts 表示获取所有帖子列表 DELETE:http://api.example.com/posts/123 则为对应的删除操作 错误的示例：http://api.example.com/getPosts/123 or http://api.example.com/getPosts/123，这里网址中有了动词，并不是通过 HTTP 动词来实现增删改查 参考文章 《什么是 RESTful API？》 《RESTful API 设计指南》","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"计算机基础","slug":"tech/Others/计算机基础","permalink":"https://norcy.github.io/wiki/categories/tech/Others/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/计算机基础/原码, 反码, 补码/","text":"在 32 位机器上，int 的范围是 [-2^31, 2^31-1]，为什么正数和负数的范围不对称？ 一、机器数和真值在学习原码，反码和补码之前，需要先了解机器数和真值的概念 机器数机器数：一个数在计算机中的二进制表示形式。其最高位存放符号，正数为0，负数为1 比如 -3 的机器数就是 10000011 真值第一位是符号位，真值就是将符号考虑进去进行计算的值。 比如：1000 0001 的真值是 -1，而不是 129 二、原码，反码，补码的基础概念和计算方法在探求为何机器要使用补码之前，让我们先了解原码，反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式 原码原码就是用第一位表示符号，其余位表示值 12[+1]原 = 0000 0001[-1]原 = 1000 0001 反码 正数的反码是其本身 负数的反码是在其原码的基础上，符号位不变，其余各个位取反 12[+1]反 = 0000 0001[-1]反 = 1111 1110 补码 正数的补码就是其本身 负数的补码是在反码的基础上+1 1234[+1]补 = 0000 0001[-1]补 = 1111 1111[0] 补 = 0000 0000[-8]补 = 1000 0000 三、为何要使用原码，反码和补码对于正数三种编码方式的结果都相同 [+1] = [00000001]原 = [00000001]反 = [00000001]补 但是对于负数: [-1] = [10000001]原 = [11111110]反 = [11111111]补 原码是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢? 由于计算机识别符号位会变复杂，因此计算时使用加法替代减法 如果用原码表示，对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数 11 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 为了能够使正负相加得 0，出现了反码： 11 - 1 = 1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法，结果的真值部分是正确的，却会出现 +0 和 -0 虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的。而且会有[0000 0000]原和[1000 0000]原两个编码表示0 我们希望只有一个 0，所以发明了补码 之前相加会得到各个位都是 1，所以规定补码为在反码的基础上 +1，这样相加之后每个 1 都会变成 0，多出的进位直接抛弃 11 - 1 = 1 + (-1) = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用 [0000 0000] 表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128: 1(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 使用补码，不仅仅修复了0的符号，而且还能够多表示一个最小值 这就是为什么8位机器下，使用原码或反码表示的范围为[-127,+127]，而使用补码表示的范围为[-128,127] 因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是: [-2^31,2^31-1] 因为第一位表示的是符号位。而使用补码表示时又可以多保存一个最小值 四、补码是怎么来的同余首先介绍一个数学中相关的概念: 同余 两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余 记作 a ≡ b (mod m) 读作 a 与 b 关于模 m 同余 举例说明: 1234 mod 12 = 416 mod 12 = 428 mod 12 = 4 所以4，16，28关于模 12 同余 负数取模加上 mod 右边的数的倍数即可 12-3 mod 2 = (-3+2*2) mod 2 = 1-2 mod 12 = (-2+12) mod 12 = 10 补码与取模如果当前时间是6点，我希望将时间设置成4点，我们可以: 往回拨2个小时: 6 - 2 = 4 往前拨10个小时: (6 + 10) mod 12 = 4 在这个例子中，我们忽略了钟表是否多转了一圈，只考虑了当前时间点对不对，实际上就是只考虑对 12 个小时取余的结果对不对 -2 被我们看成是 +10，因为 -2 和 +10 是关于模 12 同余 同理，在补码的计算中，在 n 位机器上，补码与原码是关于模 2^(n-1) 同余 以 8 位为例，负数的补码与原码相加得到 1000 0000，即 128，这个 128 就好比钟表的 12 个小时 我们首先忽略符号位，只考虑剩下7位的值对不对。比如加 -1 和加 +127 就是等价的 2-1 = 2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]补 + [1111 1111]补 忽略符号位，-1 的原码是 000 0001，好比向前拨 2 个小时；补码是 111 1111，好比向后拨 10 个小时 那么， 2 + (-1) 与 2 + (127) 在 7 位比特位中的值一定是一样的。我们忽略了溢出，只考虑了对 111 1111 取余；正如我们忽略钟表多转一圈还是少转一圈，只考虑了对 12 个小时取余 符号位在补码和取模的讨论中，包括钟表的例子，我们都只看了余数，而回避了符号位的问题，现在着重看下符号位的计算 我们知道，在补码中，正数的符号位是 0，负数是 1 正数和正数、负数和负数相加可能会有溢出问题，比如 127+1，-127-1，此时的符号位都是不对的，溢出的情况我们不考虑 a+b，有以下 3 种可能 a+b = 0 a+b &lt; 0 a+b &gt; 0 以 8 位为例 我们知道由于引入了补码，所以 a+b = 0 的结果必然是 [0000 0000] 以 -3+1 为例，-3+1 = -2+(-1)+1 = -2 + 0，由于 0 是 [0000 0000]，注意我们舍弃了相加等于0的进位，所以符号位由 -2 确定 a+b &gt; 0 同理 这就是补码运算中符号位是正确的原因 五、当遇上位运算Q：~1 和 ~-1 是多少~ 是按位取反 1 的补码是 0000 0001，按位取反后是 1111 1110，这是一个负数补码，其原码是 1000 0010，即 -2 -1 的补码是 1111 1111，按位取反后是 0000 0000，这是一个正数补码，其原码是自己，即 0 Q：9&gt;&gt;&gt;2 和 -9&gt;&gt;&gt;2 是多少&gt;&gt;&gt; 是无符号右移 9 的补码是 0000 1001，无符号右移 2 位后是 0000 0010，这是一个正数补码，其原码是自己，即 2 -9 的补码是 1111 0111，无符号右移 2 位后是 0011 1101，这是一个正数补码，其原码是自己，即 61（以 8 位机器为例） 注意：无符号位移后是补 0 Q：9&gt;&gt;2 和 -9&gt;&gt;2 是多少&gt;&gt; 是有符号右移 9 的补码是 0000 1001，有符号右移 2 位后是 0000 0010，这是一个正数补码，其原码是自己，即 2 -9 的补码是 1111 0111，有符号右移 2 位后是 1111 1101，这是一个负数补码，其原码是 1000 0011，即 -3 注意：有符号位移后，正数补 0，负数补 1 注意：对于补码来说，正数前面补 0 不会影响其值，负数前面补 1 不会影响其值","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"计算机基础","slug":"tech/Others/计算机基础","permalink":"https://norcy.github.io/wiki/categories/tech/Others/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/计算机基础/字符编码/","text":"一、ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 二、非 ASCII 编码英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 三、Unicode正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。 四、Unicode 的问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。 五、UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围 (十六进制) UTF-8编码方式（二进制） 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（0100 1110 0010 0101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 可以看到严的 Unicode码 是4E25，UTF-8 编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现 六、Little endian 和 Big endianUnicode 的编码方式有 Little endian 和 Big endian 之分 以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 七、实例严字，依次采用Unicode，Unicode big endian和UTF-8编码方式保存。 1）Unicode：编码是四个字节FF FE 25 4E，其中FF FE表明是小头方式存储，真正的编码是4E25。 2）Unicode big endian：编码是四个字节FE FF 4E 25，其中FE FF表明是大头方式存储。 3）UTF-8：编码是六个字节EF BB BF E4 B8 A5，前三个字节EF BB BF表示这是UTF-8编码，后三个E4B8A5就是严的具体编码，它的存储顺序与编码顺序是一致的。（注意 UTF-8 并没有 Little endian 和 Big endian 之分）","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"计算机基础","slug":"tech/Others/计算机基础","permalink":"https://norcy.github.io/wiki/categories/tech/Others/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/iOS/Block/Block 的实现（简化版）/","text":"不捕获任何变量12345int main()&#123; void (^blk)(void) = ^&#123;printf(&quot;Block\\n&quot;);&#125;; blk();&#125; 1234567891011121314151617181920212223// block 转化后的类struct block_struct&#123; // 构造函数传入函数实现 block_struct(void *fp) &#123; this.FuncPtr = fp; // 函数实现 &#125;&#125;;// block 的内容被转化为 1 个全局函数static void block_imp(block_struct *self)&#123; printf(&quot;Block\\n&quot;);&#125;int main()&#123; // 以下语句等同于 void (^blk)(void) = ^&#123;printf(&quot;Block\\n&quot;);&#125;; block_struct blk(block_imp); // 以下语句等同于 blk() blk.FuncPtr(blk);&#125; Block 的内容被转化为 1 个全局函数 Block 本身被转为一个 struct，其构造函数传入这个全局函数的地址 Block 的调用等同于，调用 struct 的函数实现，参数是自身 捕获局部变量123456int main()&#123; int val = 5; void (^blk)(void) = ^&#123;printf(&quot;%d\\n&quot;, val);&#125;; blk();&#125; 1234567891011121314151617181920struct block_struct&#123; int val; // 多了变量 block_struct(void *fp, int _val):val(_val) // 构造函数多了个参数 &#123; this.FuncPtr = fp; &#125;&#125;;static void block_imp(block_struct *self)&#123; printf(&quot;%d\\n&quot;, self-&gt;val);&#125;int main()&#123; int val = 5; block_struct blk(block_imp, val); blk.FuncPtr(blk);&#125; 不同之处是转换后的结构体多了一个 int 的成员变量，构造函数和函数实现也相应的变化了 因为是值复制，所以无法在 Block 对捕获的简单类型值进行赋值 捕获全局变量、静态全局变量、静态局部变量123456789101112131415int global_val = 10;static int static_global_val = 10;int main()&#123; static int static_val = 10; void (^blk)(void) = ^&#123; printf(&quot;%d\\n&quot;, global_val); printf(&quot;%d\\n&quot;, static_global_val); printf(&quot;%d\\n&quot;, static_val); &#125;; global_val = 18; static_global_val = 18; static_val = 18; blk(); // 18,18,18&#125; 123456789101112131415161718192021222324252627int global_val = 10;static int static_global_val = 10;struct block_struct&#123; int *static_val; // 指针 block_struct(void *fp, int _static_val):static_val(_static_val) &#123; this.FuncPtr = fp; &#125;&#125;;static void block_imp(block_struct *self)&#123; printf(&quot;%d\\n&quot;, global_val); printf(&quot;%d\\n&quot;, static_global_val); printf(&quot;%d\\n&quot;, *(self-&gt;staic_val));&#125;int main()&#123; static int static_val = 10; block_struct blk(block_imp, &amp;static_val); global_val = 18; static_global_val = 18; static_val = 18; blk.FuncPtr(blk);&#125; 对于全局变量，block_struct 没有增加变量；对于局部静态变量，存储的是指针 这样就可以在 Block 内部任意的修改这些值 捕获 __block 变量1234567int main()&#123; __block int val = 10; void (^blk)(void) = ^&#123;printf(&quot;%d\\n&quot;, val);&#125;; val = 1; blk(); // 1&#125; 123456789101112131415161718192021222324252627struct block_struct&#123; block_val *val; // 多了变量 block_struct(void *fp, int _val):val(_val) // 构造函数多了个参数 &#123; this.FuncPtr = fp; &#125;&#125;;struct block_val&#123; block_val *forwarding; int val;&#125;;static void block_imp(block_struct *self)&#123; printf(&quot;%d\\n&quot;, self-&gt;val-&gt;forwarding-&gt;val);&#125;int main()&#123; block_val val(&amp;val, 10); block_struct blk(block_imp, val); (val.forwarding-&gt;val) = 1; blk.FuncPtr(blk); // 1&#125; __block 变量被转为一个类 无论是 Block 内还是外，访问值都得通过 forwarding 指针 Block 得到的是一个对象的指针，因此读写方面可以和 Block 外部的值保持一致 这个例子中 forwarding 指针都是自己，不能体现其意义，那么 forwarding 指针有什么用呢？ 我们知道，当对一个栈 Block 进行 copy 时，copy 函数会返回一个堆 Block。 copy 调用的时候，会将此堆 Block 访问到的 block_val 的 forwarding 指针，指向堆 Block 新生成的 block_val，而堆 Block 自己的 block_val 的 forwarding 指针会指向自己 这样原本在栈上的 block_val，或者是堆 Block 的 block_val，访问到的对象都会是同一个 1234__block int val = 0;void (^blk)(void) = [^&#123;++val;&#125; copy];++val; //1blk(); //2 12345block_val val(&amp;val, 0); // 这是一个在栈上的 block_valblock_struct temp(block_imp, val); // 这是一个在栈上的 Blockblock_struct blk = _Block_copy(temp); // 这是一个在堆上的 Block，会新生成一个新的 block_val，同时这个过程会修改 block_val 的 forwarding 指向这个新的 block_val(val.forwarding-&gt;val)++; // 对栈上的 block_val 操作是通过 forwarding，此时其指向的是堆上的 block_valblk.FuncPtr(blk); // 堆 Block 内部操作的是自己的 block_val，其 forwarding 指向自己 捕获对象__strong 类型的对象1234567int main()&#123; id array = [NSMutableArray new]; void (^blk)(void) = ^&#123;NSLog(@&quot;array count = %ld&quot;,[array count]);&#125;; [array addObject:[NSObject new]]; blk(); // 1&#125; 123456789101112131415161718192021struct block_struct&#123; id __strong array; block_struct(void *fp, int _array):array(_array) &#123; this.FuncPtr = fp; &#125;&#125;;static void block_imp(block_struct *self)&#123; NSLog(@&quot;array count = %ld&quot;,[self-&gt;array count]);&#125;int main()&#123; id array = [NSMutableArray new]; block_struct blk(block_imp, array); [array addObject:[NSObject new]]; blk.FuncPtr(blk); // 1&#125; 截获对象时，Block 内部的成员变量是用 strong 修饰，会使变量的引用计数加 1 Block 释放时，自然也会对使该变量的引用计数 -1 如果对这个 Block 进行 copy，那么栈 Block 会变成堆 Block，Block 本身的引用计数会 +1，不过这个例子没有体现 __block + __strong 类型的对象1234567int main()&#123; __block id array = [NSMutableArray new]; void (^blk)(void) = ^&#123;NSLog(@&quot;array count = %ld&quot;,[array count]);&#125;; [array addObject:[NSObject new]]; blk(); // 1&#125; 12345struct block_val&#123; block_val *forwarding; id array;&#125;; 和捕获 __block 一样，只是 block_val 内部维护的是一个对象","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Block","slug":"tech/iOS/Block","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Block/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/iOS/Block/Block/","text":"什么是 Block Block 是带有自动变量（局部变量）的匿名函数 ——《Objective-C 高级编程》 Block 是 Objective-C 对于闭包的实现，本质是一个封装了函数以及函数上下文的对象 可以定义在函数内或函数外 本质是对象 Block 的写法Block 的定义 无参数无返回值 1234void (^MyBlockOne)(void) = ^(void)&#123; NSLog(@&quot;无参数，无返回值&quot;);&#125;;MyBlockOne(); // Block的调用 有参数无返回值 1234void (^MyblockTwo)(int a) = ^(int a)&#123; NSLog(@&quot;@ = %d我就是Block，有参数，无返回值&quot;,a);&#125;; MyblockTwo(100); 有参数有返回值 123456// 声明时可以省略参数的名字int (^MyBlockThree)(int,int) = ^(int a,int b)&#123; NSLog(@&quot;%d我就是Block，有参数，有返回值&quot;,a + b); return a + b;&#125;; int ret = MyBlockThree(12,56); 无参数有返回值(很少用到) 12345int (^MyblockFour)(void) = ^&#123; NSLog(@&quot;无参数，有返回值&quot;); return 45;&#125;;int ret = MyblockFour(); Block 的省略写法以上等式的右半部分是 Block 的写法，以下是 Block 的语法，其中表达式就是 Block 的函数内容 12^ 返回值类型 参数列表 表达式^int(int a, int b) &#123;return a+b;&#125; 其中返回值类型可以被省略。省略返回值类型时，如果有 return 语句就使用该返回值的类型，如果有多条 return 语句则它们的类型必须相同，如果没有 return 则为 void 12^ 参数列表 表达式^(int a, int b) &#123;return a+b;&#125; 参数列表也可以被省略，前提是这个 Block 没有参数（而有返回值的时候依然可以省略返回值） 12^ 表达式^&#123;return @&quot;Hello&quot;;&#125; typedef实际开发中常用 typedef 定义 Block 12345678910// 最好不要省略参数的名字typedef int (^MyBlock)(int a, int b);// 注意这里不是指针@property (nonatomic, copy) MyBlock myBlock;// 注意与直接定义 Block 不同，等号右边的返回值是写出来的self.myBlock = ^int(int a,int b)&#123;&#125; 使用 typedef 定义的时候，最好不要省略参数的名字 Block 虽然是对象，但是作为属性一般不是指针类型 截获外界变量截获自动变量（局部变量）值Block 只捕获在 Block 内部使用的自动变量（局部变量），是值复制而非引用，特别要注意的是默认情况下 Block 只能访问不能修改局部变量的值 1234567int age = 10;MyBlock block = ^&#123; NSLog(@&quot;age = %d&quot;, age); //age = 11; 会导致编译错误&#125;;age = 18;block(); // age = 10 全局变量、静态全局变量和静态局部变量如果是这些类型，则 Block 直接可以访问到该变量自身，不需要进行拷贝，因此修改生效 123456789101112131415int global_val = 10;static int static_global_val = 10;int main()&#123; static int static_val = 10; myBlock block = ^&#123; printf(&quot;%d\\n&quot;, global_val); printf(&quot;%d\\n&quot;, static_global_val); printf(&quot;%d\\n&quot;, static_val); &#125;; global_val = 18; static_global_val = 18; static_val = 18; block(); // 18,18,18&#125; __block 修饰的外部变量对于用 __block 修饰的外部变量（称为 __block 变量），Block 是复制其引用地址来实现访问的。Block 可以修改 __block 修饰的外部变量的值 123456__block int age = 10;myBlock block = ^&#123; NSLog(@&quot;age = %d&quot;, age);&#125;;age = 18;block(); // age = 18 注意： __block 变量就是用 __block 修饰的局部变量 Block 的实现123456int main()&#123; void (^blk)(void) = ^&#123;printf(&quot;Block\\n&quot;);&#125;; blk();&#125; 通过 clang -rewrite-objc MyBlock.c 可以转化为 C 语言的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; printf(&quot;Block\\n&quot;);&#125;struct __block_impl&#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; // 以下语句等同于 // void (^blk)(void) = ^&#123;printf(&quot;Block\\n&quot;);&#125;; struct __main_block_impl_0 tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA); struct __main_block_impl_0 *blk = &amp;tmp; // 以下语句等同于 // blk() void *fun = blk-&gt;impl.FuncPtr; // void * 转换为函数指针进行调用 (*((void(*)(__main_block_impl_0 *))(fun)))(blk);&#125; __main_block_impl_0 的指针，其命名规则是由函数名（main）和 Block 出现的位置（第 0 个）决定的 Block 其实是一个 __main_block_impl_0 的指针，其主要包含一个 __block_impl，__block_impl 主要存储了一个函数指针，指向 Block 的内容 Block 的调用就是利用函数指针进行函数调用 为什么说 Block 是一个 Objective-C 对象？12345678910111213141516171819// Objective-C 对象的结构体struct class_t&#123; struct class_t *isa; struct class_t *superclass; Cache cache; IMP *vtable; uintptr_t data_NEVER_USE;&#125;;// 展开 __block_impl 后，Block 可以表示为以下结构体struct __main_block_impl_0 &#123; void *isa; int Flags; int Reserved; void *FuncPtr struct __main_block_desc_0* Desc;&#125;; __main_block_impl_0 相当于基于 objc_object 的 Objective-C 类对象的结构体，所以说 Block 是一个 Objective-C 对象 其中，Block 的 isa 的取值可能为 _NSConcreteGlobalBlock/_NSConcreteStackBlock/_NSConcreteMallocBlock 截获自动变量（局部变量）的实质12345678int main()&#123; int val = 5; void (^blk)(void) = ^&#123;printf(&quot;%d\\n&quot;, val);&#125;; blk();&#125; 转换后的代码与之前的差别是 12345678910111213141516171819struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _val, int flags=0):val(_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; int val = __cself-&gt;val; printf(&quot;%d\\n&quot;, val);&#125; 最主要的差别就是 __main_block_impl_0 自动增加了一个 val 的成员变量，构造函数也发生了相应的变化。注意这里是值复制，这样就可以解释为什么 Block 截获局部变量，在执行 Block 内容时修改其值并不会影响原来的值。同时，因为这种实现无法改变被截获的局部变量的值，所以当在一个 Block 内对一个局部变量进行赋值的时候，编译器就会报错 截获全局变量、静态全局变量、静态局部变量的实质123456789101112131415int global_val = 10;static int static_global_val = 10;int main()&#123; static int static_val = 10; void (^blk)(void) = ^&#123; printf(&quot;%d\\n&quot;, global_val); printf(&quot;%d\\n&quot;, static_global_val); printf(&quot;%d\\n&quot;, static_val); &#125;; global_val = 18; static_global_val = 18; static_val = 18; blk(); // 18,18,18&#125; 转换后的代码与之前的差别是 12345678910111213141516171819202122232425262728293031int global_val = 10;static int static_global_val = 10;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *static_val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0):static_val(_static_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; int staic_val = *(__cself-&gt;staic_val); printf(&quot;%d\\n&quot;, global_val); printf(&quot;%d\\n&quot;, static_global_val); printf(&quot;%d\\n&quot;, staic_val);&#125;int main()&#123; static int static_val = 10; struct __main_block_impl_0 tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val); // 下同，省略&#125; 对于全局变量和静态全局变量，转换后的代码依然可以访问到，因此在 __main_block_impl_0 内部并不会新增多余的成员变量 对于静态变量，Block 存储了其地址，从而达到可以修改其值的目的。其实普通局部变量也可以通过传地址的方式来达到在 Block 执行时可以修改其值的目的，但为什么没这么做呢？因为即使保存了普通局部变量的地址，当该变量的作用域失效的时候，那么这个地址也是非法的。而静态局部变量的作用域是一直有效，因此采用存储的地址的方法 截获 __block 变量12345678910int main()&#123; __block int val = 10; void (^blk)(void) = ^&#123;printf(&quot;%d\\n&quot;, val);&#125;; val = 1; blk(); // 1&#125; 转换后的代码与之前的差别是 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct __Block_byref_val_0 &#123; void *__isa; __Block_byref_val_0 *__forwarding; // 实例本身 int __flags; int __size; int val;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_val_0 *val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0):val(_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; __Block_byref_val_0 *val = __cself-&gt;val; printf(&quot;%d\\n&quot;, val-&gt;_forwording-&gt;val);&#125;static void __main_block_copy_0(struct __main_block_impl_0 *dst,struct __main_block_impl_0 *src) &#123; _Block_object_assign(&amp;dst-&gt;val, src-&gt;val, BLOCK_FIELD_IS_BYREF);&#125;static void __main_block_dispose_0(struct __main_block_impl_0 *src) &#123; _Block_object_dispose(src-&gt;val, BLOCK_FIELD_IS_BYREF);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main()&#123; __Block_byref_val_0 val = &#123;0, &amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;; struct __main_block_impl_0 *blk = &amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;val, 0x22000000); (val.__forwarding-&gt;val) = 1; // 下同，省略&#125; main 函数中，__block 变量已经被转化为 __Block_byref_val_0，注意转换后的代码没有一个叫做 val 的基本类型的值 __Block_byref_val_0 最后一个参数表示 __block 变量的值，这意味着该结构体持有着与原局部变量值相同的成员变量 main 函数中，__Block_byref_val_0 的构造函数中，第二个参数传的是它自己（原本是 __block 变量）的地址 修改 val 的值是通过 __forwording 来实现的，这个例子中 __forwording 指向它自己 为什么 __Block_byref_val_0 不是在 Block 内部创建呢，而是定义在 Block 的外部？这是为了如果有两个 Block 同时截获同一个局部变量，这两个 Block 需要同时引用这个值，如此才能实现多个 Block 能够修改同一个 __block 变量的值 新增了 __main_block_copy_0 和 __main_block_dispose_0 函数，而这两个函数没有被显式调用，只是作为参数传给了 __main_block_desc_0 构造函数，这两个是为了实现正确的引用计数 因为 __block 变量被转化为一个带原值的对象，这个对象以指针的形式传到了 Block 内部，因此在 Block 内部修改其值就得以实现 注意：__block 变量与 Block 的区别：__block 变量是栈上的结构体实例，而 Block 是栈上块的结构体实例 截获对象__strong 类型的对象123456789101112blk_t blk;&#123; id array = [NSMutableArray new]; blk = [^(id object)&#123; [array addObject:object]; NSLog(@&quot;array count = %ld&quot;,[array count]); &#125; copy];&#125; blk([NSObject new]); // array count = 1blk([NSObject new]); // array count = 2blk([NSObject new]); // array count = 3 array 是局部变量，看起来应该会被释放，但是实际上却是被 Block 截获了 转换后的关键代码如下 12345678910111213141516struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; id __strong array; ...&#125;static void __main_block_copy_0(...)&#123; _Block_object_assign(...);&#125;static void __main_block_dispose_0(...) &#123; _Block_object_dispose(...);&#125; 截获对象时，Block 内部的成员变量是用 strong 修饰，因此才能使 array 不被释放 __main_block_copy_0 相当于 retain，会在栈 Block 被复制到堆时被系统调用，使对象的引用计数+1 __main_block_dispose_0 相当于 release，堆上的 Block 被释放，使对象的引用计数-1 如果以上代码不对 Block 进行 copy，那么虽然 Block 可以捕获 array 并强持有，但是由于还是在栈上，超出其作用域之后，Block 被释放，array 也跟着被释放，后续的 Block 调用会 Crash __block + __strong 类型的对象注意，如果是被 __block 和 __strong 同时修饰的对象，那么区别在于 __main_block_impl_0 持有的对象不再是 id __strong array 而是 __Block_byref_obj_0 123456789struct __Block_byref_obj_0 &#123; void *__isa;__Block_byref_obj_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); __strong id obj;&#125;; 除此之外，其结果基本与 __strong 类型的对象一致 __block 使得对象可以在 Block 内被赋值，否则会编译失败 __weak 类型的对象无论是有没有被 __block 修饰，__weak 类型的对象并不会增加对象的引用计数，所以对象依然会作用域结束时被释放，nil 被赋值给被截获的对象 Block 的类型我们先来看看一个由 C/C++/OBJC 编译的程序占用内存分布的结构： block有三种类型： 全局块(_NSConcreteGlobalBlock) 栈块(_NSConcreteStackBlock) 堆块(_NSConcreteMallocBlock) 它们的内存分配如上图 全局块存在于全局内存中，相当于单例 栈块存在于栈内存中，超出其作用域则马上被销毁 堆块存在于堆内存中，是一个带引用计数的对象，需要自行管理其内存 简而言之，存储在栈中的 Block 就是栈块、存储在堆中的就是堆块、既不在栈中也不在堆中的块就是全局块 _NSConcreteGlobalBlock以下情况均为全局块： 定义在函数之外（即写全局变量的地方） 没有截获任何局部变量（即使定义在函数内部） _NSConcreteStackBlock 栈上的 Block，如果其作用域结束，该 Block 就被废弃，如同一般的局部变量。同时，因为 __block 变量是被 Block 持有，所以它也会跟着 Block 一起被废弃 _NSConcreteMallocBlock 为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们可以把 Block 复制到堆中延长其生命周期 开启 ARC 时，大多数情况下编译器会恰当地进行判断，自动生成将 Block 从栈上复制到堆上的代码 Block 的复制操作执行的是 copy 方法。只要调用了 copy 方法，栈块就会变成堆块 举个例子，编译器会自动 copy 返回的 Block 12345typedef int (^blk_t)(int);blk_t func(int rate) &#123; return ^(int count) &#123; return rate * count; &#125;;&#125; 将 Block 从栈上复制到堆上相当消耗 CPU，所以当 Block 设置在栈上也能够使用时，就不要复制了，因为此时的复制只是在浪费 CPU 资源 栈 Block 复制到堆之后，它的 __forwarding 指针会指向堆 Block 通过 __forwarding, 无论是在 Block 中还是 Block 外访问 __block 变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个 __block 变量 1234567__block int val = 0;void (^blk)(void) = [^&#123;++val;&#125; copy];++val;blk(); 其中 ^{++val;} 和 ++val 转换后的代码如下 12// val 是 __block 变量变成的结构体，它含有 __forwarding 指针++(val.__forwarding-&gt;val); 关于 Block 类型的进一步阐释ARC 下，对于堆 Block 和栈 Block 的判断会更复杂，因为大多数情况下 ARC 会帮忙做 Copy 比如 Block 作为函数返回值返回的时候 Cocoa 框架的方法，方法中含有 usingBlock 等（如 NSArray 的 enumerateObjectUsingBlock） GCD 的 API 被 strong 变量引用到的 block 捕获到局部变量的时候，会自动 Copy 一下（所以大部分情况都是堆 Block 了） block 方法是参数的时候，依然是会触发 copy。（Xcode 13.4.1 验证如此，网上的答案都过时了） 123456789101112131415161718192021222324- (void)testMethod:(void (^)(int num))block &#123; NSLog(@&quot;%@&quot;,block); // __NSMallocBlock__&#125;- (void)main&#123; int var = 3; void (^blk)() = ^&#123; NSLog(@&quot;%@&quot;, @(var)); &#125;; __weak void (^blk2)() = ^&#123; NSLog(@&quot;%@&quot;, @(var)); &#125;; NSLog(@&quot;%@&quot;, blk); // __NSMallocBlock__ NSLog(@&quot;%@&quot;, blk2); // __NSStackBlock__ NSLog(@&quot;%@&quot;, ^&#123; NSLog(@&quot;%@&quot;, @(var)); // __NSMallocBlock__ &#125;); [self testMethod:^(int num) &#123; NSLog(@&quot;var=%d&quot;,var); &#125;];&#125; ARC 下，反而要创建一个栈 Block 更困难了，比如专门使用 weak 修饰的 block，但是没什么实际用途 因而随着 ARC 的完善，考察 Block 的类型判断跟考察 MRC 一样，越来越没有意义了 对各种类型的 Block 执行 copy 操作 栈 Block 何时会从栈复制到堆 对 Block 调用 copy Block 作为函数返回值返回的时候（编译器自动复制） Cocoa 框架的方法，方法中含有 usingBlock 等（如 NSArray 的 enumerateObjectUsingBlock）（编译器自动复制） GCD 的 API（编译器自动复制） 将 Block 赋值给类的 strong 成员变量 多次 copy Block无论是什么类型的 Block，对 Block 进行多次 copy 都不会有问题。在不确定时调用 copy 方法即可 12blk = [[blk copy] copy];// 经过多次复制，变量 blk 仍然持有 Block 的强引用，该 Block 不会被废弃 改代码等价为 123456789// 翻译后的代码&#123; blk_t tmp = [blk copy]; blk = tmp; &#125;&#123; blk_t tmp = [blk copy]; blk = tmp; &#125; 12345678910111213141516171819202122// 翻译后的代码+注释&#123; // 初识时，blk 指向一个栈块 blk_t tmp = [blk copy]; // 第一次 copy 会将栈块变为堆块，赋值给 tmp，tmp 此时强持有堆块 blk = tmp; // blk 和 tmp 都强持有堆块，blk 原来指向的栈块将会在整个函数结束时被释放&#125;// tmp 被释放，此时堆块只被 blk 持有&#123; blk_t tmp = [blk copy]; // 第二次 copy 会导致堆块的引用计数+1，tmp 强持有堆块 blk = tmp; // 赋值导致 blk 原有的指向失效，堆块引用计数-1，但此时 tmp 强持有，所以堆块不会被释放 // blk 再次指向堆块，此时 blk 和 tmp 同时强持有堆块&#125;// tmp 被释放，此时堆块只被 blk 持有，引用计数为 1 Block 循环引用使用 Block 成员变量引起的循环引用123456789101112131415161718192021222324252627282930313233typedeft void (^blk_t)(void);@interface MyObject : NSObject&#123; blk_t blk_;&#125;@end@implementation MyObject- (id)init&#123; self = [super init]; blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;; return self;&#125;- (void)dealloc&#123; NSLog(@&quot;dealloc&quot;);&#125;@endint main()&#123; id o = [[MyObject alloc] init]; NSLog(@&quot;%@&quot;, o); return 0;&#125; 以上代码引起循环引用，self 强引用 Block，Block 强引用 self Block 截获了类的成员变量时，即使没有使用 self，也会同样截获 self 12345678910111213141516@interface MyObject : NSObject&#123; blk_t blk_; id obj_;&#125;@end@implementation MyObject- (id)init&#123; self = [super init]; blk_ = ^&#123;NSLog(@&quot;obj_ = %@&quot;, obj_);&#125;; return self;&#125; 对编译器来说，等价于 1blk_ = ^&#123;NSLog(@&quot;obj_ = %@&quot;, self-&gt;obj_);&#125;; 破解方法：使用 weak 修饰符 12345678910- (id)init&#123; self = [super init]; id __weak weakSelf = self; blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, weakSelf);&#125;; return self;&#125; 使用 __block 变量引起的循环引用1234567891011121314151617- (instancetype)init&#123; self = [super init]; __block id temp = self;//temp持有self //self持有blk_ blk_ = ^&#123; NSLog(@&quot;self = %@&quot;,temp);//blk_持有temp temp = nil; &#125;; return self;&#125;- (void)execBlc&#123; blk_();&#125; 该源代码没有引起循环引用。但是，如果不调用 execBlock 实例方法（即不执行赋值给成员变量 blk_ 的 Block），便会循环引用并引起内存泄露 破解方法：执行 Block 将 __block 变量置空 两种方法的比较相比使用 Block 成员变量，使用 __block 变量的优点如下： 通过 __block 变量可控制对象的持有期间（即不会在执行 Block 之前被释放，不过使用 Block 成员变量可以通过 Strong-Weak Dance 来解决被截获对象被提早释放的问题） 缺点如下： 为避免循环引用必须执行 Block 相关链接 之前写的关于 Block 的笔记 Strong-Weak Dance iOS Block 详解","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"iOS","slug":"tech/iOS","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/"},{"name":"Block","slug":"tech/iOS/Block","permalink":"https://norcy.github.io/wiki/categories/tech/iOS/Block/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/Xcode/库/iOS 二进制文件分析之常用命令/","text":"otoolotool 命令全称 object file displaying tool，是针对目标文件的展示工具，可以帮助我们发现应用中使用了哪些系统库，以及调用了哪些对象的方法和属性。 12345otool -L path // 查看可执行程序都链接了那些库otool -L path | grep &quot;xxx&quot; // 筛选是否链接了 xxx 库otool -ov path // 输出 Object-C 类结构以及定义的方法 lipo处理架构相关 1234567lipo -info XXX // 查看静态库所支持的架构 armv7 x86_64 arm64lipo -remove armv7 origin_xxx.a -output op_xxx.a // 删除静态库包括的 armv7 架构lipo -thin arm64 origin_xxx.a -output op_xxx.a // 拆分静态库，只保留 arm64 CPU 架构lipo -create 模拟器架构.a 真机架构.a -output 目标通用架构.a // 合并成通用架构 nmnm 命令的作用是显示符号表 12345nm path // 得到 Mach-O 中的程序符号表nm -nm path // 目标文件的所有符号nm -u path //Display only undefined symbols. 如查看 JSCore 中是否包含 stepInto 方法 1nm ~/Library/Developer/Xcode/iOS\\ DeviceSupport/15.2.1\\ \\(19C63\\)\\ arm64e/Symbols/System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore | grep stepInto strings搜索二进制文件中是否包含相关字符串，常用的命令为： 1strings xxx.a | grep &quot;xxx&quot;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"},{"name":"库","slug":"tech/Others/Xcode/库","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/%E5%BA%93/"}]},{"title":"动态库和静态库","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/Xcode/库/动态库和静态库/","text":"库什么是库 库的本质是一段编译好的二进制代码，加上头文件就可以供别人使用。 库从广义上可分为开源库和闭源库, 而闭源库才分为静态库和动态库 开源库：对外公开源代码, 能看到具体的代码实现, 例如Github上面的第三方开源库都称之为开源库 闭源库：不公开源代码, 文件是经过编译后的二进制文件, 看不到具体实现 为什么要用库 保护代码：某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件 提高编译速度：对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间 静态库和动态库上面提到库在使用的时候需要 Link，Link 的方式有两种，静态和动态，于是便产生了静态库和动态库 静态库静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a） 之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了 所以如果两个程序都用了某个静态库，那么每个二进制可执行文件里面其实都含有这份静态库的代码 优点是编译完成之后，目标程序不再依赖库文件，直接就可以运行 缺点是会使用目标程序的体积增大 动态库动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib/.tbd） 与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来 优点是，不会影响目标程序的体积（不需要拷贝到目标程序中），而且同一份库可以被多个程序共享使用；同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码 缺点是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误） Framework什么是 FrameworkFramework 是Cocoa/Cocoa Touch程序中使用的一种资源打包方式，可以将代码文件(.a)、头文件、资源文件、说明文档等集中在一起，方便开发者使用 系统的 Framework 是动态库，开发者自己开发的 Framework 是静态库 其实是资源打包的方式，和静态库动态库的本质是没有关系的 苹果在iOS平台上规定不允许存在动态库，但是为了 App 和 Extension 能够共享代码，提出了 Embedded Framework .a与.framework的区别 .a是一个纯二进制文件不能直接使用，必须要有.h文件才能使用，.h文件对外提供接口 .framework中除了有二进制文件之外还有资源文件，可以直接使用所以开发中建议使用.framework .a、.dylib 和 .tbd.a：静态库的后缀名.dylib：动态库的后缀名.tbd：text-based stub libraries，本质上就是一个YAML描述的文本文件。iOS 7 之后取代 .dylib。具体请看这里 动态 Framework 和静态 Framework使用 file 命令可以判断 .framework 中的可执行文件是动态还是静态 123456file GPUImage.framework/GPUImageGPUImage.framework/GPUImage: Mach-O universal binary with 4 architectures: [i386:Mach-O dynamically linked shared library i386] [arm64]GPUImage.framework/GPUImage (for architecture i386): Mach-O dynamically linked shared library i386GPUImage.framework/GPUImage (for architecture x86_64): Mach-O 64-bit dynamically linked shared library x86_64GPUImage.framework/GPUImage (for architecture armv7): Mach-O dynamically linked shared library arm_v7GPUImage.framework/GPUImage (for architecture arm64): Mach-O 64-bit dynamically linked shared library arm64 12345file TVKPlayer.framework/TVKPlayerTVKPlayer.framework/TVKPlayer: Mach-O universal binary with 3 architectures: [arm_v7:current ar archive] [arm64]TVKPlayer.framework/TVKPlayer (for architecture armv7): current ar archiveTVKPlayer.framework/TVKPlayer (for architecture x86_64): current ar archiveTVKPlayer.framework/TVKPlayer (for architecture arm64): current ar archive 可以看到 GPUImage 有 dynamic，它是动态 framework，而 TVKPlayer 是静态的 如果是动态的 Framework，添加到工程的时候需要在 Embedded Binaries 下面手动添加，意思是嵌入，并不是嵌入 app 可执行文件，而是嵌入 app 的 bundle 文件。当一个 app 通过 Embedded 的方式嵌入一个 app 后，在打包之后解压 ipa 可以在包内看到一个 framework 的文件夹，下面都是与这个应用相关的动态 framework 如果是静态的 Framework，添加到工程的时候需要在 Linked Frameworks and Libraries 添加，这些 Framework 将会被拷贝到 App 的可执行文件中 架构 123// 1. 模拟器使用的CPU架构： i386: iPhone4s - iPhone5x86_64: iPhone5s - iPhoneX 123456// 2. 真机使用的CPU架构： armv6: iPhone、iPhone 2、iPhone 3G、iPod Toucharmv7: iPhone3Gs - iPhone4sarmv7s: iPhone5、iPhone5carm64: iPhone5s - iPhoneX（没有armv64） 命令查看 .a 支持的架构lipo -info xxx.a 合并成通用架构lipo -create 模拟器架构.a 真机架构.a -output 目标通用架构.a 参考iOS - 静态库、动态库、Framework组件化-动态库实战","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"},{"name":"库","slug":"tech/Others/Xcode/库","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/%E5%BA%93/"}]},{"title":"库体积优化","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/Xcode/库/库体积优化/","text":"概念符号表符号表是内存地址与函数名、文件名、行号的映射表。符号表元素如下所示： &lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;] Debug Symbol 调试符号借助符号调试程序可以将原始符号表转换成可读性较强的符号表，主要是方便开发人员获取调试信息 还原前： 12345Thread 0 Crashed:0 libobjc.A.dylib 0×300c87ec 0×300bb000 + 552761 MobileLines 0×00006434 0×1000 + 215562 MobileLines 0×000064c2 0×1000 + 216983 UIKit 0×30a740ac 0×30a54000 + 131244 还原后： 12345Thread 0 Crashed:0 libobjc.A.dylib 0×300c87ec objc_msgSend + 201 MobileLines 0×00006434 -[BoardView setSelectedPiece:] (BoardView.m:321)2 MobileLines 0×000064c2 -[BoardView touchesBegan:withEvent:] (BoardView.m:349)3 UIKit 0×30a740ac -[UIWindow sendEvent:] + 264 DWARF一种支持源代码级别调试的调试文件格式 DWARF是平台独立的且适用于任何处理器任何操作系统 dSYMiOS平台中，dSYM文件是指具有调试信息的目标文件，文件名通常为：xxx.app.dSYM 为了避免进行 Strip 操作后调试符号的丢失，你可以使用dwarf-with-dsym选项。 DWARF with dSYM 选项在标准的DWARF之外执行一个额外的步骤：创建一个单独的MyApp.app.dSYM文件，这个文件包含你的程序的所有调试符号(这个文件其实是一个包，可以通过右键-&gt;显示包内容进行查看)。 事实上，DWARF with dSYM选项允许你对你进行单步调试而不管可执行程序是否被剥离了调试信息(stripped)。 这是可能的，这是因为gdb将会在你的程序的目录下查找.dSYM文件。它不需要知道对象文件(object files)的名字或者路径。如果你不除去调试符号 (strip debugging symbols)，你可以使用.o或者.dSYM文件来调试。 DWARF - Object files and linked products will use DWARF as the debug information format. [dwarf] DWARF with dSYM File - Object files and linked products will use DWARF as the debug information format, and Xcode will also produce a dSYM file containing the debug information from the individual object files (except that a dSYM file is not needed and will not be created for static library or object file products). [dwarf-with-dsym] 静态库无法产生 dsym 编译选项Generate Debug Symbols是否产生调试符号 当Generate Debug Symbols设置为YES时，编译产生的.o文件会大一些，当然最终生成的可执行文件也大一些（亲测如此） 当Generate Debug Symbols设置为NO的时候，在Xcode中设置的断点不会中断。但是在程序中打印 [NSThread callStackSymbols]，依然可以看到类名和方法名 在程序崩溃时，也可以得到带有类名和方法名的函数调用栈 19 QQLiveInternational 0x00000001069c2515 -[QVNUICustomView layoutSubviews] + 3253 结论：Debug/Release 均打开 Debug Information Level调试符号携带的信息等级 Debug Information Level 默认值为 Compiler default，另一个选项是 Line tables only Generate Debug Symbols = YES 的前提下，如果选择 Line tables only，调试信息带有函数名、文件名和行号，但是不包含其他数据（比如局部变量和函数参数）。所以断点可以工作，但是无法在 lldb 中查看局部变量的值（亲测如此） Deployment Postprocessing该选项是所有 Strip 选项的总开关 Strip，也就是把生成的 .o 文件中剥离特定的符号（symbols） Strip Linked Product 如果 Deployment Postprocessing 不打开，该选项没有作用 如果该选项生效，app 构建的过程多了两步 在app构建的开始，会生成一些.hmap辅助文件 在app构建的末尾，会执行Strip操作 如果该选项生效，断点不会中断，在程序中打印 [NSThread callStackSymbols] 也无法看到类名和方法名，程序崩溃时无法看到类名和方法名 Strip StyleStrip Linked Product 打开时该选项才生效（待验证） 剥离符号的程度依次是All Symbols &gt; Non-Global Symbols &gt; Debugging Symbols All Symbols：剥离所有符号表和重定向信息，适用于最后生成 .app 的工程 Non-Global Symbols：剥离非全局的符号（包括调试符号），保留外部符号，适用于 bundle 和 framework Debugging Symbols：剥离调试符号，保留局部符号和全局符号，都适用 Strip Linked Product = YES 时，如果把 Strip Style 从 All Symbols 改为 Debugging Symbols，则程序崩溃时就可以看到类名和方法名 注意如果构建的是一个静态库，则不可以 strip all，因为剥离了所有符号的静态库是无法被正常链接的（亲测编译失败） Link Time Optimization优点： 将一些函数內联化 去除了一些无用代码 对程序有全局的优化作用 缺点： 降低编译链接速度，只建议在打正式包时开启 降低 link map 可读性（多出了很多数字开头的“类”） 我是如何把 600M 的库减少到 30M123Deployment Postprocessing = 1Strip Linked Product = 1Strip Style = Non-Global Symbols 不过这样会导致 crash 时无法查看堆栈信息 参考文章 Xcode中和symbols有关的几个设置（好文） 干货|今日头条iOS端安装包大小优化—思路与实践 注意 是对 Framrwork 的 Target 进行设置，而不是用于打包的 Target Generate Debug Symbols = NO，Deployment Postprocessing = NO时，体积仍然很大（猜测：strip 不止剥离了 debug symbols，还剥离了其他内容，比如符号表）","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"},{"name":"库","slug":"tech/Others/Xcode/库","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/%E5%BA%93/"}]},{"title":"","date":"2025-04-20T05:50:42.953Z","path":"tech/Others/Xcode/库/编译选项/","text":"OTHER_CFLAGS 和 GCC_PREPROCESSOR_DEFINITIONS 区别1s.pod_target_xcconfig = &#123; &#x27;OTHER_CFLAGS&#x27; =&gt; &#x27;-DFoo&#x27;, &#x27;GCC_PREPROCESSOR_DEFINITIONS&#x27; =&gt; &#x27;Foo&#x27; &#125; OTHER_CFLAGS 是直接传递给编译器的，如果你要传递一个常量定义，那么你需要写 -D 开头，然后才是你的常量名称，如 -DFoo 而 GCC_PREPROCESSOR_DEFINITIONS 更加友好，你直接传递 Foo 就可以了，它会自动添加 -D 然后再传给编译器，这样就能减少出错 如果要定义常量，大部分场景下都优先推荐 GCC_PREPROCESSOR_DEFINITIONS 参考 Xcode Build Settings Part 1: Preprocessing","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"},{"name":"库","slug":"tech/Others/Xcode/库","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/%E5%BA%93/"}]},{"title":"","date":"2025-04-20T05:50:42.952Z","path":"tech/Others/VSCode 调教/","text":"配置同步Key：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 借助插件：vscode-syncing 备份方法：cmd+shift+p，输入 upload 恢复方法：cmd+shift+p，输入 download 安装命令行cmd+shift+p，输入 “install code command”，之后就可以在 Terminal 中使用 code 来打开 vscode 修改为中文cmd+shift+p，输入 “Configure Display Language”，选择 “Install additional languages”，安装中文插件即可 新增的快捷键 快捷键 作用 cmd+shift+p 命令窗口 cmd+k,cmd+s 快捷键设置 cmd+k,cmd+f 格式化文件 cmd+k,cmd+o 优化 import cmd+\\ 分割窗口抄代码，随后使用 cmd+1、cmd+2 切换窗口 alt+shift+o 查找函数 cmd+shift+\\ 跳转到匹配的括号 cmd+enter 在当前行下面新增一行，不影响这一行 1 option+↑/↓ 将代码向上/下移动 重构 命名重构：在变量上面按 F2 插件Markdown Preview Github Styling预览：cmd+shift+v Search node_modules输入快捷键「Cmd + Shift + P」，然后输入 node_modules 格式化使用 Prettier 插件 如果要全局支持 JS 格式化但是希望过滤 markdown 文件，需要进行以下操作 新建 .prettierignore 文件，推荐在 ~/ 目录下 .prettierignore 推荐配置如下 123**/.git**/node_modules*.md","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"Cocoapods","date":"2025-04-20T05:50:42.952Z","path":"tech/Others/Xcode/Cocoapods/","text":"VideoNative 项目与 Cocoapods三个仓库 VideoNative/VideoNative 日常开发用的仓库（开发仓库） VideoNative/VideoNativeFramework 稳定版本的仓库，存放框架文件，用于发布（发布仓库） VideoNative/VideoNativeSpecs 远程的私人 Cocoapods 源，存放 VideoNative.podspec（说明书仓库） 发布流程 用开发仓库的最新代码打包一个 Framework，拷贝到 VideoNativeFramework 仓库（本质：发布仓库在本地更新框架） 编辑 VideoNativeFramework 下的 VideoNative.podsepc 文件，更新版本号（或者依赖文件，如果需要的话）（本质：发布仓库在本地更新说明书） 执行 pod lib lint 进行本地检查，如果没问题就 Push 到远程（发布仓库在远程更新框架和说明书） 再执行 pod spec lint 进行远程检查（校验发布仓库的框架和说明书） 最后执行以下命令，将 VideoNativeFramework 的 VideoNative.podspec 推送到私人 Cocoapods 源（提交说明书到说明书仓库） 1pod repo push oa-videonative-vnspec VideoNative.podspec --verbose --allow-warnings 执行 pod search VideoNative 检查是否发布新版本成功（校验说明书仓库） 其他 spec 的全称是 specification，意为“说明书；技术规范” Cocoapods/Specs 的意思是这个是 Cocoapods 公有仓库的说明书合集 podspec 就是每个 pod 组件的说明书文件 pod lib lint 和 pod spec lint 区别 pod lib lint 只对本地的 podspec 进行检查，没有联网操作 pod spec lint 对远程仓库（Spec Repo）的 podspec 进行检查 podfile.lock 是什么可以参考这里 CocoaPods的原理与技巧（二） 优秀文章 我所理解的 CocoaPods 一行命令发布 Pod 框架（生成 podspec 的工具不错）","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"}]},{"title":"","date":"2025-04-20T05:50:42.952Z","path":"tech/Others/Xcode/使用脚本添加Xcode文件/","text":"主要是 XcodeProj 这个工具的应用 Xcode 中 Group 和 FileRef 的区别GroupGroup 这个概念和我们平时经常说的 folder 文件夹有很大的差别, 文件夹在我们的日常使用时是一直所接触到的, 而对于 Group, 如果你不使用 Xcode 来编程(不是很清楚别的 IDE 是否有这个功能)的话, 这个概念距离你太远了. Group 其实是 Xcode 中用来组织文件的一种方式, 它对文件系统没有任何影响, 无论你创建或者删除一个 Group, 都不会导致 folder 的增加或者移除. 当然如果在你删除时选择 Move to Trash 就是另外一说了. 在 Group 中的文件的关系, 不会与 folder 中的有什么冲突, 它只是 Xcode 为你提供的一种分离关注的方式而已. 但是, 我一般会在开发过程中将不同的模块分到不同的 Group 和 folder 中便于整理. Group 之间的关系, 也是在 project.pbxproj 中定义的, 这个文件中包含了 Xcode 工程中所有 File 和 Group 的关系, 如果你大致浏览过这个文件的话, 你就会对我所说的有所了解. Group 在我们的工程中就是黄色的文件夹, 而 Folder 是蓝色的文件夹 一般在 Xcode 工程中, 我们比较少用 Folder Folder 会被打入到 app 的 bundle 中，比如 H5 的离线包文件夹就可以使用 FileRefFileRef 其实就是 File Reference 的缩写, 当你从 Xcode 中删除一个文件的时候, 它会弹出提示框. 而其中的 Remove Reference 选项并不会将这个文件移除到垃圾桶, 而只是会将这个文件的引用从 Xcode 的工程文件中删除. 如果你曾经看过 Build Phases 中的内容, 你会发现 如果删除的是 .h 文件, 它会从 Build Phases 中的 Headers 部分删除如果删除的是 .m 文件, 它会从 Build Phases 中的 Compile Source 部分删除但是文件还是会在原来的地方, 因为 Xcode 中所加入到工程的只是文件的一个引用 — File Ref. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667require &#x27;xcodeproj&#x27;project_path = &#x27;./VideoNativeiPhone.xcodeproj&#x27;project = Xcodeproj::Project.open(project_path)# 测试的目录结构=begin./├── *.xcodeproj├── This └── is └── Test ├── Test.h └── Test.m=end# 递归从 Build Phases 删除引用def removeBuildPhaseFilesRecursively(aTarget, aGroup) aGroup.files.each do |file| if file.real_path.to_s.end_with?(&quot;.m&quot;, &quot;.mm&quot;, &quot;.cpp&quot;) then aTarget.source_build_phase.remove_file_reference(file) elsif file.real_path.to_s.end_with?(&quot;.plist&quot;) then aTarget.resources_build_phase.remove_file_reference(file) end end aGroup.groups.each do |group| removeBuildPhaseFilesRecursively(aTarget, group) endend# 枚举所有 targetproject.targets.each do |target| puts target.nameend# 获取第一个 Target，一般与工程名字同名target = project.targets.first# 根据路径名寻找 group。如果 should_create = true，则如果当前的 group 不存在, 它还会递归地创建group = project.main_group.find_subpath(File.join(&#x27;This&#x27;, &#x27;is&#x27;, &#x27;Test&#x27;), true)# 建议设置为 SOURCE_ROOT，为了加入到 Build Phases 的时候, 从工程文件的根目录下开始寻找你所添加的文件# &lt;absolute&gt; for absolute paths# &lt;group&gt; for paths relative to the group# SOURCE_ROOT for paths relative to the project# DEVELOPER_DIR for paths relative to the developer directory.# BUILT_PRODUCTS_DIR for paths relative to the build products directory.# SDKROOT for paths relative to the SDK directory.group.set_source_tree(&#x27;SOURCE_ROOT&#x27;)# 如果多次添加会导致重复，因此需要将引用和 build phases 的值删除if !group.empty? then removeBuildPhaseFilesRecursively(target, group) group.clear()end# 为文件创建一个 FileRef 添加到 group 中file_ref_h = group.new_reference(&quot;./This/is/Test/Test.h&quot;)file_ref_m = group.new_reference(&quot;./This/is/Test/Test.m&quot;)# .h文件只需引用一下，.m 引用后还需加入 Build Phasestarget.add_file_references([file_ref_m])# 保存project.save 参考文章 使用代码为 Xcode 工程添加文件（入门篇） 懒人福利：用脚本来修改Xcode工程（实战篇） XcodeProj 源码","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"}]},{"title":"","date":"2025-04-20T05:50:42.952Z","path":"tech/Others/Xcode/内存泄漏定位技巧/","text":"Instruments 的 Leak 使用 Make Generation 标记，如图所示。 Generation A 的内存占用表示的是，是从启动到标记 A 点的时候的内存增量 Generation B 的内存占用表示的是，是从标记 A 的时候到标记 B 点的时候的内存增量 点击具体的内存占用，如果右侧没有显示堆栈，则需要修改 Xcode 的 Build Settings -&gt; Debug Information Format，打开 Debug 下的 DWARF with dSYM File","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Xcode","slug":"tech/Others/Xcode","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Xcode/"}]},{"title":"","date":"2025-04-20T05:50:42.952Z","path":"tech/Others/Python/语法/Python 小知识/","text":"我用过的python库 pprint：美观打印数据结构 requests：可以方便地发送http请求，以及方便地处理响应结果，完胜自带的 urllib Beautiful Soup：抓取网页数据 字符串拼接1234567891011121314151617181920212223242526272829tpl = &quot;i am &#123;&#125;, age &#123;&#125;, &#123;&#125;&quot;.format(&quot;seven&quot;, 18, &#x27;alex&#x27;) tpl = &quot;i am &#123;&#125;, age &#123;&#125;, &#123;&#125;&quot;.format(*[&quot;seven&quot;, 18, &#x27;alex&#x27;]) tpl = &quot;i am &#123;0&#125;, age &#123;1&#125;, really &#123;0&#125;&quot;.format(&quot;seven&quot;, 18) tpl = &quot;i am &#123;0&#125;, age &#123;1&#125;, really &#123;0&#125;&quot;.format(*[&quot;seven&quot;, 18]) tpl = &quot;i am &#123;name&#125;, age &#123;age&#125;, really &#123;name&#125;&quot;.format(name=&quot;seven&quot;, age=18) tpl = &quot;i am &#123;name&#125;, age &#123;age&#125;, really &#123;name&#125;&quot;.format(**&#123;&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18&#125;) tpl = &quot;i am &#123;0[0]&#125;, age &#123;0[1]&#125;, really &#123;0[2]&#125;&quot;.format([1, 2, 3], [11, 22, 33]) tpl = &quot;i am &#123;:s&#125;, age &#123;:d&#125;, money &#123;:f&#125;&quot;.format(&quot;seven&quot;, 18, 88888.1) tpl = &quot;i am &#123;:s&#125;, age &#123;:d&#125;&quot;.format(*[&quot;seven&quot;, 18]) tpl = &quot;i am &#123;name:s&#125;, age &#123;age:d&#125;&quot;.format(name=&quot;seven&quot;, age=18) tpl = &quot;i am &#123;name:s&#125;, age &#123;age:d&#125;&quot;.format(**&#123;&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18&#125;) tpl = &quot;numbers: &#123;:b&#125;,&#123;:o&#125;,&#123;:d&#125;,&#123;:x&#125;,&#123;:X&#125;, &#123;:%&#125;&quot;.format(15, 15, 15, 15, 15, 15.87623, 2) tpl = &quot;numbers: &#123;:b&#125;,&#123;:o&#125;,&#123;:d&#125;,&#123;:x&#125;,&#123;:X&#125;, &#123;:%&#125;&quot;.format(15, 15, 15, 15, 15, 15.87623, 2) tpl = &quot;numbers: &#123;0:b&#125;,&#123;0:o&#125;,&#123;0:d&#125;,&#123;0:x&#125;,&#123;0:X&#125;, &#123;0:%&#125;&quot;.format(15) tpl = &quot;numbers: &#123;num:b&#125;,&#123;num:o&#125;,&#123;num:d&#125;,&#123;num:x&#125;,&#123;num:X&#125;, &#123;num:%&#125;&quot;.format(num=15) 全局变量1234OutputFile = &#x27;&#x27;def generateMarkdown(jsonData): OutputFile = &#x27;123&#x27; 如果在函数中需要对全局变量进行赋值，需要添加 global 关键字 12345OutputFile = &#x27;&#x27;def generateMarkdown(jsonData): global OutputFile OutputFile = &#x27;123&#x27; list 合并123l1 = [1,2,3]l2 = [3,4,5]l3 = l1+l2 将 json 写入文件123import jsonwith open(&#x27;data.json&#x27;, &#x27;w&#x27;) as f: json.dump(myJsonData, f, ensure_ascii=False) 优雅的写法 列出 1 到 10 的平方列表 1234L=[]for x in range(1,11): L.append(x*x)print(L) 优雅 12&gt;&gt;&gt; [x*x for x in range(1,11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 只取列表中的偶数 12&gt;&gt;&gt; [x*x for x in range(1,11) if x%2==0][4, 16, 36, 64, 100] 双重循环 12&gt;&gt;&gt; [m+n for m in &#x27;ABC&#x27; for n in&#x27;abc&#x27;][&#x27;Aa&#x27;, &#x27;Ab&#x27;, &#x27;Ac&#x27;, &#x27;Ba&#x27;, &#x27;Bb&#x27;, &#x27;Bc&#x27;, &#x27;Ca&#x27;, &#x27;Cb&#x27;, &#x27;Cc&#x27;]","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Python","slug":"tech/Others/Python","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/"},{"name":"语法","slug":"tech/Others/Python/语法","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2025-04-20T05:50:42.952Z","path":"tech/Others/Python/语法/Python 文件操作/","text":"python中对文件、文件夹(文件操作函数)的操作需要涉及到os模块和shutil模块。 例子读取文件全部内容12with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) as f: print(f.read()) 按行读取文件内容12for line in f.readlines(): print(line.strip()) # 把末尾的&#x27;\\n&#x27;删掉 按行写入文件123with open(&#x27;/path/to/file&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;Hello, world!\\n&#x27;) f.write(&#x27;Hello, world!2&#x27;) 清空指定文件夹的所有文件123456import osimport shutilif os.path.exists(root_director): shutil.rmtree(root_director) os.mkdir(root_director) APIPython脚本工作的目录路径(区别于脚本所在的目录)os.getcwd() 返回指定目录下的所有文件和目录名os.listdir() 检验给出的路径是否是一个文件os.path.isfile() 检验给出的路径是否是一个目录os.path.isdir() 判断是否是绝对路径os.path.isabs() 检验给出的路径是否存在os.path.exists() 返回一个路径的目录名和文件名os.path.split() 1os.path.dirname(&#x27;/a/b/c&#x27;) # (&#x27;a/b&#x27;, &#x27;c&#x27;) 分离扩展名os.path.splitext() 1os.path.dirname(&#x27;/a/b/c.txt&#x27;) # (&#x27;a/b/c&#x27;, &#x27;.txt&#x27;) 获取路径名os.path.dirname() 1os.path.dirname(&#x27;/a/b/c&#x27;) # a/b 获取文件名os.path.basename() 1os.path.dirname(&#x27;/a/b/c.txt&#x27;) # c.txt 运行shell命令os.system() 读取和设置环境变量os.getenv() 与os.putenv() 给出当前平台使用的行终止符os.linesep() Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’ 指示你正在使用的平台os.name()对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ 重命名os.rename(old,new) 创建多级目录os.makedirs(“a/b/c”) 创建单个目录os.mkdir(“test”) 获取文件属性os.stat(file) 修改文件权限与时间戳os.chmod(file) 终止当前进程os.exit() 获取文件大小os.path.getsize(filename) 复制文件shutil.copyfile(“oldfile”,”newfile”) oldfile和newfile都只能是文件 shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录 复制文件夹shutil.copytree(“olddir”,”newdir”) olddir和newdir都只能是目录，且newdir必须不存在 重命名文件(目录)os.rename(“oldname”,”newname”) 文件或目录都是使用这条命令 移动文件(目录)shutil.move(“oldpos”,”newpos”) 删除文件os.remove(“file”) 删除目录os.rmdir(“dir”) 只能删除空目录 shutil.rmtree(“dir”) 空目录、有内容的目录都可以删 删除多个目录os.removedirs() 转换目录os.chdir(“path”) 换路径 文件操作：os.mknod(“test.txt”) 创建空文件fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件 关于 open 模式： 1234567891011w 以写方式打开，a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ )","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Python","slug":"tech/Others/Python","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/"},{"name":"语法","slug":"tech/Others/Python/语法","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2025-04-20T05:50:42.952Z","path":"tech/Others/Python/语法/Python 网络请求/","text":"示例代码123456789101112131415161718192021import urllib.requestimport urllib.parseimport requestsfrom pprint import pprinturl = &#x27;https://api.douban.com/v2/book/search?q=%22%E7%99%BD%E5%A4%9C%E8%A1%8C%22&amp;count=1&amp;apikey=0df993c66c0c636e29ecbb5344252a4a&#x27;def useUrllib(): print(&quot;useUrllib&quot;) f = urllib.request.urlopen(url) print(f.read().decode(&#x27;utf-8&#x27;))def useRequests(): print(&quot;useRequests&quot;) r = requests.get(url) jsonResult = r.json(); pprint(jsonResult)if __name__ == &quot;__main__&quot;: # useUrllib() useRequests() 参考链接 Python3中进行HTTP请求的4种方式","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Python","slug":"tech/Others/Python","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/"},{"name":"语法","slug":"tech/Others/Python/语法","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/TS 笔记/","text":"其他 TypeScript 规定，变量只有赋值后才能使用，否则就会报错 12let x:number;console.log(x) // 报错 上面示例中，变量x没有赋值就被读取，导致报错。而 JavaScript 允许这种行为，不会报错，没有赋值的变量会返回undefined 类型声明并不是必需的如果没有声明，TypeScript 会自己推断类型 12let foo = 123;foo = &#x27;hello&#x27;; // 报错 TypeScript 也可以推断函数的返回值，正因如此，函数返回值的类型通常是省略不写的 123function toString(num:number) &#123; return String(num);&#125; 三种特殊类型 any： 定义：任意类型，对此 TS 会关闭类型检查 注意：any 类型不一定等于没写类型，因为没写时 TS 有可能自己推导出类型。 缺点：any 类型存在污染变量，慎用 12345let x:any = &#x27;hello&#x27;;let y:number;y = x; // 不报错y*123 // y 值其实是字符串了，但不报错 适用场景：重构老项目时可用，其他场景少用 unknown： 定义：与 any 类似，所有类型的值都可以赋值给 unknown，但可解决 any 的污染变量问题 12345let x:unknown;x = true; // 正确x = 42; // 正确x = &#x27;Hello World&#x27;; // 正确 注意：unknown 无法赋值给 any/unknown 以外类型，以此解决了 any 的污染变量问题 1234let v:unknown = 123;let v1:boolean = v; // 报错let v2:number = v; // 报错 注意：直接调用 unknown 的属性和方法都是不允许的，除非经过类型缩小 12345678910let v1:unknown = &#123; foo: 123 &#125;;v1.foo // 报错let v2:unknown = &#x27;hello&#x27;;v2.trim() // 报错let s:unknown = &#x27;hello&#x27;;if (typeof s === &#x27;string&#x27;) &#123; s.length; // 正确&#125; 适用场景：凡是需要设为 any 类型的地方，通常都应该优先考虑设为 unknown 类型 never 定义：空类型。即不可能有值。 注意：对应集合论中的空集，never 类型是所有类型的子集，因此可赋给所有类型 适用场景：不可能返回值的函数，或永久执行的函数，返回值的类型就可以写为 never，never 不是 void，前者表示函数没有执行结束，不可能有返回值；后者表示函数正常执行结束，但是不返回值 12345678910111213function f():never &#123; throw new Error(&#x27;Error&#x27;);&#125;function g():never &#123; while(true) &#123; console.log(&#x27;forever&#x27;) &#125;&#125;let v1:number = f(); // 不报错let v2:string = f(); // 不报错let v3:boolean = f(); // 不报错 类型系统JS 中的 8 种类型（不是 TS） boolean string number bigint symbol object undefined null 注意，所有类型的名称都是小写字母，首字母大写的Number、String、Boolean等在 JavaScript 语言中都是内置对象，而不是类型名称 在 JS 中，typeof运算符只可能返回八种结果，与上面的类型不同。注意 null 的类型是 object，以及多了一个 function 类型 123456789typeof undefined; // &quot;undefined&quot;typeof true; // &quot;boolean&quot;typeof 1337; // &quot;number&quot;typeof &quot;foo&quot;; // &quot;string&quot;typeof &#123;&#125;; // &quot;object&quot;typeof null // &quot;object&quot;typeof parseInt; // &quot;function&quot;typeof Symbol(); // &quot;symbol&quot;typeof 127n // &quot;bigint&quot; 而在 TS 中，typeof 返回的是该值的 TS 类型 123const a = &#123; x: 0 &#125;;type A = typeof a // 无法打印 A，因为 A 编译时会被删除，此时 A 的值应该是 &#123;x: number&#125;，这里是 TS 的 typeofconsole.log(typeof a) // &quot;object&quot;，这里是 JS 的 typeof 同一段代码可能存在两种typeof运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分 123456let a = 1;let b:typeof a;if (typeof a === &#x27;number&#x27;) &#123; b = a;&#125; 上面示例中，用到了两个typeof，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。 JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。 上例的代码编译结果如下。 12345let a = 1;let b;if (typeof a === &#x27;number&#x27;) &#123; b = a;&#125; 上面示例中，只保留了原始代码的第二个 typeof，删除了第一个 typeof undefined 与 null另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们 undefined 类型可包含一种值 undefined（不像 boolean，包含 true 和 false）。前者是类型，后者是值，需要区分 1let x:undefined = undefined; null 类型可包含一种值 null。前者是类型，后者是值，需要区分 1const x:null = null; 类型未声明，值为 undefined或null，它们的类型会被推断为any 12345let a = undefined; // anyconst b = undefined; // anylet c = null; // anyconst d = null; // any 声明为 null 类型，但未赋值，默认值为 undefined` 而不是 null12let x:null;console.log(x) // 输出 undefined 而不是 null Object 与 objectObject广义对象，少用。除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型。 12345678910let obj:Object; obj = true;obj = &#x27;hi&#x27;;obj = 1;obj = &#123; foo: 123 &#125;;obj = [1, 2];obj = (a:number) =&gt; a + 1;obj = undefined; // 报错obj = null; // 报错 另外，空对象&#123;&#125;是Object类型的简写形式，所以使用Object时常常用空对象代替 1let obj:&#123;&#125;; // 等价于 let obj:Object; 上面示例中，变量obj的类型是空对象&#123;&#125;，就代表Object类型。 显然，无所不包的Object类型既不符合直觉，也不方便使用。 object 类型狭义对象，常用。只包含对象、数组和函数，不包括原始类型的值。大多数时候，我们使用的是 object 而不是 Object 12345678let obj:object; obj = &#123; foo: 123 &#125;;obj = [1, 2];obj = (a:number) =&gt; a + 1;obj = true; // 报错obj = &#x27;hi&#x27;; // 报错obj = 1; // 报错 值类型与联合类型1234// x 的类型是 &quot;https&quot;const x = &#x27;https&#x27;;// y 的类型是 stringconst y:string = &#x27;https&#x27;; 变量x是const命令声明的，TypeScript 就会推断它的类型是值https，而不是string类型。 值类型一般不会单独使用，而是结合联合类型，表示值的枚举 12345let setting:true|false;let gender:&#x27;male&#x27;|&#x27;female&#x27;;let rainbowColor:&#x27;赤&#x27;|&#x27;橙&#x27;|&#x27;黄&#x27;|&#x27;绿&#x27;|&#x27;青&#x27;|&#x27;蓝&#x27;|&#x27;紫&#x27;; 上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，true|false其实就是布尔类型boolean 联合类型除了和值类型一起使用，也可用于多种类型 1234let name:string|number;name = &#x27;John&#x27;;name = 3; “类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing） 123456789function printId( id:number|string) &#123; if (typeof id === &#x27;string&#x27;) &#123; console.log(id.toUpperCase()); &#125; else &#123; console.log(id); &#125;&#125; 或 12345678910function getPort( scheme: &#x27;http&#x27;|&#x27;https&#x27;) &#123; switch (scheme) &#123; case &#x27;http&#x27;: return 80; case &#x27;https&#x27;: return 443; &#125;&#125; type 命令type命令用来定义一个类型的别名 123type Age = number;let age:Age = 55; type 不允许重名 12type Color = &#x27;red&#x27;;type Color = &#x27;blue&#x27;; // 报错 数组JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple） 数组的 TS 声明TypeScript 数组有一个根本特征：所有成员的类型必须相同 123let arr:number[] = [1, 2, 3]; // 普通写法，推荐// 或let arr:Array&lt;number&gt; = [1, 2, 3]; // 泛型写法 数组的 TS 类型推断如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是any[]。 12// 推断为 any[]const arr = []; 后面，为这个数组赋值时，TypeScript 会自动更新类型推断。 12345678const arr = [];arr // 推断为 any[]arr.push(123);arr // 推断类型为 number[]arr.push(&#x27;abc&#x27;);arr // 推断类型为 (string|number)[] 如果初始值不是空数组，类型推断就不会更新。 1234// 推断类型为 number[]const arr = [123];arr.push(&#x27;abc&#x27;); // 报错 多维数组TypeScript 使用T[][]的形式，表示二维数组，T是最底层数组成员的类型。 12var multi:number[][] = [[1,2,3], [23,24,25]]; 元组元组和数组最大的区别就是，元组的各个成员的类型可以不同。因此它必须明确声明每个成员的类型 1const s:[string, string, boolean] = [&#x27;a&#x27;, &#x27;b&#x27;, true]; 元组成员的类型可以添加问号后缀（?），表示该成员是可选的，但必须处于必选成员之后 12345678type myTuple = [ number, number, number?, string?];const s:myTuple = [1,2,3] // 正确 由于类型声明是必须的，所以大多数情况元组的元素个数是确定的，但也有例外 123type t1 = [string, number, ...boolean[]];type t2 = [string, ...boolean[], number];type t3 = [...boolean[], string, number];","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/TSC 是什么/","text":"背景RN 项目中可以使用 yarn tsc 来进行 TS 文件的检查。什么是 tsc 呢？ tsc 是 TypeScript 编译器，用于将 TypeScript 代码转换为 JavaScript 代码。它帮助开发者在编译阶段发现错误，，如类型不匹配、未定义的变量等，以提高代码质量和可维护性 tsc 的安装1yarn global add typescript tsc 的基础使用安装 tsc ，使用以下命令编译 TypeScript 文件，生成对应的 JavaScript 文件 1tsc your-file.ts tsc 的进阶使用tsc 还支持其他选项和配置，可以通过 tsc --help 查看。这些选项可以在配置文件中指定 tsc 的配置文件是一个名为 tsconfig.json 的文件，它用于配置 TypeScript 编译器的行为。通过配置文件，你可以指定编译器的选项、编译输出的目录结构以及其他一些配置。 在项目的根目录下创建一个名为 tsconfig.json 的文件，并在其中指定你想要的配置选项。以下是一个简单的 tsconfig.json 示例： 12345678910111213141516171819202122232425&#123; &quot;compilerOptions&quot;: &#123; &quot;allowJs&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;esModuleInterop&quot;: true, &quot;isolatedModules&quot;: true, &quot;jsx&quot;: &quot;react&quot;, &quot;lib&quot;: [&quot;es6&quot;], &quot;moduleResolution&quot;: &quot;node&quot;, &quot;noEmit&quot;: true, &quot;strict&quot;: true, &quot;target&quot;: &quot;esnext&quot;, &quot;resolveJsonModule&quot;: true, &quot;skipLibCheck&quot;: true, &quot;allowUnusedLabels&quot;: true, &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123;&quot;@common/*&quot;: [&quot;./common/*&quot;]&#125; &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;babel.config.js&quot;, &quot;metro.config.js&quot;, &quot;jest.config.js&quot;, ]&#125; allowJs允许编译器编译 JavaScript 文件（.js）。 当 allowJs 设置为 true 时，编译器将会编译项目中的 JavaScript 文件，而不仅仅是 TypeScript 文件。 这意味着你可以在一个 TypeScript 项目中混合使用 JavaScript 和 TypeScript 文件。这个选项的主要作用是允许你逐步迁移现有的 JavaScript 代码到 TypeScript，而无需一次性将所有文件都转换为 TypeScript。你可以先将项目中的 JavaScript 文件保留下来，并在需要的时候逐个进行类型检查和适当的类型注解。 需要注意的是，当 allowJs 设置为 true 时，编译器将尝试对 JavaScript 文件进行类型检查，但由于 JavaScript 是一种动态类型语言，编译器无法推断出变量的具体类型。 因此，在 JavaScript 文件中，你可能需要手动添加类型注解来帮助编译器进行类型检查。 allowSyntheticDefaultImports允许在没有默认导出的模块中使用默认导入。 在 JavaScript 中，一个模块可以通过默认导出（default export）或命名导出（named export）的方式暴露其功能。默认导出是指模块中的主要导出，而命名导出是指通过具体名称导出的功能。 然而，在某些情况下，某个模块可能没有默认导出，而只有命名导出。当你尝试使用默认导入语法导入这样的模块时，TypeScript 编译器会发出一个错误，因为它默认情况下假设每个模块都有一个默认导出。 通过将 allowSyntheticDefaultImports 设置为 true，你告诉编译器允许在没有默认导出的模块中使用默认导入语法。编译器会在背后生成额外的代码来模拟默认导入的行为。 这个选项的主要作用是提供更好的互操作性，允许你在使用第三方库或模块时更自由地使用默认导入语法，而不需要担心是否存在默认导出 esModuleInterop允许在导入模块时使用 CommonJS 或 AMD 的默认导出语法。 在 JavaScript 中，有两种主要的模块系统：CommonJS 和 AMD。它们在导出和导入模块时使用不同的语法。当 esModuleInterop 设置为 true 时，TypeScript 编译器会生成额外的代码来兼容使用 CommonJS 或 AMD 的默认导出语法的模块。这样，你可以在 TypeScript 代码中使用更简洁的默认导入语法，而不需要手动进行转换。 具体来说，当你使用 import 语句导入一个模块时，如果该模块使用 CommonJS 或 AMD 的默认导出语法，编译器会自动进行转换，以确保导入的模块能够正确地被使用。它简化了在 TypeScript 代码中导入模块的语法，使代码更加清晰和易读。 isolatedModules将每个文件作为单独的模块进行编译，而不是将它们合并到一个文件中。 为 true 时，编译器会将每个文件视为独立的模块，并且会在每个文件中执行严格的模块化检查。这意味着在一个文件中无法使用另一个文件中定义的变量、函数或类，除非通过导入模块的方式进行访问。 这个选项的主要目的是帮助开发者遵循模块化的最佳实践，确保代码的可维护性和可重用性。通过将每个文件作为独立的模块进行编译，可以减少全局命名空间的污染，强制使用显式的导入和导出语法，以及更好地检测潜在的命名冲突和依赖关系问题。 需要注意的是，当 isolatedModules 设置为 true 时，你需要确保每个文件都使用了适当的导入和导出语法，以便在文件之间进行正确的模块依赖关系。否则，编译器会发出错误。 jsx指定 JSX 的转换方式，这里设置为 “react”，表示使用 React 的 JSX 语法。RN 项目都如此设置 lib指定编译时可用的库文件，这里只包含 “es6”，表示使用 ES6 标准库来进行编译检查。RN 项目都如此设置 lib 选项用于指定编译器可以使用的 JavaScript 标准库的集合。标准库提供了一组预定义的类型定义和运行时功能，供 TypeScript 编译器使用 moduleResolution指定模块解析策略，这里设置为 “node”，表示使用 Node.js 的模块解析方式。RN 项目都如此设置 noEmit不生成编译输出文件，只进行类型检查。非常常用 strict启用所有严格的类型检查选项。无脑选 true target编译后的 JavaScript 代码的目标版本，这里设置为 “esnext”，表示生成符合最新 ECMAScript 版本的 JavaScript 代码。 resolveJsonModule允许导入 JSON 文件作为模块。如果项目中导入了 JSON 文件需要开启这个 skipLibCheck跳过对声明文件的检查，可以加快编译速度。也就是跳过了三方库的检查 allowUnusedLabels允许存在未使用的标签 baseUrl指定模块解析的基础路径，默认为当前目录。与 paths 配合使用，实现绝对路径的导入 paths配置模块的路径映射。与 baseUrl 配合使用，实现绝对路径的导入 如何防劣化只要在 package.json 中 hook，在每次 Git 提交前检查 tsc 即可 安装 husky 1yarn add -D husky 在 package.json 中配置 12345&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;yarn tsc&quot; &#125;&#125;,","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/npx 是什么/","text":"npx 主要有两个作用 作用 1：调用项目安装的模块如果要在命令行中调用 node_modules 中的模块，使用 npx 之前，你需要 12# 项目的根目录下执行$ node-modules/.bin/mocha --version 使用 npx 之后，你只需 1npx mocha --version 其原理是运行的时候，会到 node_modules/.bin 路径和环境变量 $PATH 里面，检查命令是否存在。 由于 npx 会检查环境变量$PATH，所以系统命令也可以调用 如 1npx ls 注意，Bash 内置的命令不在 $PATH 中，所以 npx cd 无效 作用 2：避免全局安装模块如开发 react-native 时使用的 pod-install 1npx pod-install 虽然我本机没有安装 pod-install 模块，但是使用 npx 可以直接运行，其原理是先把该模块下载到临时目录，使用以后再删除 小技巧：临时切换 node 版本1npx node@0.12.8 -v 小技巧：执行 Github 源码12345# 执行 Gist 代码$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32# 执行仓库代码$ npx github:piuccio/cowsay hello 参考 阮一峰老师的 npx 使用教程","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/peerDependencies 是什么/","text":"假设现在有一个 helloWorld 工程，已经在其 package.json 的 dependencies 中声明了 packageA，有两个插件 plugin1 和 plugin2 他们也依赖 packageA，如果在插件中使用 dependencies 而不是 peerDependencies 来声明 packageA，那么 npm install 安装完 plugin1 和 plugin2 之后的依赖图是这样的： 12345678910.├── helloWorld│ └── node_modules│ ├── packageA│ ├── plugin1│ │ └── nodule_modules│ │ └── packageA│ └── plugin2│ │ └── nodule_modules│ │ └── packageA 从上面的依赖图可以看出，helloWorld 本身已经安装了一次 packageA，但是因为因为在plugin1 和 plugin2 中的 dependencies 也声明了 packageA，所以最后 packageA 会被安装三次，有两次安装是冗余的。 而 peerDependencies 就可以避免类似的核心依赖库被重复下载的问题。 如果在 plugin1 和 plugin2 的 package.json 中使用 peerDependencies 来声明核心依赖库，例如： plugin1/package.json 12345&#123; &quot;peerDependencies&quot;: &#123; &quot;packageA&quot;: &quot;1.0.1&quot; &#125;&#125; plugin2/package.json 12345&#123; &quot;peerDependencies&quot;: &#123; &quot;packageA&quot;: &quot;1.0.1&quot; &#125;&#125; 在主系统中声明一下 packageA: helloWorld/package.json 12345&#123; &quot;dependencies&quot;: &#123; &quot;packageA&quot;: &quot;1.0.1&quot; &#125;&#125; 此时在主系统中执行 npm install 生成的依赖图就是这样的： 123456.├── helloWorld│ └── node_modules│ ├── packageA│ ├── plugin1│ └── plugin2 可以看到这时候生成的依赖图是扁平的，packageA 也只会被安装一次。 因此我们总结下在插件使用 dependencies 声明依赖库的特点： 如果用户显式依赖了核心库，则可以忽略各插件的 peerDependencies 声明； 如果用户没有显式依赖核心库，则打包会报错 当用户依赖的版本、各插件依赖的版本之间不相互兼容，会报错让用户自行修复； 最后，如果你是组件的开发者，在开发组件时需要把 packageA 加到 devDependencies，这样你在开发时才能读到这个 packageA 这个库，因为 peerDependencies 在 yarn 的时候是不会帮你安装依赖的","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/yarn 时指定 Node 版本/","text":"执行 yarn 时可能遇到 Node 版本不匹配 1The engine &quot;node&quot; is incompatible with this module. Expected version &quot;14 || &gt;=16.14&quot;. Got &quot;16.13.2&quot; 此时我们可以通过 nvm 来安装对应的 Node 版本，并使用 123nvm install 16.14.2nvm use 16.14.2node -v 如果需要在项目中指定 Node 的版本，让别人 clone 时能遵循这个 Node 的版本限制，可以创建 .nvmrc 文件来强制指定该项目的 Node 版本 1echo v16.14.2 &gt; .nvmrc","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/移动端适配/","text":"常用方案 媒体查询 https://github.com/Norcy/wiki/commit/923735e175cd300292eedb93557c18a490e720a6 https://github.com/Norcy/wiki/commit/956a0f3029d5d6431eed2191933a47961cabcdc1 使用 postcss-px-to-viewport https://juejin.cn/post/6959047144065990663","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/给三方模块打补丁/","text":"如果是 node_modules 下的三方模块使用 patch-package 工具即可 Step1：安装注意只在 dev 下生效即可 1yarn add patch-package --dev Step2：创建补丁 修改 node_modules 下的三方代码 根目录下执行以下代码即可创建 patches 补丁文件夹，其中 TargetPackageName 为你要修改的三方模块的名字 1npx patch-package TargetPackageName Step3：添加自动化脚本package.json 的 scripts 中添加代码 &quot;postinstall&quot;: &quot;patch-package&quot;，最终效果如下图 123456789101112&#123; ... &quot;scripts&quot;: &#123; &quot;android&quot;: &quot;react-native run-android&quot;, &quot;ios&quot;: &quot;react-native run-ios&quot;, &quot;start&quot;: &quot;react-native start&quot;, &quot;test&quot;: &quot;jest&quot;, &quot;lint&quot;: &quot;eslint .&quot;, &quot;postinstall&quot;: &quot;patch-package&quot; // 此处是新增代码 &#125;, ...&#125; Step4：提交到 Git将 patches 文件夹和 package.json 的修改提交到 Git 即可 如果该模块在 Pods 下但不在 node_modules使用 cocoapods-patch 工具 Step1：安装Gemfile 中添加 1gem &#x27;cocoapods-patch&#x27; 然后执行 1bundle install Step2：创建补丁pod install 后，修改 Pods 中三方模块的代码 然后创建补丁 1pod patch create XXX Step3：自动应用补丁在 Podfile 中添加 1plugin &#x27;cocoapods-patch&#x27; 这样，每次执行 pod install 后，都会自动应用补丁 注意事项 patch 文件可能含有 .DS_Store 文件，需要手动删除 自测补丁的时候，如果 patch 文件有多个补丁，Pods 源码需要同时删除所有补丁再应用才能成功。也就是说，如果一个库有多个补丁，只要一个应用出错，那么这个库的所有补丁都不会生效","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/节流与防抖/","text":"节流 throttle定义n 秒内频繁调用多次时，只执行第一次调用（也可以选择定时结束时执行） 举例如下，疯狂点击按钮，1 秒内只会执行一次，且这一次为 1 秒内的第一次点击 123456import &#123;throttle&#125; from &#x27;lodash&#x27;;&lt;Button onPress=&#123;throttle(_onSave, 1000, &#123;leading: true, trailing: false&#125;)&#125; title=&#123;&#x27;保存&#x27;&#125;/&gt; leading = true, trailing = true：默认情况。执行第一次调用，如果有多次，则定时结束后再执行一次。不建议。 leading = true, trailing = false：执行第一次调用。建议。 leading = false, trailing = true：定时结束后次调用一次。不建议。 leading = false, trailing = false：永不触发回调。不建议。 应用 按钮点击跳页面，以第一次为准就够了 滚动到底部加载更多 防抖 debounce定义n 秒内频繁调用多次时，只执行最后一次调用（定时结束时无新调用即为最后一次） 举例如下，疯狂拖动进度条，拖动后只要 0.01 秒内发生过拖动，则上一次的 onProgressValueChange 会被取消，若 0.01 秒内没有拖动，则上一次的 onProgressValueChange 才会被调用 12345import &#123;debounce&#125; from &#x27;lodash&#x27;;&lt;Slider onValueChange=&#123;debounce(onProgressValueChange, 10)&#125;/&gt; 应用 进度条的频繁拖动，以最后一次为准 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 坑当应用进入后台时，如果 JavaScript 线程被暂停，那么被 debounce 延迟的回调可能就没机会执行了，比如下方的代码，进前台会打印，但是退后台就不会 1234const _handleAppStateChange = debounce(()=&gt;&#123; console.log(&#x27;123&#x27;)&#125;, 100);AppState.addEventListener(&#x27;change&#x27;, _handleAppStateChange); 总结本质上都是优化高频率执行代码的一种手段 比如，设置时间频率为 500ms，在 2 秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在 2s 后，只会执行最后一次","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/Others/GitHub Page 从 TravisCI 迁移到 GitHub Action/","text":"背景Travis CI 开始收费，导致我的 GitHub Page 的网站部署失败，转向免费又好用的 GitHub Action 我之前使用的 Hexo 来创建 GitHub Page，源代码和网站代码是放在同一个仓库的不同分支，源代码为 HexoBackup，网站代码是 master 关于 GitHub Action 的入门，参考 GitHub Actions 入门教程 步骤 申请 GitHub Token，选择永不过期，记得一定要勾选全部权限，随后复制得到的 Token，后续该 Token 将不再可见 Token 填入网站仓库的 Secret 中：仓库 -&gt; Settings -&gt; Secrets and variables -&gt; New repository secret，然后取名 HEXO_DEPLOY，填入刚复制得到的 Token，此时前置工作准备就绪 仓库的 Settings -&gt; Pages 中的 Source 更改为 Deploy from branch，当前例子中为分支的值为 master 在网站仓库的 HexoBackup 分支，新建 workflow 文件，路径为 .github/workflows/deploy.yml yml 文件使用了 theme-keep/hexo-deploy-github-pages-action插件，方便又好用。最终效果，这里真正要配置的有 4 个值，触发构建的 branch，env 中的两个值，以及 secrets 的名字 注意 Token 不知道忘了勾选哪个权限导致 Push 时鉴权失败，勾选全部权限即解决了 不要把 Token 直接写到 yml 中，而应该通过上述步骤 1 和 2 配置好，然后通过 secrets.HEXO_DEPLOY 来读取，这样可以避免泄漏，因为 Hexo 源码仓库是 Public 的","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"Hexo 特性","date":"2025-04-20T05:50:42.951Z","path":"tech/Others/Hexo 特性/","text":"一些坑 如果使用了分割线，则生成 html 失败（已经第三次踩坑），如果要用分割线，得使用 ____ 而不是 --- Travis CI 自动构建NexT 主题添加点击的爱心效果NexT 主题内接入网页在线联系功能NexT 主题中添加网页标题崩溃欺骗搞怪特效NexT 主题添加圆角效果以 Pisces 模式为例，其他模式同理 themes/next/source/css/_schemes/Pisces/_sidebar.styl 添加 border-radius 属性 12345678910111213141516.sidebar &#123; display: none; right: auto; bottom: auto; -webkit-transform: none; border-radius:10px;&#125;.sidebar-inner &#123; box-sizing: border-box; width: 240px; color: $text-color; background: white; border-radius:10px; &amp;.affix &#123; top: 0px; position: fixed; &#125;&#125; themes/next/source/css/_schemes/Pisces/_layout.styl添加 border-radius 属性 1234567.sidebar-position-right &#123; .header-inner &#123; right: 0; border-radius:10px;&#125; .content-wrap &#123; float: left; &#125; .sidebar &#123; float: right; &#125; .footer-inner:before &#123; float: right; &#125;&#125; NexT 主题添加动态背景themes/next/layout/_layout.swig 添加以下代码 1234&#123;% if theme.canvas_nest %&#125;&lt;!-- 可选配置：color=&quot;0,255,255&quot; opacity=&quot;0.7&quot; count=99 zIndex=&quot;0&quot;--&gt;&lt;script type=&quot;text/javascript&quot; color=&quot;51,163,220&quot; opacity=&quot;0.8&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 不蒜子统计","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/Others/Mac 安装 Ruby 踩坑记录/","text":"Mac 系统版本为 Sonoma 14.4.1，不小心卸载了 ruby 2.7，重装过程无比坎坷，是为记之 Google 了 2 个小时无果，关键还得感谢 Kimi 正常的安装流程 1234# 确保 rvm 最新rvm get master# 直接安装对应版本的 rubyrvm install 2.7.1 但是一直报错，总是卡在 installing，错误信息大概为 12dyld[26672]: missing symbol calledmake: *** [do-install-nodoc] Abort trap: 6 正规的解决步骤 1234567891011121314151617181920# 确保 Xcode 命令行已安装xcode-select -p# 但是还是进行了一次卸载，再重装，不确定有没有用rm -rf /Library/Developer/CommandLineTools# 重新安装 Xcode 命令行xcode-select --install# 关键：确保所有依赖安装完成，今天就是缺少了 libffi 导致一直失败brew install libyaml libffi autoconf automake libtool readline zlib# 这句不知道有没有用brew unlink openssl@3# 这句不知道有没有用rvm cleanup all# 关键，需要用 brew 查找 libffi 的位置，再拼上去export LDFLAGS=&quot;-L`brew --prefix libffi`/lib&quot;export CPPFLAGS=&quot;-I`brew --prefix libffi`/include&quot;export PKG_CONFIG_PATH=&quot;`brew --prefix libffi`/lib/pkgconfig&quot;# 关键，要带上 openssl@1.1rvm install ruby-2.7.1 --with-openssl-dir=$(brew --prefix openssl@1.1)# 这句不知道有没有用brew link openssl@3","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/ReactNative/ReactNative滑动中误点击问题优化方案/","text":"转自公司内文章 背景使用 TouchableOpacity 组件，在快速横向切换和上下滑动过程中，存在较高概率的误点击的情况 RN 的点击原理如下 方案根据以上原理，我们可以在 onPressIn 的时候记录下手势坐标，然后在 onPress 时进行判断，如果有滑动（手势在 x或者 y 方向上移动了一段距离），则不触发 onPress 事件，从而解决滑动过程中误点击的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123;useRef&#125; from &quot;react&quot;;import &#123; TouchableOpacity,&#125; from &quot;react-native&quot;;const PREVENT_DISTANCE = 2;export default function FixedTouchableOpacity(&#123; onPress, onPressIn, ...props&#125;) &#123; const _touchActivatePositionRef = useRef(null); const _onPressIn = (e: any) =&gt; &#123; const &#123; pageX, pageY &#125; = e.nativeEvent; _touchActivatePositionRef.current = &#123; pageX, pageY, &#125;; onPressIn?.(e); &#125; const _onPress = (e: any) =&gt; &#123; const &#123; pageX, pageY &#125; = e.nativeEvent; const absX = Math.abs(_touchActivatePositionRef.current.pageX - pageX); const absY = Math.abs(_touchActivatePositionRef.current.pageY - pageY); const isDragging = absX &gt;= PREVENT_DISTANCE || absY &gt;= PREVENT_DISTANCE; if (!isDragging) &#123; onPress?.(e); &#125; &#125; return ( &lt;TouchableOpacity onPressIn=&#123;_onPressIn&#125; onPress=&#123;_onPress&#125; &#123;...props&#125;&gt; &#123;props.children&#125; &lt;/TouchableOpacity&gt; );&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/ReactNative/TextInput的一个小坑/","text":"这样写，键盘的修改不会导致 value 改变，你还需要监听 onChangeText 来 setValue 12345const [value, setValue] = useState(&#x27;&#x27;)&lt;TextInput value=&#123;value&#125;&gt;&lt;/TextInput&gt; 但是这样写，就不需要监听，不需要 setValue 了 12345const [value, setValue] = useState(&#x27;&#x27;)&lt;TextInput&gt; &#123;value&#125;&lt;/TextInput&gt;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/ReactNative/memo/","text":"React.memoReact 中，当父组件的一个状态改变后，无论和子组件是否有关，子组件都会受到影响进行重新渲染，这也是 React 中默认的一个行为 使用 React.memo 可以避免子组件多余的渲染，对标类组件的 shouldComponentUpdate 优化的核心思想是，React.memo 会记住组件的输入（props），并在下一次渲染时对比新旧 props 是否发生了变化。如果 props 没有发生变化，React.memo 会阻止组件的重新渲染，直接使用之前的渲染结果 详见例子：https://snack.expo.dev/@tt123753/memo 更新父组件的状态时，即使该状态与子组件无关，子组件也会刷新，使用 memo 可以避免多余的刷新 123456789101112131415161718192021222324252627282930313233343536const Child = (&#123; prop, memo &#125;) =&gt; &#123; if (memo) &#123; console.log(&quot;Child 缓存组件渲染&quot;); &#125; else &#123; console.log(&quot;Child 组件渲染&quot;); &#125; return &lt;Text&gt;&#123;prop.age&#125;&lt;/Text&gt;;&#125;;const MemoChild = React.memo(Child);export default function App() &#123; const [parentData, setParentData] = React.useState(0); const [childData, setChildData] = React.useState(&#123; age: 24, &#125;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; setParentData(parentData + 1)&#125;&gt; &#123;/*只触发 Child*/&#125; &lt;Text&gt;&#123;&quot;Update Parent Data&quot;&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; setChildData(&#123; age: childData.age + 1 &#125;); &#125;&#125; &gt; &#123;/*触发 Child 和 MemoChild*/&#125; &lt;Text&gt;&#123;&quot;Update Child Data&quot;&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Child prop=&#123;childData&#125; /&gt; &lt;MemoChild memo prop=&#123;childData&#125; /&gt; &lt;/View&gt; );&#125; 但如果子组件是定义在父组件中，那么每次父组件刷新时，子组件总是会重新渲染，即使加了 memo，这一点要特别注意 12345678910111213141516171819202122232425export default function App() &#123; const [parentData, setParentData] = React.useState(0); const Child = (&#123; prop, memo &#125;) =&gt; &#123; if (memo) &#123; console.log(&quot;Child 缓存组件渲染&quot;); &#125; else &#123; console.log(&quot;Child 组件渲染&quot;); &#125; return &lt;Text&gt;&#123;prop.age&#125;&lt;/Text&gt;; &#125;; const MemoChild = React.memo(Child); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; setParentData(parentData + 1)&#125;&gt; &#123;/*触发 Child 和 MemoChild*/&#125; &lt;Text&gt;&#123;&quot;Update Parent Data&quot;&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Child prop=&#123;childData&#125; /&gt; &lt;MemoChild memo prop=&#123;childData&#125; /&gt; &lt;/View&gt; );&#125; React.memo 的对比函数 memo 默认使用了浅对比，什么是浅对比？即只要引用的对象变了，就会触发刷新，但其实这种刷新可能是多余的。 如下例，如果不引入 isEqual 函数， 1234567891011121314151617181920212223242526272829303132333435363738const isEqual = (prevProps, nextProps) =&gt; &#123; return prevProps.age == nextProps.age;&#125;;const Child = (&#123; prop, memo &#125;) =&gt; &#123; if (memo) &#123; console.log(&quot;Child 缓存组件渲染&quot;); &#125; else &#123; console.log(&quot;Child 组件渲染&quot;); &#125; return &lt;Text&gt;&#123;prop.age&#125;&lt;/Text&gt;;&#125;;const MemoChild = React.memo(Child, isEqual);export default function App() &#123; const [childData, setChildData] = React.useState(&#123; age: 24, &#125;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; &#123; /*age 的值其实没有改变，但是 MemoChild 引用的对象变了*/ &#125; setChildData(&#123; age: childData.age &#125;); &#125;&#125; &gt; &#123;/*引入 isEqual 后只触发 Child，否则两个都触发*/&#125; &lt;Text&gt;&#123;&quot;Update Child Data&quot;&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Child prop=&#123;childData&#125; /&gt; &lt;MemoChild memo prop=&#123;childData&#125; /&gt; &lt;/View&gt; );&#125; 不适用 React.memo 的情况 props 每次都会改变的组件，不要使用 React.memo，使用 React.memo 只会带来不必要的新旧 props 比较和无意义的缓存 组件如果很简单，不建议使用 React.memo，并不能带来多大提升，而使用 React.memo 本身就有心智负担 React.memo 只能针对函数组件，对于普通函数的优化得用 useMemo 配合 useCallback 完成优化https://juejin.cn/post/7107943235099557896 改造前：刷新与 Child 无关的 Parent 属性时，Child 会触发渲染，原因是每次刷新时，传入 Child 的函数都会重新构建，而 Memo 比较的是函数的地址，所以会重刷 Child 1234const calRef = useRef(null);return ( &lt;MemoChild ref=&#123;(ref) =&gt; &#123;chartRef.current = ref&#125;&#125; /&gt;;) 改造后：解决方法是使用 useCallback 保证函数地址不变，从而不会触发 Memo 的刷新。改造后刷新与 Child 无关的 Parent 属性时，Child 不再触发渲染 12345678const calRef = useRef(null);const setChartRef = useCallback((ref) =&gt; &#123; chartRef.current = ref;&#125;, []);return ( &lt;MemoChild ref=&#123;setChartRef&#125; /&gt;;) 需要注意的是，使用 useCallback 会导致原函数捕捉的 state 不再改变，因此如果原函数需要读取 Parent 的 state 时，需要特殊处理下，有两种方法 方法 1：将 state 作为原函数参数传入，在调用该函数时，传入最新的 state 即可 12const [count, setCount] = useState(0)const foo = useCallback((count) =&gt; console.log(count), []) 方法 2：将 state 作为 useCallback 的第二个依赖参数传入，这样当 state 改变时，useCallback 会重新触发原函数的生成 12const [count, setCount] = useState(0)const foo = useCallback(() =&gt; console.log(count), [count]) useMemo某些场景下，我们只是希望 component 的局部不要重新渲染，而不是整个组件不重新渲染，此时就得用到 useMemo；另外 React.memo 针对的是函数式组件，如果要优化普通的函数执行，则得依赖 useMemo 一句话总结 useMemo 的作用就是，减少组件重新渲染时不必要的函数计算 注意一些简答的计算比如 for 循环相加 1000 次这种简单的函数就不要使用 useMemo 了，必须是复杂的函数运算才值得用 useMemo 的基础用法如下 1const memoizedValue = useMemo(() =&gt; return a+b, [a, b]); useMemo 接收两个参数，后者是一个数组，类比 useState，当数组内的元素发生变化时才会调用前者传入的函数 我们假设 calculateName 是一个非常耗时的函数。如下代码，每次更改 age 时都会导致 calculateName 的调用 12345678910111213141516171819202122232425262728293031323334353637const Child = (&#123; prop &#125;) =&gt; &#123; const &#123; age, name &#125; = prop; &#123; /*假如这个函数的运算非常复杂*/ &#125; const calculateName = (name) =&gt; &#123; console.log(&quot;calculateName&quot;); return name + &quot;123&quot;; &#125;; const realName = calculateName(name); return ( &lt;&gt; &lt;Text&gt;&#123;age&#125;&lt;/Text&gt; &lt;Text&gt;&#123;realName&#125;&lt;/Text&gt; &lt;/&gt; );&#125;;export default function App() &#123; const [childData, setChildData] = React.useState(&#123; age: 24, name: &quot;Mike&quot;, &#125;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; setChildData(&#123; age: childData.age + 1, name: &quot;Mike&quot; &#125;); &#125;&#125; &gt; &lt;Text&gt;&#123;&quot;Update Child Data&quot;&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Child prop=&#123;childData&#125; /&gt; &lt;/View&gt; );&#125; 由于 calculateName 只与 name 有关，age 改变重新执行 calculateName 是多余的，因此这种情况下可以使用 useMemo 来减少 calculateName 的调用 12345678910111213141516171819202122232425262728293031323334353637const Child = (&#123; prop &#125;) =&gt; &#123; const &#123; age, name &#125; = prop; &#123; /*假如这个函数的运算非常复杂*/ &#125; const calculateName = (name) =&gt; &#123; console.log(&quot;calculateName&quot;); return name + &quot;123&quot;; &#125;; const realName = React.useMemo(() =&gt; calculateName(name), [name]); return ( &lt;&gt; &lt;Text&gt;&#123;age&#125;&lt;/Text&gt; &lt;Text&gt;&#123;realName&#125;&lt;/Text&gt; &lt;/&gt; );&#125;;export default function App() &#123; const [childData, setChildData] = React.useState(&#123; age: 24, name: &quot;Mike&quot;, &#125;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; setChildData(&#123; age: childData.age + 1, name: &quot;Mike&quot; &#125;); &#125;&#125; &gt; &lt;Text&gt;&#123;&quot;Update Child Data&quot;&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Child prop=&#123;childData&#125; /&gt; &lt;/View&gt; );&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/ReactNative/如何在 JS import 绝对路径/","text":"背景引入项目中的模块时，默认使用了相对路径，由于 i18n 需要批量替换 import，而每个文件相对 i18n 模块的位置不一样，那此时就无法完成批量替换 解决方法是使用绝对路径来 import 模块 Before 1import i18n from &#x27;../common/other/i18n&#x27;; After 1import i18n from &#x27;@common/other/i18n&#x27;; 方法 安装 babel 插件 1yarn add babel-plugin-module-resolver -D babel.config.js 中使用插件，如下的 plugins 信息 123456789101112131415module.exports = &#123; presets: [&#x27;module:metro-react-native-babel-preset&#x27;], plugins: [ [ &#x27;module-resolver&#x27;, &#123; extensions: [&#x27;.js&#x27;, &#x27;.jsx&#x27;, &#x27;ts&#x27;, &#x27;tsx&#x27;], root: [&#x27;.&#x27;], alias: &#123; &#x27;@common&#x27;: &#x27;./common&#x27;, &#125;, &#125;, ], ],&#125;; 为了能够实现在 VSCode 中点击跳转，还需要配置 tsconfig.json（如果是 js 工程使用 js.config.json） 在 compilerOptions 中新增 baseUrl 和 paths 123456&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123;&quot;@common/*&quot;: [&quot;./common/*&quot;]&#125; &#125;&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/ReactNative/如何在函数组件里模拟构造函数/","text":"转自公司内大佬的文章，深入浅出的写法值得学习 TLDR源码实现 12345/** 可在同一函数重复多次使用，互不干扰 */export function useSingleton&lt;T&gt;(callBack: () =&gt; T): T &#123; const [T] = useState(callBack); return T&#125; 使用例子 12345678910111213141516171819202122function Example() &#123; // 不带返回值，只会触发一次，相比 useEffect，该函数会在 render 之前触发 useSingleton(() =&gt; &#123; console.log(&#x27;init before render once&#x27;); &#125;); // 带返回值 const store:IStore = useSingleton(()=&gt;&#123; return new FileStore(); &#125;); const [count, setCount] = useState(store.get(&#x27;click_count&#x27;)); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 特点 可以模拟构造函数，只有一次调用 可以在渲染之前调用 有返回值时，多次调用的返回值结果一样，就像单例函数 详细说明函数组件是 React 推出的新的组件形式，让写组件变得简单些，它抛弃了复杂的生命周期回调，专注于展示和数据监听。下面这是一个例子： 1234567891011121314import React, &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 函数组件返回一个样式，react 会在每次数据变化的时候就调用一次此方法获取最新样式。大部分情况，函数组件都能满足需求。但有一个业务场景函数组件不支持，就是构造函数。函数组件实际是一个函数，自然肯定没有 class 的构造函数。那对一些一次性的初始化逻辑该如何实现呢？React 的官方解释是函数组件不需要构造函数，因为状态初始化可以用 useState。 官方解释对不对是值得商榷的，因为初始化阶段不只是状态初始化，也会包含一些业务逻辑。那既然官方不准备支持，那我们有什么办法模拟呢？首先我们能想到的是 useEffect 方法。useEffect 会在 render 结束后调用(useLayoutEffect同理，只是时机不同)。它会接受第二个参数，只关注某些状态变化才调用。利用这一点，我们可以传入空数组，也就是只关注第一次： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, []); //此时只会在第一次渲染后调用。 这样的实现基本满足我们只执行一次的要求，但有一个缺点，执行的时机是在渲染后，我们有时候会想在渲染前作准备。要适应这种场景，我们可以用 useState 来模拟，设置一个标志位来来表示是不是第一次执行。可以写一个自定义 hook 工具方法： 123456const useConstructor(callBack = () =&gt; &#123;&#125;) =&gt; &#123; const [hasBeenCalled, setHasBeenCalled] = useState(false); if (hasBeenCalled) return; callBack(); setHasBeenCalled(true);&#125; 这样，我们在函数组件第一行调用这个方法，包住初始化逻辑就能满足在渲染前调用: 123456789101112131415function Example() &#123; useConstructor(()=&gt;&#123; // 初始化逻辑 &#125;); const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 这样是不是完美模拟了呢？其实还是有两个小缺点： 调用 setHasBeenCalled 会触发一次不必要的刷新； useConstructor 命名不合适，因为不是真的构造函数，实际调用点是靠使用方在什么时候调用；基于这两点，我们可以优化一下成这样： 123456const useSingleton = (callBack = () =&gt; &#123;&#125;) =&gt; &#123; const hasBeenCalled = useRef(false); if (hasBeenCalled.current) return; callBack(); hasBeenCalled.current = true;&#125; 这个函数实际是一个单例函数，确保传入的函数只执行一次。useRef 可以理解为函数组件的全局变量，对它修改不会触发刷新。这里有一点需要说一下，useSingleton 是可以在同一个函数组件里多次使用，useRef 会每次都生成新的变量，React 会保证不会相互干扰并正确执行。 这个模拟构造函数还能不能进一步优化呢，比如期望 useSingleton 有返回值，一次执行，每次都获取相同的结果？可以的。根据 Reactjs 官方文档的惰性初始State， 可以给 useState 传函数，并且只会在第一次初始化时调用。所以我们可以进一步优化 useSingleton，再加上考虑返回值的话，最终版以及用法见文章开头 参考：https://dev.to/bytebodger/constructors-in-functional-components-with-hooks-280m","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/FrontEnd/ReactNative/如何调试一个未发布的RN组件/","text":"背景当开发一个新的 RN 组件时，发布之前可能需要经过业务场景的测试。如何测试才能更高效呢？ 这里涉及两个路径，用以下字符串代替 开发中的组件的路径：/path/to/my-package 想引用该组件的工程的路径：/path/to/my-project 最佳实践：使用 wmlwml 的本质就是监听指定文件的变化，然后及时复制该文件到你指定的地方 所以在我们这个场景，就是利用 wml 把组件的代码自动复制到工程目录下的 node_modules Step 1. 安装并配置 wmlwml 官方文档 12yarn global add wml # 全局安装 wmlwatchman watch `yarn global dir`/node_modules/wml/src # 确保能被 watchman 监听 如果安装之后，wml 依然提示找不到，原因可能是 iTerm 的配置文件的 Path 里面没有包含 yarn global 的执行路径，只需要在 ~/.zshrc 中添加以下代码即可 1PATH=&quot;$PATH:`yarn global bin`&quot; Step 2. 开始使用 wml12wml add /path/to/my-package /path/to/my-project/node_modules/my-package #指定复制规则wml start # 开始监听并复制 start 之后记得随意修改下组件，这样就能触发自动复制 记得 node_modules 后面还需要加上组件名字 附录 wml 其他常用方法 1234wml ls # 列出当前的复制规则wml rm [linkId/all]wml enable [linkId]wml disable [linkId] Step 3. 可选：如果是原生组件，你还需要安装原生依赖跟普通的原生组件类似，你需要安装原生依赖，然后重新安装 App 如果该组件是新增的，记得在 package.json 中引用到，版本写为 “*” 就可以了，不然 pod install 的时候找不到该组件 1npx pod-install # For iOS 不推荐的方法使用 npm link 或 yarn link1234cd /path/to/my-packageyarn linkcd /path/to/my-projectyarn link my-package 然后你可以在工程中这样使用 123const &#123; someMethod &#125; = require(&#x27;my-awesome-package&#x27;);// ... orimport &#123; someMethod &#125; from &#x27;my-awesome-package&#x27;; 最终你会发现这样的错误 123error: Error: Unable to resolve module my-package from /Users/mac/MyReactNativeApp/src/App.tsx: my-package could not be found within the project or in these directories:node_modules../../node_modules 因为 yarn link 的原理就是在 node_modules 中创建组件文件夹的软链，而 RN 默认使用的 metro 不支持这种，详细请看 这篇文章 修改 Metro 配置修改 metro.config.js，确保组件模块能被解析；同时添加 watchman 监听 12345678910const packagePath = &#x27;/path/to/my-package&#x27;;module.exports = &#123; resolver: &#123; nodeModulesPaths: [packagePath], // rest of metro resolver options... &#125;, watchFolders: [packagePath], // rest of metro options...&#125;; 然后在你的工程中这样引入 1yarn add /path/to/my-package 经测试，这种方法会导致运行报错 参考 《Linking Local Packages in React Native the Right Way》 解决 WML 失效","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/Others/Python/Python 实战/","text":"下载 KM 图书知识点：网络 Get 请求；文件读写；Markdown 转 PDF 深圳新冠疫苗放号监控知识点：网络 Post/Get 请求；定时任务；微信推送 照片命名整理神器知识点：使用 argparse 库，进行人性化的参数解析","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Python","slug":"tech/Others/Python","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/Others/Python/周边/切换 Mac Python 版本/","text":"切换 Mac Python 版本12python3 --version # pip 21.0.1 from /usr/local/lib/python3.8/site-packages/pip (python 3.8) 解决方法，打开 ~/.zshrc，添加环境变量 1234# 修改前export PATH=&quot;$HOME/.yarn/bin:$HOME/.config/yarn/global/node_modules/.bin:$PATH&quot;# 修改后export PATH=&quot;$HOME/.yarn/bin:$HOME/.config/yarn/global/node_modules/.bin:/usr/local/opt/python@3.9/bin:$PATH&quot; 12python3 --version # pip 21.0.1 from /usr/local/lib/python3.9/site-packages/pip (python 3.9)","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Python","slug":"tech/Others/Python","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/"},{"name":"周边","slug":"tech/Others/Python/周边","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/%E5%91%A8%E8%BE%B9/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/Others/Python/周边/参数解析神器/","text":"https://www.jianshu.com/p/409bfa57608e 详细可见 https://github.com/Norcy/photo_rename.git","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Python","slug":"tech/Others/Python","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/"},{"name":"周边","slug":"tech/Others/Python/周边","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/%E5%91%A8%E8%BE%B9/"}]},{"title":"","date":"2025-04-20T05:50:42.951Z","path":"tech/Others/Python/语法/Python 参数/","text":"方法一、arvg参数获取12345import sys print(sys.argv[0]) ## 脚本名 print(sys.argv[1]) ## 第一个参数，后面以此类推print(len(sys.argv)) ## 参数个数 方法二、getopt模块获取getopt 模块是专门用来处理命令行参数的，里面的提供了2个函数和一个类，我们主要使用getopt函数，原型为: 1def getopt(args, shortopts, longopts = []): 调用语句为: 1opts, args = getopt.getopt(sys.argv[1:], &quot;ho:&quot;, [&quot;help&quot;， &quot;output=&quot;]) 参数解释有两种格式的参数，一种为短参数，如&quot;-h&quot;；另外一种是长参数，如&quot;--version&quot; 参数后面又要区分，是否带了入参值，如查看help命令，只需要”-h”，就是不需要带入参值； 如果是输入ip，如”-i 127.0.0.1”，这个就是带了入参值 短参数中，需要输入的如入参名后面加了冒号&quot;:&quot;，表明需要带参数，不加冒号则表明不要， 如上面的例子，短参数为&quot;ho:&quot;，表明有两个短参数，&quot;-h&quot;，&quot;-o&quot;，其中&quot;-o&quot;需要后面接参数 长参数中，后面如果接了等号&quot;=&quot;，表明需要带参数，不加则表明不要 如上面的例子，长参数为[&quot;help&quot;， &quot;output=&quot;]，表明有两个长参数，一个&quot;--help&quot;，不需要后面带参数；一个&quot;--output&quot;，需要后面带参数 返回值调用getopt 函数函数返回两个列表：opts 和args opts 为分析出的格式信息 args 为不属于格式信息的剩余的命令行参数(即那些不含”-/–”的参数) opts 是一个两元组的列表每个元素为：(选项串，附加参数）如果没有附加参数则为空串’’ 比如 1&#x27;-h -o file --help --output=out file1 file2&#x27; opts 应该是： 1[(&#x27;-h&#x27;, &#x27;&#x27;)， (&#x27;-o&#x27;, &#x27;file&#x27;)， (&#x27;--help&#x27;, &#x27;&#x27;)， (&#x27;--output&#x27;, &#x27;out&#x27;)] args 则为： 1[&#x27;file1&#x27;, &#x27;file2&#x27;] 例子12345678910111213141516171819202122232425262728293031#!/usr/bin/python# -*- coding: UTF-8 -*-# http://www.runoob.com/python3/python3-command-line-arguments.htmlimport sys, getoptdef main(argv): inputfile = &#x27;&#x27; outputfile = &#x27;&#x27; try: opts, args = getopt.getopt(argv,&quot;hi:o:&quot;,[&quot;ifile=&quot;,&quot;ofile=&quot;]) except getopt.GetoptError: print(&#x27;command-line-arguments.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;) sys.exit(2) for opt, arg in opts: if opt == &#x27;-h&#x27;: print(&#x27;Usage: command-line-arguments.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;) sys.exit() elif opt in (&quot;-i&quot;, &quot;--ifile&quot;): inputfile = arg elif opt in (&quot;-o&quot;, &quot;--ofile&quot;): outputfile = arg print(&#x27;输入的文件为：&#x27;, inputfile) print(&#x27;输出的文件为：&#x27;, outputfile)if __name__ == &quot;__main__&quot;: main(sys.argv[1:])","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"Others","slug":"tech/Others","permalink":"https://norcy.github.io/wiki/categories/tech/Others/"},{"name":"Python","slug":"tech/Others/Python","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/"},{"name":"语法","slug":"tech/Others/Python/语法","permalink":"https://norcy.github.io/wiki/categories/tech/Others/Python/%E8%AF%AD%E6%B3%95/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/BackEnd/如何比较简单地展示一个静态网/","text":"python1python3 -m http.server http-server1234yarn global add http-server# 也可以使用 brew# brew install http-serverhttp-server nginxhttps://segmentfault.com/a/1190000010487262 MAMP","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"BackEnd","slug":"tech/BackEnd","permalink":"https://norcy.github.io/wiki/categories/tech/BackEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/BackEnd/定时任务/","text":"crontab 用法常用命令如下 1234crobtab crontab_info # 录入定时任务，只执行这个不会生效crontab -e # 编辑定时任务，保存退出后会展示 crontab: installing new crontab 即为成功crontab -l # 列出定时任务，可以根据这个判断是否有定时任务crontab -r # 移除定时任务（所有） crontab 的格式参考这个资料 例子想要使用定时执行 shell 脚本，可以把定时任务写在 txt 然后再录入系统 新建一个文件为 crontab_info.txt，录入以下信息 123# 这个是注释# 表示 2 月 7 号早上 8 点 30 分执行 abc.sh，并把信息录入 abc.log30 08 7 2 * abc.sh &gt;&gt; abc.log 坑第一个坑只录入是不会生效的，录入完之后需要编辑下，然后保存退出后展示 crontab: installing new crontab 才会成功 第二个坑 如果是 Mac：shell 脚本开头必须写上 source /etc/profile 才会成功 如果是 Linux：shell 脚本开头必须写上以下代码 123#!/bin/sh. /etc/profile. ~/.zshrc # 如果使用的是 zsh 的话 第三个坑相对路径的问题。 shell 脚本中访问的一切数据都要注意路径问题，如先 cd 到对应的目录以及指明 node 的绝对路径 12345#!/bin/sh. /etc/profilecd /home/ubuntu/Norcy/LeanCloud_Backup # 先 cd/usr/local/bin/node auto_backup.mjs # 使用 /usr/local/bin/node 而不是 node crontab_info.txt 中要注意使用绝对路径 10 3 * * * timer.sh &gt;&gt; timer.log # 不生效，因为没加 /bin/sh；timer.sh 和 timer.log 的路径都是在 ~ 10 3 * * * /bin/sh /home/ubuntu/Norcy/LeanCloud_Backup/timer.sh &gt;&gt; /home/ubuntu/Norcy/LeanCloud_Backup/timer.log # 建议使用绝对路径 第四个坑使用 crontab -e 如何将编辑器从 nano 改为 vim 123export VISUAL=vim# orexport EDITOR=vim 第五个坑有些机器存在时区问题，比如我们希望是北京下午 15 点发送，应该这样转换成 0 时区 10 7 * * * /bin/sh /home/ubuntu/Norcy/LeanCloud_Backup/timer.sh &gt;&gt; /home/ubuntu/Norcy/LeanCloud_Backup/timer.log # 转换时区","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"BackEnd","slug":"tech/BackEnd","permalink":"https://norcy.github.io/wiki/categories/tech/BackEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/H5打开外链失败/","text":"问题在 H5 页面使用 JS 代码下载 apk 文件 1window.open(&#x27;http://xx.apk&#x27;); 表现在 Chrome 上新窗口一闪而过，部分手机浏览器有问题，本地部署调试时没有问题 原因线上 H5 地址是 HTTPS，而外链是 HTTP，所以被 Chrome 和部分手机浏览器拦截了；而本地部署的地址是 HTTP，所以没问题 方法外链替换为 HTTPS 记录下自己这个 case 的具体做法： 七牛云申请一个 HTTPS 的加速域名，想要申请一个 image.xx.com 的域名，提示需要 HTTPS 证书 到域名提供商，如腾讯云，申请一个二级域名证书。之前的证书只能支持一级域名，方法是点击 Chrome 左上角的锁查看颁发对象，如果是 xx.com 就是只支持一级，如果是 *.xx.com 就是泛域名证书。由于我的是一级证书，因此需要重新申请一个。腾讯云的泛域名证书需要付费，而单个的二级域名不需要。详情点击 腾讯云 SSL 证书，选择自动解析 DNS 下载 SSL 证书，选择 pem 格式 上传到七牛云，上传 pem 和 key 两个文件 添加 image.xx.com 的加速域名 到腾讯云为该域名添加 CNAME 解析，主机记录填写 image 即可，value 值填写七牛云给的加速域名。意思是凡是访问 image.xx.com 这个域名，统统先解析为七牛云给的加速域名，再解析为其对应的 IP 地址。这样哪天七牛云换了 IP 地址，你的这个域名就依然生效 由于腾讯 SSL 证书只有一年有效期，到期后需要手动更新，重复步骤 2-4，然后在七牛云该证书页面点击部署到 CDN 即可","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/JS CORS 问题/","text":"现象 A.js 部署在 http://192.168.2.103:5173/，服务器部署在 http://192.168.2.103:8888/guess.php A.js 向 Guess.php 发起 Get 请求时，会报错 12Access to fetch at &#x27;http://192.168.2.103:8888/guess.php?reset=1&#x27; from origin &#x27;http://192.168.2.103:5173&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.:8888/guess.php?reset=1:1 解决方法 1：前后端配合 JS 的 fetch header 的 content-type 设置为 ‘application/x-www-form-urlencoded; charset=UTF-8’ 即可，而不能是其他的 后端设置 Access-Control-Allow-Origin 为 * 或指定 url 12345678910const obj = &#123;a:1&#125;;const options = &#123; method: &quot;POST&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &#125;, body: JSON.stringify(obj),&#125;;fetch(&quot;http://192.168.2.103:8888/guess.php&quot;, options) 服务端的 NodeJS 代码如下 1234import cors from &#x27;cors&#x27;;import express from &#x27;express&#x27;;const app = express();app.use(cors()); 服务端的 PHP 代码如下 12345&lt;?phpheader(&quot;Access-Control-Allow-Origin: *&quot;);$data = json_decode(file_get_contents(&#x27;php://input&#x27;), true);$uid = $data[&#x27;user&#x27;][&#x27;AVUser&#x27;][&#x27;objectId&#x27;];?&gt; 参考：https://stackoverflow.com/questions/25727306/request-header-field-access-control-allow-headers-is-not-allowed-by-access-contr 解决方法 2：浏览器插件，仅适用于本地调试解决方法 3：JSONP，仅适用于 Get 请求，且需要服务端配合注意 fetch 方法中添加 mode:no-cors 不可行 只是 Get 请求，可以用 JSONP 的方式来解决 客户端的改造A.js 安装 fetch-jsonp，代替 fetch Before 123const response = await fetch(&#x27;http://192.168.2.103:8888/guess.php?reset=1&#x27;);const json = await response.json();console.log(json) After 1234import fetchJSONP from &#x27;fetch-jsonp&#x27;;const response = await fetchJSONP(&#x27;http://192.168.2.103:8888/guess.php?reset=1&#x27;);const json = await response.json();console.log(json) 服务端的改造Before 123$ret = [&#x27;state&#x27; =&gt; 0];$tmp = json_encode($ret);echo $tmp; After 1234$ret = [&#x27;state&#x27; =&gt; 0];$tmp = json_encode($ret);$callback = isset($_GET[&#x27;callback&#x27;]) ? trim($_GET[&#x27;callback&#x27;]) : &#x27;&#x27;;echo $callback . &#x27;(&#x27; . $tmp .&#x27;)&#x27;; 解决方法 4：临时关闭浏览器的 CORS 防御策略，仅适用于本地调试123cd /Applications/Google\\ Chrome.app/Contents/mkdir MyCORSopen -n /Applications/Google\\ Chrome.app --args --disable-web-secruity --user-data-dir=&#x27;/Applications/Google Chrome.app/Contents/MyCORS&#x27;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/JS双问号用法/","text":"当左值为 null 或 undefined 时（并非所有 false 值，如 0 或 ‘’），返回右值 但是当左值为 0 时，依然返回左值，这是和 || 的唯一区别 12345678let foo = null ?? &#x27;default string&#x27;; //&quot;default string&quot;foo = 0 ?? 42; //0foo = 1 ?? 42; //1foo = &#x27;&#x27; ?? 42; //&#x27;&#x27;foo = null || &#x27;default string&#x27;; ////&quot;default string&quot;foo = 0 || 42; // 42foo = 1 || 42; // 1foo = &#x27;&#x27; || 42; //42 参考：Nullish coalescing operator (??)","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/JavaScript/","text":"?? 坑要注意运算符 ?? 的优先级 123456let a = 2, b = 3;a-b; // -1a??0; // 2b??0; // 3a??0-b??0 // 竟然为 2 (a??0)-(b??0) // -1 == 和 === 区别 === 严格相等，会比较两个值的类型和值 == 抽象相等，比较时，会先进行类型转换，然后再比较值 建议用 === 具体可见 js 中 == 和 === 的区别 JavaScript 中的相等性判断 Js 中如何正确创建一个类1234567function Cat(name,color)&#123; this.name = name; this.color = color;&#125;Cat.prototype.type = &quot;猫科动物&quot;;Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;; 使用构造函数，成员变量使用 this 在构造函数中初始化； 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 1234var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);alert(cat1.name); // 大毛alert(cat1.color); // 黄色 类变量和方法定义在 prototype 上 构造函数有一个 prototype 对象，该对象的所有属性和方法，都会被构造函数的实例继承。因此在这里定义类变量和方法可以实现不同对象之间的数据共享 参考：Javascript 面向对象编程（一）：封装 JS 数组深拷贝1const newArray = JSON.parse(JSON.stringify(array)); JS Fetch 请求使用 application/x-www-form-urlencoded 的坑body 参数必须自己手动编码，否则会出错 123456789101112131415161718192021var details = &#123; &#x27;userName&#x27;: &#x27;test@gmail.com&#x27;, &#x27;password&#x27;: &#x27;Password!&#x27;, &#x27;grant_type&#x27;: &#x27;password&#x27;&#125;;var formBody = [];for (var property in details) &#123; var encodedKey = encodeURIComponent(property); var encodedValue = encodeURIComponent(details[property]); formBody.push(encodedKey + &quot;=&quot; + encodedValue);&#125;formBody = formBody.join(&quot;&amp;&quot;);fetch(&#x27;https://example.com/login&#x27;, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27; &#125;, body: formBody&#125;) 数组中如果含有 undefined，不会参加 sort 函数的排序，会默认被排到最后123456let years = [2011, undefined, 2012]years.sort((a, b) =&gt; &#123; // undefined 元素不会参与排序 return b-a; // 输出 [2012, 2011, undefined] // return a-b; // 输出 [2011, 2012, undefined]&#125;);","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/RN TS 实践/","text":"剩余参数使用 &amp; 来声明 props 的类型 12345678const ListItem = (&#123; item, ...props&#125;: &#123; item: UIRecord;&#125; &amp; ViewProps) =&gt; &#123; return &lt;View ...props/&gt;&#125; children1children?: React.ReactNode | undefined; 字典的 key123const foo: &#123;[key: string]: string&#125; = &#123; &#x27;a&#x27;: &#x27;123&#x27;&#125; useRef12const allPageData = useRef&lt;UIRecord[]&gt;([]);allPageData.current // 此时为 UIRecord[] 12345const listRef = useRef&lt;FlatList|null&gt;();&lt;FlatList ref=&#123;(ref) =&gt; (listRef.current = ref)&#125;/&gt;listRef.current?.scrollToOffset(0) type普通 type 1234export type FooType = &#123; marked: boolean; image?: string;&#125;; type 联合 1234export type FooType = &#123; marked: boolean; image?: string;&#125; &amp; ViewProps; type 联合 2 1234567891011121314151617interface OriginProps = &#123; name: string;&#125;interface CustomProps extends OriginProps = &#123; age: number;&#125;// Before// export type FooType = &#123;// [key:string]: OriginProps;// &#125;;// Afterexport type FooType = &#123; [key:string]: CustomProps;&#125;; 类型强转1const date: DateData = data.date as DateData;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/MiniApp/小程序踩坑/","text":"wxml 的胡子拼接1&lt;view wx:for=&quot;&#123;&#123;5&#125;&#125;&quot;&gt;&#123;&#123; item3[&#x27;p_&#x27;+index] &#125;&#125;&lt;/view&gt; // 生效1&lt;mission-item state=&quot;&#123;&#123;property[item.key].state&#125;&#125;&quot;/&gt; // 不生效1&lt;mission-item state=&quot;&#123;&#123;property.&#123;&#123;item.key&#125;&#125;.state&#125;&#125;&quot;/&gt; setData 的 key 中含有变量12var originData = &quot;fmList[&quot;+index+&quot;].isStar&quot;;this.setData(&#123;[originData]: isStar&#125;); setData 更新对象的某个值// 不生效1this.setData(&#123;reward.winTips: &quot;恭喜获得钻石，请到任务中心兑换\\n赶紧跟小伙伴炫耀吧&quot;&#125;); // 生效1this.setData(&#123;&#x27;reward.winTips&#x27;: &quot;恭喜获得钻石，请到任务中心兑换\\n赶紧跟小伙伴炫耀吧&quot;&#125;); wx.setStorageSync 不能直接缓存 Map/Set123456789// Getlet storagedList = wx.getStorageSync(StorageKey);if (storagedList) &#123; this.favList = new Set(storagedList);&#125;// Set// storage 不支持 set，只能转为 arraywx.setStorageSync(StorageKey, Array.from(this.favList)) 音频播放被抢占过久如果音频被抢占过久，等到页面出现时，播放器会 Loading，此时直接 replay 是没有效果的，需要通过 src 重置播放器 1234567891011onShow: function () &#123; console.log(&quot;onShow&quot;); if (!this.data.isPlaying) &#123; // 如果音频被抢占过久，等到页面出现时，播放器会 Loading， // 此时直接 replay 是没有效果的，需要通过 src 重置播放器 this.backgroundPlayer.src = this.data.playerData.src; &#125; // 每次出现就要重新启动播放，包括第一次 this.replay();&#125;, 子 view 超出父 view 的部分仍然响应了点击目前只能在超出部分盖一层 View，并给它添加点击事件来解决 内容超过容器，导致可以滚动以禁止竖直为例：overflow-y:hidden 设置透明背景 正确：background-color:rgba(0,0,0,0) 错误：background-color:clear 胡子通知顺序不一致123456&#123;&#123;a || b&#125;&#125;a = true, b = falsethis.setData(&#123;a:false&#125;);this.setData(&#123;b:true&#125;); 结果可能导致 b 的变化比 a 的变化先通知 CSS 变量12345678910page &#123; --music-item-width: 5rpx; --music-item-count: 7;&#125;.music_bar &#123; width: var(--music-item-width); height: calc(var(--music-item-width)*var(--music-item-count));&#125; 布尔值的胡子语法1234567&lt;!-- 生效 --&gt;&lt;van-popup show=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;&lt;/van-popup&gt;&lt;!-- 不生效 --&gt;&lt;van-popup show=&quot;false&quot;&gt;&lt;/van-popup&gt; scroll-view 的坑竖直滑动的 scroll-view, 需要给 scroll-view 一个固定的高度（比如 100%），设置属性 scroll-y 1&lt;scroll-view class=&#x27;root&#x27; scroll-y&gt; 1234.root &#123; width: 100%; height: 100%;&#125; van-popup 滚动时，事件穿透到底下的 View解决方案 网络回包12345678910wx.request(&#123; url: &#x27;https://norcy.weimiaotech.com/SmallFrequence/regions?version=&#x27;+version, header: &#123; &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认值 &#125;, success(res) &#123; console.log(&quot;Request Category Sucess&quot; + res.data.data.length); self.didCategoryRequestFinished(res.data.data); &#125;&#125;) 这样当 res.data 是空的时候，res.data.data 会变成 undefined，从而访问 length 的时候会出错 注意获取二维码的 scene 值最多只支持 32 个字母text 标签出现顶部空白123&lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; 改为 1&lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; 行内样式胡子语法不生效// 生效 // 不生效","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"MiniApp","slug":"tech/FrontEnd/MiniApp","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/MiniApp/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/!!的妙用/","text":"背景x 是一个字符串，要求 x 为 null/undefined/‘’ 时不要渲染元素 很容易会写出以下代码 1&#123;x?.length &gt; 0 &amp;&amp; &lt;View/&gt;&#125; 但是这个代码是有问题的，因为 undefined 时，这个 x?.length 也会是 undefined，undefined 与 0 比较 ts 会报错。 那改为以下写法呢？ 1&#123;x?.length &amp;&amp; &lt;View/&gt;&#125; 这个虽然 ts 不会报错，但是如果 x 是 ‘’ 时， length 为 0，会导致运行时 React 报错 最佳实践x 为字符串使用 !! 来强制转 boolean，null/undefined/‘’ 这几种情况都会转为 false，’1’ 会转为 true，符合预期 1&#123;!!x &amp;&amp; &lt;View/&gt;&#125; x 为数组如果 x 为数组，要求是 null/undefined/[] 不渲染，不需要加 !! 1&#123;x?.length &amp;&amp; &lt;View/&gt;&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/Android RN 引用 fork 的三方库/","text":"背景Android 的 RN 工程，如果要对某个三方库进行 Native 代码的修改，该三方库不是自己维护的，因此需要 fork 一份到自己的 Github 仓库。此时要如何才能引用到自己修改过后的库呢？ 我对 Android 不熟，iOS 的做法是 Fork 原仓库，修改后加标签以及修改其 podspec 文件指向新的标签 Podfile 中将引用改为 Commit 引用即可（分支引用或发布自己的 podspec 也是可以的） 经过一番搜索，Android 也可以用类似的做法 步骤1. Fork 原仓库，修改代码我这里要修改的是 react-native 仓库 2. 修改版本信息即修改 ReactAndroid/gradle.properties 的 VERSION_NAME 字段 12-VERSION_NAME=0.62.2+VERSION_NAME=0.62.2.9.1 3. 修改 source 信息修改 ReactAnroid/release.gradle 中的信息，执行自己的仓库，类似修改 iOS 的 podspec 文件 其实就是把里面关于原来的 git 链接替换为自己的 123456789101112131415161718192021222324252627282930313233 artifactId(POM_ARTIFACT_ID) packaging(POM_PACKAGING) description(&quot;A framework for building native apps with React&quot;)- url(&quot;https://github.com/facebook/react-native&quot;)+ url(&quot;https://github.com/Norcy/react-native&quot;) scm &#123;- url(&quot;https://github.com/facebook/react-native.git&quot;)- connection(&quot;scm:git:https://github.com/facebook/react-native.git&quot;)- developerConnection(&quot;scm:git:git@github.com:facebook/react-native.git&quot;)+ url(&quot;https://github.com/Norcy/react-native.git&quot;)+ connection(&quot;scm:git:https://github.com/Norcy/react-native.git&quot;)+ developerConnection(&quot;scm:git:git@github.com:Norcy/react-native.git&quot;) &#125; licenses &#123; license &#123; name(&quot;MIT License&quot;)- url(&quot;https://github.com/facebook/react-native/blob/master/LICENSE&quot;)+ url(&quot;https://github.com/Norcy/react-native/blob/master/LICENSE&quot;) distribution(&quot;repo&quot;) &#125; &#125; developers &#123; developer &#123;- id(&quot;facebook&quot;)- name(&quot;Facebook&quot;)+ id(&quot;Norcy&quot;)+ name(&quot;Norcy&quot;) &#125; &#125; &#125; 4. 制作 aar、pom 等产物接下来就是生成 aar 等产物，幸好这个 RN 仓库就已经自带了，只需要在根目录下执行内置脚本即可 1./gradlew :ReactAndroid:installArchives 该命令执行后会在根目录生成一个 android 文件夹，这里面就是产物信息，如下 123456789101112131415161718192021.└── com └── facebook └── react └── react-native ├── 0.62.2.9.1 │ ├── react-native-0.62.2.9.1-javadoc.jar │ ├── react-native-0.62.2.9.1-javadoc.jar.md5 │ ├── react-native-0.62.2.9.1-javadoc.jar.sha1 │ ├── react-native-0.62.2.9.1-sources.jar │ ├── react-native-0.62.2.9.1-sources.jar.md5 │ ├── react-native-0.62.2.9.1-sources.jar.sha1 │ ├── react-native-0.62.2.9.1.aar │ ├── react-native-0.62.2.9.1.aar.md5 │ ├── react-native-0.62.2.9.1.aar.sha1 │ ├── react-native-0.62.2.9.1.pom │ ├── react-native-0.62.2.9.1.pom.md5 │ └── react-native-0.62.2.9.1.pom.sha1 ├── maven-metadata.xml ├── maven-metadata.xml.md5 └── maven-metadata.xml.sha1 这里我遇到脚本执行出错的几个问题 问题 1：找不到 hermes，通过在仓库根目录 yarn 后即可解决 问题 2：仓库根目录 yarn 失败，通过删除 node_modules 和 yarn.lock 重新 yarn 即可 问题 3：找不到 tools.jar 错误，第一步是在 ~/.zshrc 中配置 JAVA_HOME，其中 JAVA_HOME 的 value 是通过执行 /usr/libexec/java_home 得到 12export JAVA_HOME=&quot;/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home&quot;export PATH=$JAVA_HOME/bin:$PATH 问题 4：配置后依然找不到 tools.jar，最终使用 Android Studio 下载了一个 JDK，把其中的 tools.jar 拷贝到 JAVA_HOME 的 bin 文件夹下解决 5. 配置远程 maven 仓库这一步类似 iOS 的 podspec 的 source 仓库 新创建一个 Github 仓库 新建一个 repository 文件夹 将上一个步骤的产物信息拖到该文件夹，提交 Git 即可 由此计算最终的 maven 链接，以我的仓库为例 https://github.com/Norcy/maven，最终输出的链接为 https://raw.githubusercontent.com/Norcy/maven/master/repository/，其中 master 是分支名 6. 配置新的 maven 源这一步类似修改 iOS 的 Podfile 现在要切到我们的项目工程 在 android/app/build.gradle 中修改其中的版本引用，类似修改 Podfile 中的版本 12- implementation &quot;com.facebook.react:react-native:+&quot; // From node_modules+ implementation &quot;com.facebook.react:react-native:0.62.2.9.1&quot; // From node_modules 在 android/build.gradle 中修改修改其中的 maven 链接，类似修改 Podfile 中的 source。同时这里也有一个版本号需要一起修改 12345678910111213141516allprojects &#123; repositories &#123;+ maven &#123; url &#x27;https://raw.githubusercontent.com/Norcy/maven/master/repository/&#x27; &#125; jcenter() mavenLocal() maven &#123;allprojects &#123; configurations.all &#123; resolutionStrategy &#123; // Remove this override in 0.65+, as a proper fix is included in react-native itself.- force &quot;com.facebook.react:react-native:&quot; + REACT_NATIVE_VERSION+ force &quot;com.facebook.react:react-native:&quot; + &#x27;0.62.2.9.1&#x27;//REACT_NATIVE_VERSION force &#x27;androidx.core:core-ktx:1.6.0&#x27; &#125; &#125; 全部完成之后，sync 一下 gradle 即可 参考 例子，不过用的是 maven 而不是 gradle 管理 如何修改配置 例子","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/JS Object 的坑/","text":"12345const FOO = &#x27;123&#x27;;const BAR = &#123; FOO: 333&#125;; BAR 的结果竟然是 &#123;FOO:333&#125; 正确给 Object 设置 key 应该是这样 12345const FOO = &#x27;123&#x27;;const BAR = &#123; [FOO]: 333&#125;; 这样 BAR 的输出为 &#123;123:333&#125;，才符合预期","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/JSON.stringfy 的坑/","text":"Object 经过 JSON.stringify 转换之后，会丢失值为 undefined 的键值对 12let a = &#123;foo: 1, bar: undefined&#125;JSON.stringify(a) // 输出 &#x27;&#123;&quot;foo&quot;:1&#125;&#x27;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/RN 全局替换 Text 属性/","text":"1234567const oldRender = Text.render;Text.render = (...args) =&gt; &#123; const origin = oldRender.call(this, ...args); return React.cloneElement(origin, &#123; style: [fontFamily: &#x27;&#x27;, origin.props.style] &#125;);&#125; 原理就是重写 Text 组件的 render 方法 React.cloneElement 是 React 一个方法，用于复制一个 React 元素，并为其修改属性或修改 Children 12345function cloneElement&lt;P&gt;( element: FunctionComponentElement&lt;P&gt;, props?: Partial&lt;P&gt; &amp; Attributes, ...children: ReactNode[] ): FunctionComponentElement&lt;P&gt;; 第一个参数是被拷贝的原元素；第二个参数是希望新增的属性，React 内部会对其和原有属性进行一个合并，而不是覆盖；第三个参数是可选的，是 Children 元素","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/RN 安卓开发笔记/","text":"USB 调试 连接 USB 后运行 adb reverse tcp:8081 tcp:8081 执行 yarn run android 安装 APK console 按下 R 即可 不需要通过摇一摇去设置 IP 编译 APK 参考 https://reactnative.cn/docs/signed-apk-android 完成签名配置 点击 Android Studio 的 Build -&gt; Generate Signed Bundle/APK -&gt; APK -&gt; 根据你的签名配置填好即可 Android Studio 的弹框中会提示 APK 地址 安装 APK 到手机USB 连接手机且打开手机的 USB 安装开关前提下 发布时：执行 adb install xxx.apk 即可 调试时：执行 npx react-native run-android 运行 Release 包点击 Build 控制台左边的 Build Variants，将 :app 的编译模式从 debug 改为 release，再运行即可 修改安卓版本号更改 app/src/main/AndroidManifest.xml 中的 versionName 字段 通过 ADB 打开手机网址1adb shell am start -a android.intent.action.VIEW -d https://www.qq.com 命令行打包 apk 失败参考 官方文档，执行 ./gradlew assembleRelease 时报错 12:compileReleaseKotlin FAILEDKotlin could not find the required JDK tools in the Java installation. Make sure Kotlin compilation is running on a JDK, not JRE 修改 ~/.zshrc 的 JAVA_HOME 为 Android Studio 即可 123export JAVA_HOME=/Applications/&quot;Android Studio.app&quot;/Contents/jbr/Contents/Home# export JAVA_HOME=&quot;/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home&quot;export PATH=$JAVA_HOME/bin:$PATH 无线调试 先插线，确保手机上允许 USB 调试，然后可以断开线 打开手机的无线调试，记住该页面展示的 IP 和 Port adb connect IP:Port yarn run android 如果提示 adb pair 找不到，可能是 adb 版本过低导致，可通过 adb --version 确认版本，30 以上的版本即可使用 如果版本太低，需要更新 adb，打开 Android Studio 的设置，【Android SDK】-&gt; 【SDK Tools】-&gt;【Android SDK Platform-Tools】勾选后确认即可更新 详见 Android 无线调试教程","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/RN 异常调研/","text":"Native Debug 在点击函数里面 console.log(a.b) 如果是 JS Debug，则 Fatal 如果是 JS Release，则打印 undefined JS 经过编译之后，a 应该是一个存在的变量！ 在点击函数里面 console.log(aaa.bbb)直接 Fatal 在全局，即函数外面 console.log(aaa.bbb)直接 Fatal 在点击函数里面直接写多余的 abcd直接 Fatal 随意修改 main.jsbundleBundle 加载失败 console.error(123)Soft Native Release123ErrorUtils.setGlobalHandler((error: any) =&gt; &#123; console.log(&#x27;js error2: &#x27;, error);&#125;); Release 下的 Fatal 错误，如果不实现 RN 的 Fatal 回调，默认情况下是会 Crash 的 如何制造 Soft console.error 运行起来之后修改代码，使其编译不过的都是 Soft（没什么意义好像，因为打包的时候会编译不过） 如何制造 krn_page_error在 JS 的全局区域写几个字母，比如 123456789const store = createStore( rootReducer, applyMiddleware(thunkMiddleware, promiseMiddleware),);asdxaxconst persistor = persistStore(store); 如何制造 krn_bundle_load_result 的失败运行时修改 path 为空","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/ReactNative JS 笔记/","text":"useRefuseRef 有两个作用，详细可参考 https://zh-hans.reactjs.org/docs/hooks-reference.html#useref 1. 为子组件提供命令式访问通常配合子组件的 ref 属性使用 12345678910111213function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; 2. 提供实例变量，减少渲染次数useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。注意自建对象在每次渲染的时候都保持其初始值，而 useRef 会保持上一次渲染时候的值 请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要触发渲染，则需要手动调用 老方案：每次选择标签会触发两次 Render 1234567891011121314const [rateFilterIndex, setRateFilterIndex] = useState(0)useEffect(()=&gt; &#123; // reloadData 会触发第二次渲染 reloadData();&#125;, [rateFilterIndex])&lt;MyTagFilter selectIndex=&#123;rateFilterIndex&#125; didFilterSelect=&#123;(newIndex) =&gt; &#123; // setRateFilterIndex 会触发第一次渲染 setRateFilterIndex(newIndex) &#125;&#125;/&gt; 新方案：使用 useRef 减少 Render 次数，每次选择标签只会触发一次 Render 12345678910const rateFilterIndex = useRef(0)&lt;MyTagFilter selectIndex=&#123;rateFilterIndex.current&#125; didFilterSelect=&#123;(newIndex) =&gt; &#123; // reloadData 会重新触发渲染 rateFilterIndex.current = newIndex; reloadData() &#125;&#125;/&gt; react navigation 的 focus 回调中的 state 没有及时更新以下代码，假如此刻 setRoutes 已经触发，有新的值了，然后再切换 Tab 触发 focus 回调 此时下面这代码的 focus 回调里面会一直使用老的 routes 1234567891011const [routes, setRoutes] = useState(&#123;a:1&#125;)React.useEffect(() =&gt; &#123; const unsubscribe_focus = navigation.addListener(&#x27;focus&#x27;, () =&gt; &#123; // 打印出来的是老的 routes console.log(&#x27;Home viewWillAppear&#x27;, routes); &#125;); return function cleanup() &#123; unsubscribe_focus(); &#125;;&#125;, [navigation]); 解决办法是在 useEffect 的参数里面添加 routes 监听，此时下面这代码的 focus 回调里面会读到新的 routes 123456789React.useEffect(() =&gt; &#123; const unsubscribe_focus = navigation.addListener(&#x27;focus&#x27;, () =&gt; &#123; // 打印出来的是新的 routes console.log(&#x27;Home viewWillAppear&#x27;, routes); &#125;); return function cleanup() &#123; unsubscribe_focus(); &#125;;&#125;, [navigation, routes]); 获取 value 总是老的值1234567// 添加 useLayoutEffect 会导致点击函数中获取的 value 值永远是老的// React.useLayoutEffect(() =&gt; &#123; navigation.setOptions(&#123; headerTitle: &#x27;编辑&#x27; + title, headerRight: () =&gt; _renderSaveButton(), &#125;);// &#125;, [navigation]); setState 失效 如果值是一个数组，记得拷贝一下 slice()，否则即使对象的值改了，state 也不会变化 12345console.log(pageData.data) // print 111pageData.data = 222console.log(pageData.data) // print 222setPageData(pageData) // 不会触发 UI 刷新！setPageData(pageData.slice()) // 这样才会触发 UI 刷新！ 如果值是一个对象，则不能使用 slice，而使用 ... 1setPageData(&#123;...pageData&#125;) 如何正确使用 useState 来更新 UI我们想在 pageData 更新的时候，更新下搜索结果。 错误的代码 12345const onPageDataUpdate = async (newPageData) =&gt; &#123; setPageData(newPageData) const searchResult = searchInPageData(pageData) // 此时我们期望 pageData 是对的，但其实是老数据！ setSearchResult(searchResult) // 利用 searchResult 更新 UI，UI 使用的是 &#123;searchResult&#125;&#125; 可以看到，setState 这个方法，并不是同步生效的！ 那么使用 await 来等待 setState 是否可行呢？ 12345const onPageDataUpdate = async (newPageData) =&gt; &#123; await setPageData(newPageData) const searchResult = searchInPageData(pageData) // 此时我们期望 pageData 是对的，但其实是老数据！ setSearchResult(searchResult) // 利用 searchResult 更新 UI，UI 使用的是 &#123;searchResult&#125;&#125; 结果依然是不对的，这就说明，await 操作并不能让 setState 等待，详细可以看这个 demo 正规做法是需要借助 useEffect 来完成这个操作（如果是 setState，则使用 setState 的第二个参数来回调） 使用 useEffect 的代码如下 12345678useEffect(() =&gt; &#123; const searchResult = searchInPageData(pageData) // 此时 pageData 是对的 setSearchResult(searchResult) // 利用 searchResult 更新 UI，UI 使用的是 &#123;searchResult&#125;&#125;, [pageData]) // 当 pageData 变化时，调用该函数const onPageDataUpdate = async (newPageData) =&gt; &#123; setPageData(newPageData) // 只更新 pageData，然后等待 useEffect 的更新&#125; setState 的四种用法 接受一个 Object setState 方法其实是 “异步” 的。即立马执行之后，是无法直接获取到最新的 state 的 123console.log(this.state.count) // 0this.setState(&#123;count: this.state.count + 1&#125;)console.log(this.state.count) // 0 接受一个 Object 和函数 setState 的回调可以获取最新的 state 的值 123this.setState(&#123;count: this.state.count + 1&#125;, ()=&gt;&#123; console.log(this.state.count) // 1&#125;) 只接受一个函数 函数的首个参数就是上一次的 state，利用这个可以实现连续“同步”更新 state 12this.setState(prevState =&gt; &#123;count: prevState.count + 1&#125;); // 0this.setState(prevState =&gt; &#123;count: prevState.count + 1&#125;); // 1 接受两个函数 第一个函数的首个参数是上一次的 state，第二个函数是 callback 123this.setState(prevState =&gt; &#123;count: prevState.count + 1&#125;, () =&gt; &#123; console.log(&quot;更新完成&quot;)&#125;); setState(object) 是真的异步吗？ 在生命周期（Hook 函数）中是异步的 1234567891011class MyTest extends Component &#123; state = &#123; count: 0 &#125;; componentDidMount() &#123; console.log(this.state.count) // 0 this.setState(&#123; count: this.state.count + 1 &#125;) console.log(this.state.count) // 0 &#125;&#125; 在合成事件中是异步的 1234567891011121314151617class MyTest extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;TouchableWithoutFeedback onPress=&#123;() =&gt; &#123; console.log(this.state.count) // 0 this.setState(&#123; count: this.state.count + 1 &#125;) console.log(this.state.count) // 0 &#125;&#125; &gt; &lt;View /&gt; &lt;/TouchableWithoutFeedback &gt; ) &#125;&#125; 在 setTimeout 中是同步的 12345678910111213class MyTest extends Component &#123; state = &#123; count: 0 &#125;; componentDidMount() &#123; setTimeout(() =&gt; &#123; console.log(this.state.count) // 0 this.setState(&#123; count: this.state.count + 1 &#125;) console.log(this.state.count) // 1 &#125;, 1); &#125;&#125; 除了 setTimeout 外，在 DeviceEventEmitter 的回调函数里，也是同步执行。这跟 js 的事件循环机制有关，setTimeout 和 DeviceEventEmitter 的回调都是在事件循环结束时调用，其余时候调用 setState 则是异步的。 https://github.com/sisterAn/blog/issues/26 SVG 的替换颜色不生效1yarn start --reset-cache useEffect 的作用12345678910111213141516171819// 没有参数，每一次 Render 之后都会执行useEffect(() =&gt; &#123; console.log(&#x27;每一次 Render 之后都会执行&#x27;)&#125;)// 空数组，只会执行一次useEffect(() =&gt; &#123; console.log(&#x27;只会执行一次&#x27;)&#125;, [])// 数组单个值，特定参数改变的时候都会执行（该值是 state）useEffect(() =&gt; &#123; console.log(&#x27;navigation 改变的时候都会执行&#x27;)&#125;, [navigation])// 数组多个值，每个值改变的时候都会执行（该值是 state）useEffect(() =&gt; &#123; console.log(&#x27;id 或 name 改变的时候都会执行&#x27;)&#125;, [id, name]) useEffect 里面如何调用 async 函数12345678910useEffect(() =&gt; &#123; (async () =&gt; &#123; await initConnection(); console.log(&#x27;iap initConnection finish&#x27;); &#125;)(); return () =&gt; &#123; endConnection(); &#125;; &#125;, []); React Context 学习当主题设置、语言设置等类似需求时，使用 Context 是一个非常好的解决方案。Context 主要解决属性层层传递的问题，当数据源变更时，可以方便的通知到各个使用该属性的地方 主要包含三个方法： createContext 1const MyContext = React.createContext(defaultValue); 主要用于创建 Context，支持传递 defalutValue Provider 1&lt;MyContext.Provider value=&#123;customValue&#125;&gt; 被 Provider 包裹的组件，无论递归多少，都能方便的使用 Context 的 value Provider 标签支持传递 value，如果不传递，则使用 createContext 中的 defaultValue Consumer 12345&lt;MyContext.Consumer&gt;&#123;(value) =&gt; &#123; console.log(&quot;value 变化了&quot;);&#125;&#125;&lt;/MyContext.Consumer&gt; Consumer 的作用是订阅 context 的变化 注意事项 1：并不是所有的数据层层传递是适合用 Context比如，考虑这样一个 Page 组件，它层层向下传递 user 和 avatarSize 属性，从而让深度嵌套的 Link 和 Avatar 组件可以读取到这些属性： 123456789&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;// ... 渲染出 ...&lt;PageLayout user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;// ... 渲染出 ...&lt;NavigationBar user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;// ... 渲染出 ...&lt;Link href=&#123;user.permalink&#125;&gt; &lt;Avatar user=&#123;user&#125; size=&#123;avatarSize&#125; /&gt;&lt;/Link&gt; 如果在最后只有 Avatar 组件真的需要 user 和 avatarSize，那么层层传递这两个 props 就显得非常冗余。而且一旦 Avatar 组件需要更多从来自顶层组件的 props，你还得在中间层级一个一个加上去，这将会变得非常麻烦。 注意事项 2：避免多余渲染Provider 的 value 是浅比较，所以当 Provider 重新渲染的时候，由于 value 属性总是被赋值为新的对象，以下的代码会重新渲染下面所有的 consumers 组件 123456789class App extends React.Component &#123; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123;something: &#x27;something&#x27;&#125;&#125;&gt; &lt;Toolbar /&gt; &lt;/MyContext.Provider&gt; ); &#125;&#125; 为了防止这种情况，将 value 状态提升到父节点的 state 里： 12345678910111213141516class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &#123;something: &#x27;something&#x27;&#125;, &#125;; &#125; render() &#123; return ( &lt;MyContext.Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt; &lt;/MyContext.Provider&gt; ); &#125;&#125; 注意事项 3：Hook 下的 context 依然使用 Provider 包裹 使用 useContext 能够读取 context 的 value，以及代替 Consumer 监听 context 变化 useContext 的入参和返回值都是 context 本身 如何从子组件更新 Context 的内容，主要是将 setState 传到 context 中，详见 https://stackoverflow.com/questions/41030361/how-to-update-react-context-from-inside-a-child-component","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/ReactNative 中 fetch 的巨坑/","text":"RN 中，fetch 的 body 参数，只要带上 query，在安卓的 release 版本上，调用 .json() 的时候就会报错。 Android 的 debug 版本没有任何问题；与 __DEV__ 变量无光；排除了后台代码、回包的影响；只要把 query 改为其他单词比如 check 就没任何问题（后台同步修改） 由于是 Release，默认报错无法查看，复现机型是红米 8A，怀疑是小米系统底层问题。不打算进一步研究 12345678910111213141516try &#123; const rawResponse = await fetch(SERVER_URL, &#123; method: &#x27;POST&#x27;, headers: &#123; Accept: &#x27;application/json&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#125;, body: JSON.stringify(&#123; cmd: &#x27;query&#x27;, // 罪魁祸首 &#125;), &#125;); // 这句会报错 const res = await rawResponse.json();&#125; catch (e) &#123; console.error(e)&#125;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/ReactNative 组件推荐/","text":"已实践的组件推荐 cell 拖拽 react-native-draggable-flatlist 星星评分组件 react-native-ratings react-native-star-rating 图表组件 react-native-chart-kit victory react-native-svg-charts react-native-echarts-wrappe 轮播 react-native-snap-carousel react-native-reanimated-carousel 未实践的组件推荐 快速给指定位置添加子节点 react-native-root-siblings Switch 开关 split 请参考 openbase 排名","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/ReactNative Native 笔记/","text":"Bridge 与线程1. Bridge 中所有暴露的方法，分为同步方法和异步方法1234// 这是同步方法的声明RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(foo)&#123;&#125;// 这是异步方法的声明RCT_EXPORT_METHOD(bar)&#123;&#125; 2. Bridge 的方法调用，默认都在子线程默认情况下，Bridge 的方法都是从 JS 线程直接过来的，所以特别特别需要注意方法实现中不能去操作 UI 如果需要操作 UI 有两种办法，第一种是直接异步到主线程，比如 123456RCT_EXPORT_METHOD(openView)&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // 这里是 UI 操作 &#125;);&#125; 第二种方法如下，Bridge 中实现了该方法后，该 Bridge 的所有异步方法都默认在主线程调用 1234- (dispatch_queue_t)methodQueue&#123; return dispatch_get_main_queue();&#125; 注意，这种情况下，如果是同步方法，依然会在 JS 线程中调用 3. 导出常量Native 暴露能力给 JS 调用，除了同步方法和异步方法，还有一种是导出常量 1234- (NSDictionary *)constantsToExport &#123; return @&#123;@&quot;myKey&quot;: @&quot;myValue&quot;&#125;;&#125; JS 中的调用方法如下 12// KRNBasic 是 Bridge 名称console.log(NativeModules.KRNBasic.myKey); // 输出 myValue 4. 指定线程去初始化函数和导出常量如果你导出了常量，或者实现了 init 方法，RN 会提醒你实现 + (BOOL)requiresMainQueueSetup 方法 该方法的作用是让 RN 引擎知道，你的 init 方法或 constantsToExport 方法在什么线程中执行。 如果你不实现这个方法，你的 init 或 constantsToExport 将会在子线程中执行 Bridge 方法回调1RCT_EXPORT_METHOD(open:(id)obj success:(RCTResponseSenderBlock)success fail:(RCTResponseSenderBlock)fail) 每个方法最多支持两个 RCTResponseSenderBlock 参数，一个用于 success，一个用于 fail，且这两个方法只能回调一个 且无法将 RCTResponseSenderBlock 放到 Object 中 https://github.com/facebook/react-native/issues/9213","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.950Z","path":"tech/FrontEnd/ReactNative/ReactNative 踩坑记录/","text":"di18n 失效字符串中只要出现 “.” 就会失效，比如 1234// 翻译失败i18n.t(&quot;该文件的后缀名不对，应该为 .db&quot;)// 翻译成功i18n.t(&quot;该文件的后缀名不对，应该为 db&quot;) ScrollView 如何让内容撑满1234&lt;ScrollViewcontentContainerStyle=&#123;&#123; flexGrow: 1 &#125;&#125;&gt;&lt;/ScrollView&gt; 如何实现上拉加载 1234567891011121314151617181920&lt;ScrollViewcontentContainerStyle=&#123;&#123; flexGrow: 1 &#125;&#125;&gt;&lt;!-- 你的数据 --&gt;...&lt;!-- 占位 --&gt;&lt;View style=&#123;&#123;flex: 1, width: &#x27;100%&#x27;&#125;&#125;&gt;&lt;/View&gt;&lt;View&gt;&lt;Text style=&#123;&#123; marginTop: 30, position: &#x27;absolute&#x27;, textAlign: &#x27;center&#x27;, width: &#x27;100%&#x27;, color: &#x27;gray&#x27;, &#125;&#125;&gt; &#123;&#x27;继续上拉查看时间轴↑&#x27;&#125;&lt;/Text&gt;&lt;/View&gt;&lt;/ScrollView&gt; FlatList 的 Header 中的 TextInput，每次输入后总是会失去焦点如果 Header 中含有 TextInput，则不能返回一个渲染函数，否则 TextInput 会每次输入完，重新渲染，从而失去焦点。https://github.com/facebook/react-native/issues/13365 TextInput 在 Editable 为 false 时会响应长按pointerEvents 会禁止所有手势 123&lt;View pointerEvents=&#123;isEdit ? &#x27;none&#x27; : &#x27;auto&#x27;&#125;&gt; &lt;TextInput editable=&#123;isEdit&#125;&gt;&lt;/View&gt; 在 JSX 中慎用 length 作为 &amp;&amp; 的条件1&#123;media.url?.length &amp;&amp; _renderUrlButton()&#125; 该代码 length 返回的是 int，用 int 来作为 &amp;&amp; 的条件，是有问题的，会导致报错 1Text strings must be rendered within a &lt;Text&gt; component. 解决办法 1&#123;media.url?.length &gt; 0 &amp;&amp; _renderUrlButton()&#125; 如果是普通的 if 条件，或者是三元表达式就没问题 1&#123;media.url?.length ? _renderUrlButton() : &lt;/&gt;&#125; // 没问题 1234// 这样也没问题if (media.url?.length &amp;&amp; someCondition) &#123;&#125; Android TextInput 键盘弹出出现空白问题 AndroidMainfest.xml 修改 windowSoftInputMode 从 adjustPan 改为 adjustResize，即 android:windowSoftInputMode=&quot;adjustResize&quot; KeyboardAvoidingView 的 behavior 选择 height 而不是 padding 123&lt;KeyboardAvoidingViewbehavior=&#123;Platform.OS == &#x27;ios&#x27; ? &#x27;padding&#x27; : &#x27;height&#x27;&#125;&gt;... Android TextInput 第二次键盘弹起时，cursor 正确，但是没有自动自动滚动到 cursor，必须先输入一下之后才会滚动解决方法：模拟用户操作 cursor 12345678910111213141516171819202122232425262728293031323334const cursorPosition = React.useRef(0);useEffect(() =&gt; &#123; const unsubscribe = Keyboard.addListener(&#x27;keyboardDidShow&#x27;, (e) =&gt; &#123; if (Platform.OS === &#x27;android&#x27;) &#123; setTimeout(() =&gt; &#123; inputRef.current?.setNativeProps(&#123; selection: &#123; start: cursorPosition.current, end: cursorPosition.current, &#125;, &#125;); // 必须设置回来，不然 cursor 永远不对 inputRef.current?.setNativeProps(&#123; selection: &#123;&#125;, &#125;); &#125;, 10); &#125; &#125;); return () =&gt; &#123; unsubscribe.remove(); &#125;;&#125;, []);&lt;TextInput onSelectionChange=&#123;(&#123; nativeEvent: &#123; selection: &#123;start, end&#125;, &#125;, &#125;) =&gt; &#123; cursorPosition.current = start; &#125;&#125;&gt; Android TextInput cursor 不对的问题TextInput 在 multiline，首次 focus 时，cursor 不是在手指的位置，而是在文本末尾 解决方法： 12345678910111213141516const inputRef = React.useRef&lt;TextInput | null&gt;();useEffect(() =&gt; &#123; // 完美解决安卓首次 focus 聚焦到 Text 末尾的问题 setTimeout(() =&gt; &#123; if (Platform.OS === &#x27;android&#x27;) &#123; inputRef.current?.focus(); inputRef.current?.blur(); &#125; &#125;, 10);&#125;, []);&lt;TextInput multiline=&#123;true&#125; ref=&#123;(ref) =&gt; (inputRef.current = ref)&#125;/&gt; iOS TextInput 在换行时会滚动到顶部复现路径1：文本超过一屏，最好全部是中文，最后一行倒数几个是英文，输入一个个英文，会发现换行时，TextInput 自动滚动到顶部，再输入一下才会滚回来 复现路径2：文本超过一屏，最好全部是中文，最后一行倒数几个留空，一次性输入大段文字（可通过拼音转汉字或者粘贴实现）确保换行，此时也会复现，也是再输入一下才会滚回来 思路：因为再输入一下才会滚回来，所以模拟用户输入可以解决该问题。每次当新换行时，输入一个零宽字符，再延时移除，即可解决该问题 12345678910111213141516171819202122232425262728293031323334353637const oldHeight = React.useRef(-1);const ZeroWidthCharRegex = /[\\u200B]/;const [comment, setComment] = useState(&#x27;&#x27;);&lt;TextInput onTextChange=&#123;(name, value) =&gt; &#123; if (Platform.OS == &#x27;ios&#x27; &amp;&amp; ZeroWidthCharRegex.test(value)) &#123; // 如果打字过快，可能会走到这，需要移除零宽字符 value = value.replace(ZeroWidthCharRegex, &#x27;&#x27;); &#125; setComment(value); &#125;&#125; onContentSizeChange=&#123;(&#123; nativeEvent: &#123; contentSize: &#123;width, height&#125;, &#125;, &#125;) =&gt; &#123; if (Platform.OS == &#x27;ios&#x27; &amp;&amp; height &gt; oldHeight.current) &#123; const currentValue = comment; if (!ZeroWidthCharRegex.test(currentValue)) &#123; // 新增零宽字符 // console.log(&#x27;新增零宽字符&#x27;); // 第一个 timeout 是为了解决大段拼音转文字后，出现回滚顶部的情况 setTimeout(() =&gt; &#123; setComment(comment + &#x27;\\u200B&#x27;); // 第二个 timeout 是为了增加零宽字符后，不要立刻移除，否则不会触发 TextInput 的自动滚动 setTimeout(() =&gt; &#123; // 移除零宽字符 // console.log(&#x27;移除零宽字符&#x27;); setComment(comment.replace(ZeroWidthCharRegex, &#x27;&#x27;)); &#125;, 10); &#125;, 10); &#125; &#125; oldHeight.current = height; &#125;&#125;/&gt; 拼音排序问题123456789let a = &#x27;凯瑟琳&#x27;;let b = &#x27;刘&#x27;;let c = &#x27;加勒比&#x27;;// 输出 -1，正确console.log(a.localeCompare(b, &#x27;zh&#x27;));// 输出 -1，不对console.log(a.localeCompare(c, &#x27;zh&#x27;));// 输出 -1，不对console.log(b.localeCompare(c, &#x27;zh&#x27;)); 浏览器的输出是对的，但是 React Native 的输出不对，猜测与 React Native 的 JSCore 有关。必要时可通过 pinyin-pro 这个库来解决","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"},{"name":"ReactNative","slug":"tech/FrontEnd/ReactNative","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/ReactNative/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/App 开发笔记/","text":"异常上报新版本的 Sentry 配置目前新版本是 12&quot;@sentry/cli&quot;: &quot;^1.59.0&quot;,&quot;@sentry/react-native&quot;: &quot;^3.4.3&quot;, 最新的 Sentry 只需要运行一下命令 12npx @sentry/wizard -i reactNative -p iosnpx pod-install 为了 Debug 模式不上传 Sentry，防止浪费时间和资源，可以对 Bundle React Native code and images 任务改造为 12345678910111213export NODE_BINARY=nodeif [ &quot;$CONFIGURATION&quot; == &quot;Debug&quot; ]then echo &quot;Norcy_Debug1&quot; ../node_modules/react-native/scripts/react-native-xcode.shelse echo &quot;Norcy_Release1&quot; export EXTRA_PACKAGER_ARGS=&quot;--sourcemap-output $DERIVED_FILE_DIR/main.jsbundle.map&quot; export SENTRY_PROPERTIES=sentry.properties ../node_modules/@sentry/cli/bin/sentry-cli react-native xcode \\ ../node_modules/react-native/scripts/react-native-xcode.shfi 对 Upload Debug Symbols to Sentry 勾选 Fot install builds only 即可 老版本的 Sentry 配置以下是老的配置，不需要再看了 需要根据指引对 Xcode 工程进行配置，除此之外，还针对 Debug 模式不上传 Sentry，防止浪费时间和资源 生成 sourcemap 文件 1234567891011121314export NODE_BINARY=nodeif [ &quot;$CONFIGURATION&quot; == &quot;Debug&quot; ]then echo &quot;Norcy_Debug&quot; ../node_modules/react-native/scripts/react-native-xcode.shelse echo &quot;Norcy_Release&quot; export EXTRA_PACKAGER_ARGS=&quot;--sourcemap-output $DERIVED_FILE_DIR/main.jsbundle.map&quot; export SENTRY_PROPERTIES=../sentry.properties ../node_modules/@sentry/cli/bin/sentry-cli react-native xcode \\ ../node_modules/react-native/scripts/react-native-xcode.shfi 上传 Debug 符号到 Sentry 平台 12345678910# Type a script or drag a script file from your workspace to insert its path.if [ &quot;$CONFIGURATION&quot; == &quot;Debug&quot; ]then echo &quot;Norcy_Debug&quot;else echo &quot;Norcy_Release&quot; export SENTRY_PROPERTIES=../sentry.properties ../node_modules/@sentry/cli/bin/sentry-cli upload-dif &quot;$DWARF_DSYM_FOLDER_PATH&quot;fi 用户反馈兔小槽 日活统计友盟 隐私协议App-Privacy-Policy-Generator AppStore 截图previewed App Icon 生成蒲公英 icon 素材 阿里巴巴 react-native-vector-icons react-native-vector-icons 优点是占用体积小，缺点是图标有限 最新的 Xcode 安装 react-native-vector-icons 后，每次 pod install 之后都会编译出错，原因是资源重复导入，因此写了以下脚本进行删除 RN 的根目录运行即可 123cd iospod _1.9.3_ installsed -i &#x27;&#x27; &#x27;s/.*.ttf\\&quot;,//g&#x27; Paxxword.xcodeproj/project.pbxproj 配色创意 颜色表 色采 App 热更新 react-native-code-push 安装1234# 安装yarn global add appcenter-cli# 登录appcenter login 客户端需要修改的地方 App 新接入 到 https://appcenter.ms/apps 新增一个 App 命令行设置当前 App 12345678910# 列出所有 app，确认新增的 App 生效appcenter apps list# 设置/切换当前 Appappcenter apps set-current Nx/iRead# 列出当前 app，确认切换生效appcenter apps show# 新增 Release 模式appcenter codepush deployment add Release# 获取 CODEPUSH_KEYappcenter codepush deployment list -k 【iOS】修改 AppDelegate，详情请参考官方文档 【iOS】Info.plist 新增 CodePushDeploymentKey，值为第二步获取到的 CODEPUSH_KEY 注意：测试 CodePush 必须不能是 Debug 模式编译出来的 App，Debug 模式默认都会走本地 Server 热更新步骤 确认当前生效的 App 1234# 列出所有 app，确认新增的 App 生效appcenter apps list# 如果 App 不对则需要切换 Appappcenter apps set-current YourAppName 确认当前生效的 JS 版本 12# 列出生效的 JS 包appcenter codepush deployment list 发布新版本 12# 发布appcenter codepush release-react -d Release -t &quot;1.0.0&quot; --description &quot;Message&quot; 注意这里的版本号是 Native App 的版本号，每次热修复的时候都需要注意这个值 注意如果要覆盖 &gt;=2.0.0 &lt; 3.0.0 的版本，请不要使用 “~2.0.0”，覆盖不到 2.1.0，应该使用 “&gt;=2.0.0” 版本区间：如果要配置 [2.5.0, 2.5.2] 的版本区间，请到 CodePush 后台，写上 “&gt;=2.5.0 &lt;=2.5.2” 即可，注意中间是有空格的 你可以使用 -m 表示 Mandatory，强制更新，表示越快越好 附录1234# 列出生效的 JS 包的 Key（不常用）appcenter codepush deployment list -k# 发布历史appcenter codepush deployment history Release 包发布后台 Universal LinkUniversal Link 配置教程 发布 AppStoreArchive 失败正常编译真机能通过，但是 Archive 提示 library not found for -lBVLinearGradient，原因是 podfile 写的是最低系统版本是 iOS13，而 Xcode 中是 iOS10，而 Archive 是全部平台编译，所以就会导致编译 iOS10 的时候找不到对应的库。修改方法就是让这两处写法保持一致即可 每次 Archive 记得先修改 Build 号AppStore 页面设置多语言方法 1：直接设置 CFBundleDevelopmentRegion 的值为 zh_CN 和 en_US 方法 2：添加 lproj 文件 【iOS】App Store介绍页中显示的语言列表如何设置 如何添加 lproj 文件","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/AppLink 笔记/","text":"背景 双端均能使用 xxx:// 直接打开 App 双端均能使用 https://yyy.com/zzz 直接打开 App Android使用 scheme 打开打开 AppAndroidManifest.xml 中新增代码如下 123456&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;xxx&quot; /&gt;&lt;/intent-filter&gt; 使用 http 地址打开 App全程使用 Android Studio 的 App Links Assistant 即可配置完成 AndroidManifest.xml 中新增代码如下 123456&lt;intent-filter android:autoVerify=&quot;true&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;https&quot; android:host=&quot;yyy.com&quot; android:pathPrefix=&quot;/zzz&quot;/&gt;&lt;/intent-filter&gt; 将生成的 assetlinks.json 复制到网站根目录 123# ssh 登录后mkdir /var/www/html/.well-knowncp assetlinks.json /var/www/html/.well-known iOS使用 scheme 打开打开 AppInfo.plist -&gt; URL types 新增一条记录 URL identifier 随便写，URLSchemes 的第一个元素填写 xxx 使用 http 地址打开 App待补充 附录 测试用例 Android 的 AppLink 配置参考 Android APP Links 配置 安卓测试方法 生成二维码之后扫一扫 adb shell am start -W -a android.intent.action.VIEW -d “https://yyy.com/zzz?page=VIP&quot; com.your.package adb shell am start -a android.intent.action.VIEW -c android.intent.category.BROWSABLE -d “https://yyy.com/zzz?page=VIP&quot;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/LeanCloud 安全实践/","text":"本文记录一些 LeanCloud 方面的安全实践 MasterKeyMasterKey 是级别最高的 Key，会跳过所有 API 的权限检查，绝对不能泄漏 不能把 MasterKey 放到公开的代码里 如果 MasterKey 有曾经泄漏的可能性，则需要到控制台重置 AppKeyAppKey 是公开的访问密钥，适用于在公开的客户端中使用。使用 AppKey 进行的访问受到 ACL 的限制 AppKey 是内置在客户端代码中使用的 普通的 LeanCloud 请求会对 AppKey 进行加密传输而不是明文，因此抓包是无法获取 AppKey AppKey 依然有泄漏的可能性，比如通过反编译你的 App，或抓取你的 JSBundle 来获取，需要其他手段（比如 JS 混淆）来保障安全 表权限表的权限如下 add_fields：给 Class 增加新的字段，也就是说，保存对象时，如果对应列不存在，是否允许自动创建新的字段。对所有用户关闭。需要创建表的列在控制台创建即可，而不是客户端 create：在 Class 表中插入一个新对象。按需设置。比如需要登录用户才能创建一条 Record，此时 Record 的 create 权限可以改为登录用户 delete：删除既有对象。按需设置 update：修改既有对象。按需设置 find：通过指定条件查询对象。关闭此权限时，无法查询对象，只能通过 objectId 获取对象（需开启 get 权限），一定程度上可以防范别有用心的人批量抓取该 Class 下的所有对象 get：通过 objectId 获取单个对象。按需设置 列权限 按需设置即可，一般建议把 ACL/createdAt/updatedAt 都改为只读和客户端不可见 对象 ACL 权限对象，即表格中的每一行。每一个对象都有一个 ACL 字段，这可以提供最精细化的权限控制 一般由用户产生的数据（比如书影记录、User 表等），建议设置默认 ACL 权限，让 read 和 write 的权限都为 owner。这样可以防止所有记录被恶意批量删除 实践：User对于表权限：建议对所有人关闭 add_fields、delete、find、get；对所有人开启 create，否则未登录用户无法创建；只对已登录用户开放 update，但是这种无法规避已登录的有心人士篡改其他登录用户的数据，所以还是得靠对象 ACL 权限 对于对象 ACL 权限：应该为自己，但是不能简单设置为 Owner，因为创建 User 的时候，User 的 Owner 并不确定；所以得在 User 对象创建之后再更新其 ACL 云函数代码如下 123456789101112131415161718const AV = require(&#x27;leanengine&#x27;);AV.Cloud.afterSave(&#x27;_User&#x27;, function (request) &#123; var user = request.object; var acl = new AV.ACL(); acl.setPublicReadAccess(false); acl.setPublicWriteAccess(false); acl.setReadAccess(user.id, true); acl.setWriteAccess(user.id, true); user.setACL(acl); return user.save().then(function (res) &#123; console.log(res, &#x27;User Update ACL Success!&#x27;); &#125;);&#125;); 参考更详细的可以参考 LeanCloud 数据和安全","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/LeanCloud 最佳实践/","text":"数据库存在慢查询怎么办以 Record 为例，如果经常以 user 作为查询条件，那么就可以建立 user 索引 索引的本质是多维护一颗平衡树，这样查找的时候可以将 O(N) 的时间复杂度降低为 O(lgN) 索引对应的值越集中，查询效率越低，比如对性别建立索引 由于需要维护平衡树，每次写入的时候都要更新树，会影响效率，因此读多写少时更适合建立索引 本质就是以写入的时间和额外的空间来换读取的时间 唯一索引：如果索引对应的值不可能重复，则可以设置为唯一索引；反之如果可能重复则不能设置为唯一，否则当出现相同的值时插入会失败。创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。 可以通过 [数据存储] -&gt; [用量统计] -&gt; [响应时间] 检查优化效果 密集索引：每个索引都对应着一条记录；一个表只能创建一个密集索引 稀疏索引：每个索引可能对应多条记录 首先对密集索引和稀疏索引的区分在与是否为每个索引键的值都建立索引，简单来说就是比如有一列的值如下: 1、2、3、4、5、6、7 密集索引的做法是为这7个值建立索引记录，那么就有7条索引记录，抽象索引记录如下: 1:到1的指针2:到2的指针….7:到7的指针 稀疏索引的做法是将这个6个值分组，1、2、3和4、5、6和7分为不同的3组，取这三组中最小的索引键值作为索引记录中的索引值，抽象索引记录如下: 1:到顺序存储1、2、3的起始位置的指针 4:到顺序存在4、5、6的起始位置的指针 7:到顺序存储7的起始位置的指针 这两种索引都要通过折半查找或者叫做二分查找来确定数据位置，不同的是密集索引，只需要通过二分查找到搜索值=索引的索引记录就能确定准确的数据位置，而稀疏索引则需要先定位到搜索值&gt;索引值的最小的那个，然后在通过起始位置去定位具体的偏移量。这是两种不同的索引实现，一种建立了索引值与数据位置的1:1的关系，一种建立了索引值与数据位置1:n的关系。在大多数场景密集索引查询效率更高，在大多数场景稀疏索引占用空间更小。 参考： 深入浅出数据库索引原理 索引——廖雪峰 唯一索引 稀疏索引 稀疏索引 2","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/LeanCloud_Example/","text":"beforeSave 的时候获取不到对象的属性值1234567AV.Cloud.beforeSave(&#x27;GiftUserMap&#x27;, async function(request) &#123; async function reduceDiamond() &#123; let gift = request.object.get(&#x27;gift&#x27;); let giftName = gift.get(&#x27;name&#x27;) // giftName is undefined &#125;&#125; 创建对象12345678910// 方法 1：直接使用 AV.Object 的构造器const reward = new AV.Object(&#x27;Reward&#x27;);/* 方法 2：创建 AV.Object 子类，然后创建实例const Reward = AV.Object.extend(&#x27;Reward&#x27;);const reward = new Reward();*/reward.set(&#x27;name&#x27;, &#x27;Q 币 5 个&#x27;);reward.save().then((reward) =&gt; &#123; console.log(&#x27;Save Success&#x27;)&#125;) 获取对象根据键值对，返回数组 123456789new AV.Query(&#x27;Reward&#x27;) .equalTo(&#x27;objectId&#x27;, options.id) .find() .then(result =&gt; &#123; let simpleResult = jsonify(result)[0]; console.log(simpleResult); this.setData(&#123;reward: simpleResult&#125;); &#125;) .catch(console.error); 根据 ID，返回单个值 123456const query = new AV.Query(&#x27;Reward&#x27;);query.get(options.id).then((result) =&gt; &#123; let simpleResult = jsonify(result); console.log(simpleResult) this.setData(&#123;reward: simpleResult&#125;);&#125;); 一些常用的查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 等于query.equalTo(&#x27;firstName&#x27;, &#x27;Jack&#x27;);// 不等于query.notEqualTo(&#x27;firstName&#x27;, &#x27;Jack&#x27;);// 查找不包含 &#x27;doubanId&#x27; 字段的对象，doubanID 为 undefinedquery.doesNotExist(&#x27;doubanId);// 查找包含 &#x27;doubanId&#x27; 字段的对象，doubanID 不为 undefinedquery.exists(&#x27;doubanId);// 限制 age &lt; 18query.lessThan(&#x27;age&#x27;, 18);// 限制 age &lt;= 18query.lessThanOrEqualTo(&#x27;age&#x27;, 18);// 限制 age &gt; 18query.greaterThan(&#x27;age&#x27;, 18);// 限制 age &gt;= 18query.greaterThanOrEqualTo(&#x27;age&#x27;, 18);// 最多获取 10 条结果query.limit(10);// 只需要第一个结果query.first()// 跳过前 20 条结果query.skip(20);// 组合查询（连续写就行了）实现翻页效果const query = new AV.Query(&#x27;Todo&#x27;);query.limit(10);query.skip(20);// 【逻辑与】和【逻辑或】组合查询const priorityQuery = new AV.Query(&#x27;Todo&#x27;);priorityQuery.greaterThanOrEqualTo(&#x27;priority&#x27;, 3);const isCompleteQuery = new AV.Query(&#x27;Todo&#x27;);isCompleteQuery.equalTo(&#x27;isComplete&#x27;, true);const query = AV.Query.or(priorityQuery, isCompleteQuery);// 双表查询const studentQuery = new AV.Query(&#x27;Student&#x27;);const countryQuery = new AV.Query(&#x27;Country&#x27;);// 获取所有的英语国家countryQuery.equalTo(&#x27;language&#x27;, &#x27;English&#x27;);// 把 Student 的 nationality 和 Country 的 name 关联起来studentQuery.matchesKeyInQuery(&#x27;nationality&#x27;, &#x27;name&#x27;, countryQuery);studentQuery.find().then((students) =&gt; &#123; // students 包含 John Doe 和 Tom Sawyer&#125;);// 指定需要返回的属性const query = new AV.Query(&#x27;Todo&#x27;);query.select([&#x27;title&#x27;, &#x27;content&#x27;]);query.first().then((todo) =&gt; &#123; const title = todo.get(&#x27;title&#x27;); // √ const content = todo.get(&#x27;content&#x27;); // √ const notes = todo.get(&#x27;notes&#x27;); // undefined&#125;);// 统计数量const query = new AV.Query(&#x27;Todo&#x27;);query.equalTo(&#x27;isComplete&#x27;, true);query.count().then((count) =&gt; &#123; console.log(`$&#123;count&#125; 个 todo 已完成。`);&#125;);// 指针和 include 的配合使用，减少网络请求const query = new AV.Query(&#x27;Comment&#x27;);// 从所有评论中获取 10 条query.limit(10);// 查询的同时会把博客文章请求回来query.include(&#x27;post&#x27;);query.find().then((comments) =&gt; &#123; // comments 包含最新发布的 10 条评论，包含各自对应的博客文章 comments.forEach((comment) =&gt; &#123; // 该操作无需网络连接 const post = comment.get(&#x27;post&#x27;); &#125;);&#125;); 关联查询创建关联方法 1：设置 parent 字段，是指针吗？ 1234567891011121314// 创建 postconst post = new AV.Object(&#x27;Post&#x27;);post.set(&#x27;title&#x27;, &#x27;饿了……&#x27;);post.set(&#x27;content&#x27;, &#x27;中午去哪吃呢？&#x27;);// 创建 commentconst comment = new AV.Object(&#x27;Comment&#x27;);comment.set(&#x27;content&#x27;, &#x27;当然是肯德基啦！&#x27;);// 将 post 设为 comment 的一个属性值comment.set(&#x27;parent&#x27;, post);// 保存 comment 会同时保存 postcomment.save(); 方法 2：使用 createWithoutData 获取指针（建议） 12345678// 之前已经创建好的 Post，注意这里并没有发送网络请求，只是创建了一个指针const post = AV.Object.createWithoutData(&#x27;Post&#x27;, &#x27;57328ca079bc44005c2472d0&#x27;);// 创建 commentconst comment = new AV.Object(&#x27;Comment&#x27;);comment.set(&#x27;content&#x27;, &#x27;当然是肯德基啦！&#x27;);// 指向指针comment.set(&#x27;post&#x27;, post); 查询关联（基于方法 2）123456// 查询该 Post 的所有 Commentsconst query = new AV.Query(&#x27;Comment&#x27;);query.equalTo(&#x27;post&#x27;, post);query.find().then((comments) =&gt; &#123; // comments 包含与 post 相关联的评论&#125;); 12345678// 查询所有【包含图片的文章】的所有评论const innerQuery = new AV.Query(&#x27;Post&#x27;);// 得到所有包含图片的文章innerQuery.exists(&#x27;image&#x27;);const query = new AV.Query(&#x27;Comment&#x27;);// 从所有评论里面挑选跟【查询到的文章】相关的评论query.matchesQuery(&#x27;post&#x27;, innerQuery); 多对多（重要！）123456789101112var studentTom = new AV.Object(&#x27;Student&#x27;);studentTom.set(&#x27;name&#x27;, &#x27;Tom&#x27;);// 使用已有的对象var courseLinearAlgebra = AV.Object.createWithoutData(&#x27;Course&#x27;, &#x27;线性代数&#x27;);var studentCourseMapTom = new AV.Object(&#x27;StudentCourseMap&#x27;);studentCourseMapTom.set(&#x27;student&#x27;, studentTom);studentCourseMapTom.set(&#x27;course&#x27;, courseLinearAlgebra);// 注意这个操作会同时更新两个表，Student 和 StudentCourseMapstudentCourseMapTom.save(); 同步对象1234567891011const todo = AV.Object.createWithoutData(&#x27;Todo&#x27;, &#x27;582570f38ac247004f39c24b&#x27;);todo.fetch().then((todo) =&gt; &#123; // todo 已刷新&#125;);// 指定需要被刷新的属性todo.fetch(&#123; keys: &#x27;priority, location&#x27;&#125;).then((todo) =&gt; &#123; // 只有 priority 和 location 会被获取和刷新&#125;); 更新对象1234const todo = AV.Object.createWithoutData(&#x27;Todo&#x27;, &#x27;582570f38ac247004f39c24b&#x27;);// 这样只会更新指定字段todo.set(&#x27;content&#x27;, &#x27;这周周会改到周三下午三点。&#x27;);todo.save(); 有条件更新对象123456789101112131415161718const account = AV.Object.createWithoutData(&#x27;Account&#x27;, &#x27;5745557f71cfe40068c6abe0&#x27;);// 对 balance 原子减少 100const amount = -100;account.increment(&#x27;balance&#x27;, amount);account.save(null, &#123; // 设置条件：Account.balance &gt;= 100 才执行 query: new AV.Query(&#x27;Account&#x27;).greaterThanOrEqualTo(&#x27;balance&#x27;, -amount), // 操作结束后，返回最新数据。 // 如果是新对象，则所有属性都会被返回， // 否则只有更新的属性会被返回。 fetchWhenSave: true&#125;).then((account) =&gt; &#123; console.log(`当前余额为：$&#123;account.get(&#x27;balance&#x27;)&#125;`);&#125;, (error) =&gt; &#123; if (error.code === 305) &#123; console.error(&#x27;余额不足，操作失败！&#x27;); &#125;&#125;); 原子计数器可以通过原子操作来增加或减少一个属性内保存的数字，用于多个客户端同时修改一个数字 1post.increment(&#x27;likes&#x27;, 1); 原子数组操作更新数组也是原子操作。使用以下方法可以方便地维护数组类型的数据： 1234567const todo = new AV.Object(&#x27;Todo&#x27;);// 将指定对象附加到数组末尾todo.add(&#x27;arrayKey&#x27;, value)// 如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的todo.addUnique(&#x27;arrayKey&#x27;, value)// 从数组字段中删除指定对象的所有实例todo.remove(&#x27;arrayKey&#x27;, value) 如果你想导出数据/批量新增数据供 App 读取/备份RESTAPI 权限管理 设置好各个 Class 的增删改查的权限 使用 masterKey 来操作后台数据 12345678AV.init(&#123; appId: &quot;abccc&quot;, appKey: &quot;abc&quot;, serverURL: &quot;https://xxx.com&quot;, masterKey: &quot;xxx&quot;&#125;);AV.debug.enable();AV._config.useMasterKey = true;","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/RN Android 包体优化最佳实践/","text":"RN Android 包体优化最佳实践ABI 架构优化如果你的 App 只有真实设备，不使用模拟器，则可以移除 x86 架构，最佳实践如下 android/app/build.gradle 文件中 1234567891011121314android &#123; defaultConfig &#123; ndk &#123; abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot; &#125; &#125; splits &#123; abi &#123; enable false include &quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;//, &quot;x86&quot;, &quot;x86_64&quot; universalApk true &#125; &#125;&#125; enable 为 true，则会生成多个架构的 apk，除非你要单独打单架构的包，否则尽量设置为 false universalApk 为 true 时，表示生成通用 APK，该字段不会读取 include 配置，如果要过滤掉 x86 架构，需要设置 ndk.abiFilters 为你要支持的架构","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/fastlane 接入笔记/","text":"流程 安装 fastlane，不详述 初始化 fastlane 123456cd iosfastlane init# 选择 3. Automate App Store distribution# 输入 Apple 账号和密码# 可以暂时选择不管理 meta.json，后续再配置中再打开 meta.json# 根据最下面的文件进行修改即可 报错1Unable to upload archive. Failed to get authorization for username 解决方法： 打开 http://appleid.apple.com/ 创建一个 App 专用密码并复制，记为 A 修改 Fastfile，在 before_all 中添加用户名和专属密码的配置，注意写的位置 如果你需要避免 2 次密码验证，可以先写死 Session，方法为运行 fastlane spaceauth -u user@email.com 123456789101112131415default_platform(:ios)platform :ios do desc &quot;Setting User and specific password&quot; before_all do ENV[&#x27;FASTLANE_USER&#x27;] = &#x27;user@email.com&#x27; ENV[&#x27;FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD&#x27;] = &#x27;A&#x27; ENV[&#x27;FASTLANE_SESSION&#x27;] = &#x27;B&#x27; end desc &quot;Push a new release build to the App Store&quot; lane :release do ... endend 参考： https://stackoverflow.com/questions/54341690/sign-in-with-the-app-specific-password-you-generated-if-you-forgot-the-app-spec 报错卡在输入 6 位二次验证的数字密码，提示 Please enter the 6 digit code 然后不动 解决方法： 得用 fastlane spaceauth -u user@email.com 这个方式进行重新登录 报错1You can disable IAP checking by setting the `include_in_app_purchases` flag to `false` 解决方法： upload_to_app_store 函数添加 precheck_include_in_app_purchases: false 报错1[altool] 2023-09-04 20:31:52.016 *** Error: The provided entity includes an attribute with a value that has already been used The bundle version must be higher than the previously uploaded version: ‘10’. (ID: ca89416b-aae9-4059-8d53-bc7902b7a7d6) (-19232) 解决方法：新增 increment_build_number(xcodeproj: “iRead.xcodeproj”) 报错提示 error: exportArchive: No profiles for ‘com.norcy.xxx’ were found 解决方法： build_app 中添加 xcargs: “-allowProvisioningUpdates” 参数 1build_app(xcargs: &quot;-allowProvisioningUpdates&quot;)","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/iOS 提审缺少合规证明/","text":"每次提审 AppStore 都要提示缺少合规证明 其实只要在 Info.plist 添加 App Uses Non-Exempt Encryption 为 NO 即可 即 &lt;key&gt;ITSAppUsesNonExemptEncryption&lt;/key&gt;&lt;false/&gt; 参考：https://m.okjike.com/originalPosts/64d5bddbba30ac5540cfa7ea","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/开发问题记录/","text":"模拟器编译libWeChatSDK.a 链接失败报错：libwechatsdk.a’ for architecture arm64","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/App/苹果删除帐号/","text":"苹果删除帐号原理调用 Revoke 接口需要 client_id、client_secret 和 token client_id：App 的 BundleId client_secret：JWT（JSON Web Token），苹果开发者中心创建 P8 文件，对该文件使用相关信息进行签名获得 token：调用 Get Token 接口获得 调用 Get Token 接口需要 client_id、client_secret、code 和 grant_type grant_type：写死为 authorization_code code：调用苹果登录接口实时获得的 authorizationCode 注意事项： 签名、苹果接口调用最好都放服务端，客户端只负责调用 调用苹果 API 需要使用 &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; 的 Header 如何获取 P8 文件 登录开发者中心 创建 Key -&gt; 填写名字，如 sfmRelease -&gt; 勾选 Sign In with Apple -&gt; 点击 Configure -&gt; 选择 App -&gt; 下载 P8（注意只能下载一次） 记录当前页面的 Key ID 和 Team 如何生成 client_secret 将 P8 文件放到 secret_gen.rb 同级目录下 调用 secret_gen.rb，得到 client_secret 的值（如果是 dev，需要更新脚本中的 key_file、client_id、key_id） 1ruby secret_gen.rb 输出的值即为 client_secret 注意该 Key 是与 App Bundle Id 对应，如果需要独立的 debug App，那 debug App 需要重新申请 如何部署 将该值复制到 account.js 中 cd 到 LeanCloud 的云函数目录，执行 lean deploy --prod 部署到云函数即可，无需发版本即可直接生效 有效期问题这个有效期为半年，到期后调用 Get Token 接口会报错 invalid_client，导致注销账号失败 解决方法是重新生成 client_secret，并重新部署（注意 P8 文件无需重新生成和下载） 参考 苹果 Get Token API 苹果 revoke API 手把手教程 关键客户端代码 关键服务器代码 签名代码","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"App","slug":"tech/App","permalink":"https://norcy.github.io/wiki/categories/tech/App/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/BackEnd/Linux碎片/","text":"which 加上 -a 可以查看所有同名程序的位置123456$ which ruby/Users/Norcy/.rvm/rubies/ruby-2.7.1/bin/ruby$ which -a ruby/Users/Norcy/.rvm/rubies/ruby-2.7.1/bin/ruby/usr/bin/ruby","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"BackEnd","slug":"tech/BackEnd","permalink":"https://norcy.github.io/wiki/categories/tech/BackEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/BackEnd/Ubuntu/","text":"apache2 开机自动启动123456# 先确保 apache2 的命令是可用的，关闭后网页无法访问sudo systemctl stop apache2# 开启后网页可访问sudo systemctl start apache2# 以上 2 个步骤没问题之后，就可以设置开机自启动sudo systemctl enable apache2 更新 apache2 版本123456789101112131415cp -rf /etc/apache2/sites-available/ /tmp/apache2-availablecp -rf /etc/apache2/sites-enabled/ /tmp/apache2-enabledls -al /etc/apache2/sites-enabled/apache2 -version# 官方源没有最新版本，需要引入一个新的第三方源sudo add-apt-repository ppa:ondrej/apache2sudo apt update &amp;&amp; apt list --upgradablesudo apt-get install --only-upgrade apache2apache2 -versionls -al /etc/apache2/sites-enabled/# 确认没问题后移除第三方源sudo add-apt-repository -r ppa:ondrej/apache2# 重启 Apache 服务/etc/init.d/apache2 restart 参考：Ubuntu 升级 apache 版本 禁止 Apache 显示目录索引1sudo vim /etc/apache2/apache2.conf 123456&lt;Directory /var/www/&gt; #Options Indexes FollowSymLinks Options FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt; 将 Options Indexes FollowSymLinks 改成 Options FollowSymLinks 即可以禁止 Apache 显示该目录结构。解释：Indexes 的作用就是当该目录下没有指定 index.html 文件时，就显示目录结构，去掉 Indexes ，Apache 就不会显示该目录的列表了 在 vim 保存时获得 sudo 权限1:w ! sudo tee % 命令:w !{cmd}，让 vim 执行一个外部命令{cmd}，然后把当前缓冲区的内容从 stdin 传入。 tee 是一个把 stdin 保存到文件的小工具。 而 %，是vim当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。 所以执行这个命令，就相当于从vim外部修改了当前编辑的文件。 Ubuntu Apache2 的启动/重启/停止 启动 1/etc/init.d/apache2 start 重启 1/etc/init.d/apache2 restart 停止 1/etc/init.d/apache2 stop php 实现 RESTful api 修改 Apache 配置，/etc/apache2/apache2.conf，将以下配置从 AllowOverride None 改为 AllowOverride All 123456&lt;Directory /var/www/&gt; #Options Indexes FollowSymLinks Options FollowSymLinks AllowOverride All Require all granted&lt;/Directory&gt; 到网站的根目录下 /var/www/html，新增或修改 .htaccess 文件，如下 1234567# 开启 rewrite 功能Options +FollowSymlinksRewriteEngine on# 重写规则RewriteRule ^MiniPro/fmlist$ ./MiniPro/RestController.php?fm=all [nc,qsa]RewriteRule ^MiniPro/fmlist/([0-9]+)$ ./MiniPro/RestController.php?fm=single&amp;id=$1 [nc,qsa] 重写规则使用正则表达式来匹配 URL，进而路由到指定的页面，其中 nc 表示不区分大小写（No Case），qsa 表示可以在 URL 后面添加参数字符串（Query String Append） 更多详细可以参照 PHP RESTful 需要注意的是 SiteRestHandler.php 这个文件中的 $this -&gt;setHttpHeaders($requestContentType, $statusCode); 这句代码需要注释才能工作 如果要读取 POST 参数使用 $_POST 是读取不到的，可使用 1$postData = json_decode(file_get_contents(&#x27;php://input&#x27;), true); 来获取 POST 参数 我自己实现的例子：https://github.com/Norcy/SmallFrequence.git Ubuntu Apache2 配置 HTTPS 申请 SSL 证书：包括 apache.crt apache.key server-chain.crt 注意，腾讯云下载时选择 Apache（crt文件、key文件）类型，证书名字可能分别对应为 norcy.xyz.crt norcy.xyz.key root_bundle.crt 拷贝证书到 /etc/apache2/cert 目录下 1scp -r ~/Desktop/norcy.xyz_apache ubuntu@111.230.246.127:/etc/apache2/cert/ 创建site-enabled 指向site-available的软链接 1sudo ln -s /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled/001-ssl.conf 修改/etc/apache2/sites-enabled/001-ssl.conf，关注 ServerName，SSLCertificateFile，SSLCertificateKeyFile，SSLCertificateChainFile 123456789101112131415&lt;VirtualHost *:443&gt; ServerName norcy.xyz ServerAdmin webmaster@localhost DocumentRoot /var/www/html SSLEngine On SSLOptions +StrictRequire SSLCertificateFile /etc/apache2/cert/apache.crt SSLCertificateKeyFile /etc/apache2/cert/apache.key SSLCertificateChainFile /etc/apache2/cert/server-chain.crt ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt; 强制 HTTPS 访问：在网站根目录下新建文件 .htaccess 文件，写入内容 1234RewriteEngine onRewriteBase / RewriteCond %&#123;SERVER_PORT&#125; !^443$RewriteRule ^.* https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R] 重启 1234567// 加载Apache的SSL模块$ sudo a2enmod ssl// 然后，重启Apache $ sudo /etc/init.d/apache2 restart // 这时浏览器应该就可访问了// 可选，记得重启一下 pm2 服务$ j pay$ yarn restart Ubuntu Apache2 更新 HTTPS 证书 到腾讯云申请新的证书，填写域名（不用包含 www），域名验证方式选择自动 DNS 验证 即可秒生效。显示已签发后下载证书 重复上面配置步骤的 Step 1、2、6 即可 点击 Chrome 地址栏前面的加密标志，可以查看证书时间以此判断是否生效 基础知识 网页文件存放在 /var/www/html 以指定用户执行命令由于权限全部给了 www-data，所以使用 ubuntu 账户进行 git 操作的时候，需要添加 sudo 或者 sudo -u www-data git push 切换用户 12sudo -isu - www-data 正确的操作姿势是以 www-data 操作 .git 目录全部改为 www-data:www-data 文件上传与下载 下载 wx 文件夹 到本地 1scp -r [-P 端口号] ubuntu@111.230.246.127:/var/www/html/PublicAccount ~/Desktop/wx/ 上传 test.txt 到 www 目录 1scp [-r] [-P 端口号] /var/www/test.txt root@192.168.0.101:/var/www/ ubuntu 的终端文件名显示乱码或问号直接修改当前用户目录下的 .zshrc 文件，在最后添加如下： 1234export LC_ALL=&quot;zh_CN.utf8&quot;export LANG=&quot;zh_CN.utf8&quot;export LC_ALL=&quot;zh_CN.utf8&quot;export LC_CTYPE=&quot;zh_CN.utf8&quot; 然后 source ~/.zshrc 生效 如果还是不行，可以打印 locale 命令，如果提示 123locale: Cannot set LC_CTYPE to default locale: No such file or directorylocale: Cannot set LC_MESSAGES to default locale: No such file or directorylocale: Cannot set LC_ALL to default locale: No such file or directory 解决方法为： 需要安装中文语言包 1sudo locale-gen zh_CN.utf8 设置语言环境 1sudo vim /etc/locale.conf 添加 1LANG=zh_CN.utf8 更新语言环境配置 1sudo update-locale LANG=zh_CN.utf8 重新打印 locale 命令，如果打印以下则问题解决 123456789101112131415LANG=zh_CN.utf8LANGUAGE=LC_CTYPE=&quot;zh_CN.utf8&quot;LC_NUMERIC=&quot;zh_CN.utf8&quot;LC_TIME=&quot;zh_CN.utf8&quot;LC_COLLATE=&quot;zh_CN.utf8&quot;LC_MONETARY=&quot;zh_CN.utf8&quot;LC_MESSAGES=&quot;zh_CN.utf8&quot;LC_PAPER=&quot;zh_CN.utf8&quot;LC_NAME=&quot;zh_CN.utf8&quot;LC_ADDRESS=&quot;zh_CN.utf8&quot;LC_TELEPHONE=&quot;zh_CN.utf8&quot;LC_MEASUREMENT=&quot;zh_CN.utf8&quot;LC_IDENTIFICATION=&quot;zh_CN.utf8&quot;LC_ALL=zh_CN.utf8 ubuntu 免密登录 本地生成公钥和私钥 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 默认保存位置为 ~/.ssh/id_rsa，id_rsa.pub 是公钥，如果已存在，则跳过此部分 将公钥添加到服务器的 authorized_keys 文件中 1ssh-copy-id username@remote_host 测试 1ssh username@remote_host 如果失败，则到服务器上查看失败信息 1sudo tail -f /var/log/auth.log 如果出现 Authentication refused: bad ownership or modes for file /home/ubuntu/.ssh/authorized_keys，则 12345chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.sshchown -R ubuntu:ubuntu ~/.sshchmod go-w ~sudo service ssh restart # 重启 ssh 服务 ubuntu ssh 登录不一会就超时断开方法 1：修改 SSH 服务端配置（推荐） 编辑 SSH 服务端配置文件： 1sudo vim /etc/ssh/sshd_config 在文件末尾添加以下配置（调整数值）： 1234# 服务端每 60 秒向客户端发送一次保活信号ClientAliveInterval 60# 允许最多 3 次无响应后才断开连接（总时间 = 60 * 3 = 180 秒）ClientAliveCountMax 3 保存文件并重启 SSH 服务： 123sudo systemctl restart ssh# 或sudo service ssh restart 方法 2：修改 SSH 客户端配置如果无法修改服务端配置，可以在客户端设置保活参数： 1vim ~/.ssh/config 添加以下内容（针对特定服务器或所有连接）： 123Host * ServerAliveInterval 60 # 客户端每 60 秒发送一次保活信号 ServerAliveCountMax 3 # 允许最多 3 次无响应后断开 保存文件，后续 SSH 连接将使用此配置","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"BackEnd","slug":"tech/BackEnd","permalink":"https://norcy.github.io/wiki/categories/tech/BackEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"tech/BackEnd/如何构建一个 NodeJS 后台服务/","text":"前言一个前端开发如何摆脱 PHP 去构建后台服务 目标 使用 JS 作为语言 支持 GET/Post 支持指定路由 支持 HTTPS 支持服务持续运行 环境要求 Linux 服务器一台 确保有 NodeJs 环境 Linux 已支持 HTTPS 访问（有证书） 创建工程Step 1：初始化一个 NodeJs 工程后，安装 express 模块1234mkdir MyServercd MyServeryarn init -y # 使用 -y 跳过交互，使用默认配置yarn add express Step 2：创建 index.js，实现基础的 post/get，实现 HTTPS 功能，以及指定路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import express from &#x27;express&#x27;;import fs from &#x27;fs&#x27;;import https from &#x27;https&#x27;;// 个人配置const port = 3333;const privateKeyPath = &#x27;/etc/apache2/cert/apache.key&#x27;;const certificatePath = &#x27;/etc/apache2/cert/apache.crt&#x27;;const intermediatePath = &#x27;/etc/apache2/cert/server-chain.crt&#x27;;const app = express();// 测试代码app.get(&quot;/test/get&quot;, (req, res) =&gt; &#123; res.send(&quot;hello world&quot;);&#125;);app.post(&quot;/test/post&quot;, (req, res) =&gt; &#123; var post = &quot;&quot;; // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 req.on(&quot;data&quot;, (chunk) =&gt; &#123; post += chunk; &#125;); // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 req.on(&quot;end&quot;, async () =&gt; &#123; post = JSON.parse(post); console.log(&quot;post&quot;, post); res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;); res.write(JSON.stringify(post)); res.end(); &#125;)&#125;);// 通用代码const DEV = false;if (!DEV) &#123; // 线上环境使用 HTTPS var privateKey = fs.readFileSync(privateKeyPath, &#x27;utf8&#x27;); var certificate = fs.readFileSync(certificatePath, &#x27;utf8&#x27;); var intermediate = fs.readFileSync(intermediatePath, &#x27;utf8&#x27;); var credentials = &#123;key: privateKey, cert: certificate, ca: [intermediate]&#125;; https.createServer(credentials, app).listen(port, () =&gt; &#123; console.log(`Server running at https://0.0.0.0:$&#123;port&#125;/`); &#125;);&#125; else &#123; // 本地使用 HTTP 调试 app.listen(port, () =&gt; &#123; console.log(`Server running at http://0.0.0.0:$&#123;port&#125;/`); &#125;);&#125; 注意事项： 关于端口指定，除了在代码中指定，还需要到云服务器配置里面打开。详见腾讯云的教程链接。该例子中，来源设置为 0.0.0.0/0，协议端口设置为 TCP:3333，注意端口最好在 3306-20000 范围内，避免与周知端口冲突。 注意代码中 listen 的时候只需要指定 port 即可，host 可不填，默认是 0.0.0.0，代表本机所有 IPv4 的地址均可 NodeJs 指定路由比较麻烦，使用 express 就是为了轻松配置，该例子中，可向 https://x.x.x.x:3333/test/get 发送 GET 请求，Post 同理 关于 HTTPS 的配置 HTTPS 的关键就在于代码中三个文件的路径配置，这里不讨论如何配置 HTTPS 证书，但需要了解的是，这三个证书是申请 HTTPS 域名的时候服务商会提供的，配置的时候只需要把服务器里面证书的文件路径替换为自己的即可。 本例子是使用腾讯云，有 apache.key、apache.crt 和 server-chain.crt 这三个文件，不用纠结后缀名，本质都是 txt 其中最关键的是 server-chain.crt 这个中级证书，详见下面 如何本地调试？ 将例子中的 DEV 改为 true，本地执行 node index.js，即可使用本地调试 Step 3：后台保活默认情况下，NodeJs 起的服务会卡住当前的终端窗口，当我们关闭窗口或者断开服务器 ssh 连接时，该服务会同时中断。另外 NodeJs 服务如果代码逻辑抛出错误了，也可能会中断。为了实现以下两个目标，我们可以使用 pm2 来进行后台保活 即使断开当前的终端链接也不会影响 NodeJs 服务 即使 NodeJs 服务挂了能自动重启 安装 pm2 1npm install -g pm2 启动服务 1pm2 start index.js 终止服务 1pm2 stop index.js 这样即可实现 NodeJs 服务稳定运行 附录：HTTPS 配置的坑配置 HTTPS 时有一个大坑，网上很多教程都忽略了 credentials 中的 ca 配置，如果缺少了 ca，即缺少了 server-chain.crt 这个证书，会导致从浏览器访问网站（比如 https://x.x.x.x:3333/test/get）是正常且安全的，即使用 Chrome 地址栏左侧的检测也都是安全的，使用 Postman 工具去模拟请求也是正常回包的。但是从 Android App 访问该请求，App 却会提示 Network request failed，经过断点，底层抛出的错误是 java.security.cert.CertPathValidatorException: Trust anchor for certification path not found 经过调研，根本原因就是服务器的 HTTPS 配置缺少中级证书。 什么是中级证书什么是中级证书？需要先了解下 HTTPS 证书链的信任：根证书 -&gt; 中级证书 -&gt; 服务器 根证书：受权威机构信任，已经在用户设备中存储； 中级证书：由根证书签名而得到信任，负责给下一级的证书签名； 服务器证书：由中级证书签名而得到信任 为什么会有中级证书？原因是根证书太宝贵了，而颁发证书的风险太大。于是根证书颁发了很多中级证书，即 CA （证书颁发机构）用自己的私钥进行签名，使中级证书可信任。CA 有了中级证书之后，以后就都用中级证书自己的私钥来签名并颁发给最终用户 SSL 证书（即服务端配置的证书）。当安全事件发生时，不需要撤销根证书，只需撤销中级证书，就可以使从该中级证书发出的证书组不受信任。 如何获取缺失的中级证书一般来说，无论有多少中级证书，服务商都会全部给你。但假如中级证书丢失了，该如何获取？以下是常用的命令 使用 openssl 查看服务器的证书详细情况，并保存在 log.txt 1openssl s_client -connect YourDomain:YourPort -servername YourDomain:YourPort | tee log.txt 此时如果有中级证书的问题，日志里面会出现下面的错误 12verify error:num=20:unable to get local issuer certificateverify error:num=21:unable to verify the first certificate 从日志中提取证书 url，复制里面出现的 http 地址 1openssl x509 -in log.txt -noout -text | grep -i &quot;issuer&quot; 下载证书 1curl --output intermediate.crt 刚提取的地址 转成 .pem 文件 1openssl x509 -inform DER -in intermediate.crt -out intermediate.pem -text 其他注意点值得注意的是，假如 Android 访问成功一次后，再把 ca 配置下掉，也依然能正常访问，推测是设备会缓存已信任过的中级证书。所以真正判断 HTTPS 地址是否生效的标准依然是上述的 openssl 命令 另外，中级证书可能是 0 个也可能是多个，所以 ca 是可选的，类型是一个数组 常用命令关闭 NodeJS 服务进程假如 NodeJS 服务的端口为 3333 12sudo lsof -i :3333 # 找到 pidkill -9 YourPid # 填入对应的 pid pm2 启动1pm2 start index.js --watch # 实时监控 js 的方式启动，当 js 文件有变动时，pm2 会自动 reload pm2 查看进程123pm2 list # 启动的所有的应用程序pm2 show [app-name或 id] # 显示应用程序的所有信息pm2 info [app-name或 id] # 显示应用程序的所有信息 pm2 查看日志123pm2 logs # 显示所有应用程序的日志pm2 logs [app-name或 id] # 显示指定应用程序的日志pm2 flush #清空日志 pm2 开启自启动1234pm2 start index.js # 先启动你需要的服务pm2 save # 保存当前的程序pm2 startup ubuntu #其他平台同理，复制得到的命令# 粘贴刚得到的命令即可 参考 How to Create an HTTPS NodeJS Web Service with Express Unable to verify the first certificate in nodejs PM2 开启启动命令","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"BackEnd","slug":"tech/BackEnd","permalink":"https://norcy.github.io/wiki/categories/tech/BackEnd/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"arch/面试/网络/TCP 三次握手/","text":"三次握手的过程 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 第一次握手：客户端发送 SYN=1，seq=x（SYN=1 的报文段不能携带数据，但要消耗掉一个序号），此时客户端处于 SYN_SENT 状态 第二次握手：服务器回复 SYN=1，ACK=1，ack=x+1，seq=y，此时服务器处于 SYN_RCVD 的状态 第三次握手：客户端回复 ACK=1，ack=y+1，seq=x+1，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。 ACK 报文段可以携带数据，不携带数据则不消耗序号 注意：不要混淆 ACK 标志位和 ack 确认序列号，ACK 标记位为 1 表示这是包一个确认包，而 ack 确认序列号是 Acknowledgement Number，是对对方初始序列号的回复（ack = x+1），对方以此确认该报文是对其 SYN 报文的回复。ack 确认序列号只有在 ACK 标记位为 1 时才有效 为什么是三次握手TCP 的可靠连接是靠 seq（sequence numbers 序列号）来达成的。 TCP 设计中一个基本设定就是，通过 TCP 连接发送的每一个包，都有一个 sequence number。而因为每个包都是有序列号的，所以都能被确认收到这些包。 确认机制是累计的，所以一个对 sequence number X 的确认，意味着 X 序列号之前 (不包括 X) 包都是被确认接收到的。 所以这样就有一个问题：这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？这就需要独一无二的 ISN（初始序列号）机制。 那么 TCP 连接握手，握的是啥？ 三次握手是为了双方确定彼此的初始序列号 注意：seq = x，这个 x 就是初始序列号 如果是四次握手： 1.1 A 发送同步信号 SYN + A 的初始序列号（Initial sequence number，简称 ISN） 1.2 B 收到后回包，并记录 A 的初始序列号到本地 1.3 B 发送同步信号 SYN + B 的初始序列号 1.4 A 收到后回包，并记录 B 的初始序列号到本地 这样，A 和 B 就互相确认了彼此的初始序列号。但很显然 1.2 和 1.3 这两个步骤可以合并，只需要三次握手 如果是两次握手 2.1 A 发送同步信号 SYN + A 的初始序列号 2.2 B 收到后，发送同步信号 SYN + B 的初始序列号 这种情况，A 的初始序列号双方都知道；但是 B 的初始序列号，B 无法确定 A 是否知道 中途丢包的情况 第一个包，即 A 发给 B 的 SYN 中途被丢，没有到达 B A 会周期性超时重传，直到收到 B 的确认 第二个包，即 B 发给 A 的 SYN+ACK 中途被丢，没有到达 A B 会周期性超时重传，直到收到 A 的确认 第三个包，即 A 发给 B 的 ACK 中途被丢，没有到达 B A 发完 ACK，单方面认为 TCP 为 Established 状态，而 B 显然认为 TCP 为 Active 状态 这种情况下 A 会超时重传这个 ACK 吗？不会！TCP 不会为没有数据的 ACK 超时重传 a. 假定此时双方都没有数据发送，B 会周期性超时重传，直到收到 A 的确认，收到之后 B 的 TCP 连接也为 Established 状态，双向可以发包 b. 假定此时 A 有数据发送，B 收到 A 的 Data + ACK，自然会切换为 established 状态，并接受 A 的 Data c. 假定 B 有数据发送，数据发送不了，会一直周期性超时重传 SYN + ACK，直到收到 A 的确认才可以发送数据 三次握手过程中可以携带数据吗？其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据 为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。 也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。 对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病 SYN 攻击是什么？服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。 SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。 参考资料 TCP 为什么是三次握手，而不是两次或四次？ TCP 为什么是四次挥手，而不是三次？ 面试官，不要再问我三次握手和四次挥手","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"arch/面试/网络","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"arch/面试/网络/TCP 与 UDP/","text":"对比 UDP TCP 是否连接 无连接 面向连接（三次握手） 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，有序列号，确认号，超时重传等，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多通信 只能是一对一 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅 8 字节 首部最小 20 字节，最大 60 字节 适用场景 适用于实时应用（微信语音、视频聊天） 适用于要求可靠传输的应用，例如文件传输 总结UDP 无连接，不可靠，传输快","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"arch/面试/网络","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"arch/面试/网络/TCP 四次挥手/","text":"四次挥手的过程 TCP 三次握手，一定是客户端先发起连接；而 TCP 四次挥手，发起中断连接的既可以是客户端，也可以是服务器。 本文以客户端先发起请求为例，刚开始双方都处于 ESTABLISHED 状态。 从报文的角度上看，四次挥手的过程如下： 第一次挥手：客户端发送一个 FIN 报文（FIN=1，seq=u），进入 FIN_WAIT1 状态，等待服务端的确认，并停止发送数据 第二次挥手：服务端回复 ACK 报文（ACK=1，ack=u+1，seq=v），表明已经收到客户端的报文了，进入 CLOSE_WAIT 状态 客户端收到服务端的确认后，进入 FIN_WAIT2 状态，等待服务端的 FIN 报文。 第三次挥手：如果服务端数据发送完毕想断开连接了，发送 FIN 报文（FIN=1，ACK=1，seq=w，ack=u+1）。进入 LAST_ACK 的状态，等待客户端的确认。 第四次挥手：客户端回复 ACK 报文（ACK=1，seq=u+1，ack=w+1），进入 TIME_WAIT 状态，等待 2MSL 后进入 CLOSED 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状 从发送和接受数据的能力上看，四次挥手的过程如下： 第一次挥手：客户端不再发送数据；服务器知道客户端不再发送数据 第二次挥手：服务器对客户端 FIN 的确认，依然可能继续发送数据；客户端收到后会继续接收数据 第三次挥手：服务器数据发送完毕后发起第三次挥手，表示服务器不再发送数据；客户端收到后会等 2MSL 后关闭连接，不再接收数据 第四次挥手：服务器收到后关闭连接 什么是 MSL，为什么需要等 2MSLMSL（Maximum Segment Lifetime），即报文段最大生存时间。可以简单理解为，报文段在网络内存在的最长时间，如果超过这个时间，报文段就会被丢弃。 根据第三版《UNIX 网络编程 卷 1》2.7 节，TIME_WAIT 状态的主要目的有两个： 优雅的关闭 TCP 连接，也就是尽量保证被动关闭的一端收到它自己发出去的 FIN 报文的 ACK 确认报文； 处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接。 注：很多博文只讨论了第一点，并且轻易的给出了错误的理由：最坏情况，ACK 报文的发送和 FIN 报文的重传各自需要 1MSL，因此是 2MSL。仔细想想之后，这些人的文章简直就是不经脑子的生搬硬套 假设 A 是主动关闭的一方，B 是被动关闭。 假如现在 A 收到 FIN 之后，为了实现目标 1，即保证 B 能够收到自己的 ACK 报文。那么 A 完美的等待时间不是 2MSL，而应该是从 B 发送第一个 FIN 报文开始计时到它最后一次重传 FIN 报文这段时长加上 MSL。但这个计算方式过于保守，只有在所有的 ACK 报文都丢失的情况下才需要这么长的时间；另外，第一个目标虽然重要，但并不十分关键，因为既然已经到了关闭连接的最后一步，说明在这个 TCP 连接上的所有用户数据已经完成可靠传输，所以要不要完美的关闭这个连接其实已经不是那么关键了。因此，（我猜）RFC 标准的制定者才决定以网络丢包不太严重为前提条件，然后根据第二个目标来计算 TIME_WAIT 状态应该持续的时长。 等待 2MSL 的真正目的是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接，换句话说，就是为了让此次 TCP 连接中的所有报文在网络中消失。 假如现在 A 发送 ACK 后，最坏情况下，这个 ACK 在 1MSL 时到达 B；此时 B 在收到这个 ACK 的前一刹那，一直在重传 FIN，这个 FIN 最坏会在 1MSL 时间内消失。因此从 A 发送 ACK 的那一刹那开始，等待 2MSL 可以保证 A 发送的最后一个 ACK，和 B 发送的最后一个 FIN 都在网络中消失 注：B 超时重传的时间并不是 2MSL；2MSL 时间为 240 秒，这是协议标准，一般超时重传只有 0.5 秒、1 秒、2 秒、4 秒……小于 MSL 为什么需要四次挥手类比 TCP 的三次握手，这个问题可以理解为为什么服务器的 ACK 报文和 FIN 报文不能合并在一起发送？ 原因是第一次挥手仅仅代表着客户端不再发送数据，而服务器收到 ACK 之后，可能还有数据想要发送给客户端，所以等待服务器发送完毕数据之后，才会继续发送 FIN 报文，因此无法合并发送 参考资料 面试官，不要再问我三次握手和四次挥手 为什么 tcp 的 TIME_WAIT 状态要维持 2MSL","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"arch/面试/网络","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"arch/面试/网络/iOS 如何防止被抓包/","text":"背景想抓订阅号助手的请求，看能否实现公众号推文自动发布，结果用 Stream 抓包软件抓不到任何的请求，但是请求却正常发送了 疑问如何既能正常发出请求，又能不被抓包软件（如 Stream）抓到任何请求 方法只要 Hook NSURLSessction 的方法，将其中 configuration 的 connectionProxyDictionary 清空即可 其中部分关键代码如下 1234567891011121314151617181920212223+ (NSURLSession *)dp_sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id&lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue&#123; if (!configuration) &#123; configuration = [[NSURLSessionConfiguration alloc] init]; &#125; if (isDisableHttpProxy) &#123; configuration.connectionProxyDictionary = @&#123;&#125;; &#125; return [self dp_sessionWithConfiguration:configuration delegate:delegate delegateQueue:queue];&#125;+ (NSURLSession *)dp_sessionWithConfiguration:(NSURLSessionConfiguration *)configuration&#123; if (configuration &amp;&amp; isDisableHttpProxy) &#123; configuration.connectionProxyDictionary = @&#123;&#125;; &#125; return [self dp_sessionWithConfiguration:configuration];&#125; 详细代码请见 https://github.com/Norcy/DisableHttpProxy","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"arch/面试/网络","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"arch/面试/网络/计算机网络基础/","text":"OSI 七层模型、TCP/IP 五层模型、与 TCP/IP 四层模型 数据传递时，每层都会在上一层的报文添加自己的头部 应用层HTTP、FTP、SMTP、DNS 传输层TCP、UDP 网络层IP、ICMP（Internet 控制报文协议） ping 使用的是 ICMP 协议 链路层ARP、RARP ARP：IP 地址 -&gt; MAC 地址RARP：MAC 地址 -&gt; IP 地址 问：ARP 属于哪一层TCP/IP 模型中，它所有定义的协议是在网络层上的 按照 OSI 的标准，数据在传递时每层会加上自己的信息。当网络层的 IP 包进入链路层时，链路层通过 ARP 协议添加链路信息，因此属于链路层 在 OSI 七层模型中 ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层 问：当在浏览器中输入 www.baidu.com 的时候发生了什么一、DNS 域名解析先查本地 hosts 文件，如果没命中则主机会向 DNS 服务器发送一条 DNS 查询报文以查询该域名对应的 IP 注意，该报文是 UDP 报文，不需要与 DNS 服务器建立 TCP 连接；我们这台主机本来就知道 DNS 服务器的 IP 地址，要么是写好的静态 IP，要么是路由器动态分配的 IP，不是域名，所以 DNS 查询这个过程也不需要去解析域名 二、建立 TCP 连接传输层拿到了应用层解析到的 IP 地址，开始与服务器进行三次握手，建立 TCP 连接 三、发送 HTTP 请求建立连接后，应用层开始向服务器发送请求，服务器返回相应的结果 四、关闭 TCP 连接为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建 TCP 连接的 3 次握手类似，关闭 TCP 连接，需要 4 次握手。 五、浏览器解析 HTML、JS、CSS、JsonDom 数、CSS 规则集、Render 树","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"arch/面试/网络","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/"}]},{"title":"","date":"2025-04-20T05:50:42.949Z","path":"arch/面试/网络/重放攻击/","text":"背景今天想从【今日热榜】这个 App 中获取榜单的 Get 请求，从而可以“借”它们的数据做个榜单类的小程序。用 Charles 抓手机的包之后，发现可以抓取到一个 Get 请求，回包的内容也正确被抓取了，可是当我复制这段 Get 请求的 url 到浏览器的时候，发现没有对应的回包了 奇怪，为什么会这样呢，决定开始研究下 分析url 是类似以下结构 1http://api.tophub.today/nodes/128?nonce=xxx&amp;sign=yyy&amp;timestamp=123 主要有 3 个字段：nonce、sign 和 timestamp 基于这几个关键词去搜索，发现原来我这种行为属于【重放攻击】 什么是重放攻击假如我们要通过 Get 请求传递用户的用户名和密码，明文传输的例子如下 1http://api.tophub.today/nodes/128?id=hello&amp;password=1234 这是裸奔，我们没这么蠢，于是对 password 进行 MD5 加密之后再传输，如下 1http://api.tophub.today/nodes/128?id=hello&amp;sign=md5(password) 其中 sign 的常用加密算法为 MD5，MD5 算法是一种不可逆算法，也就是说你加密之后就不能解密了 服务器的验证方法就是根据 id 从数据库查出用户的密码，再对其进行 MD5 加密，得到的结果与 sign 的值进行对比，如果相同则请求合法，反之则 sign 被篡改过 黑客通过抓包获取到该链接，他无法破解加密信息得到用户密码；但是他只要模拟此次的正常请求，就可以伪装成客户端同服务器通信。这样至少可以做两件事，第一件是跟我一样，可以随时随地模拟客户端取服务器的数据；第二件事是可以疯狂发送该请求致使服务器繁忙 如何防止重放攻击时间戳首先我们假设一次 HTTP 请求从发出到到达服务器的时间是不会超过 60s 的，而黑客获取链接到篡改链接再发送到服务的时间会超过 60s（不要问为什么是 60s，继续往下看） 当你发送一个请求时必须携带一个当前的时间戳 timestamp。假设值为 10 为了防止黑客修改时间戳，需要将 timestamp 也进行 MD5，放到 sign 中，如下 1?id=hello&amp;sign=md5(password+timestamp)&amp;timestamp=10 当请求到达服务器之后，服务器会获取当前时间，假设为 t2 = 80，很明显 t2 - timestamp &gt; 60s，那么服务器就认为请求不合法。因为这个请求从客户端到服务器的时间竟然超过 60s。如果在 60s 内，再进行一次 md5 校验，检查 timestamp 有没有被篡改（一旦 timestamp 被篡改过，算出来的 md5 值一定与 sign 不同） 问题来了，如果黑客在 60s 内发起请求，这种方法就失效了 随机数我们加入一个随机数 nonce，每次成功请求，服务器会保存当前成功请求的随机数 nonce 到缓存或数据库中，当请求再次进到服务器，判断携带的随机数 nonce 是否在缓存或者数据库中已经存在，如果存在，则认为请求非法 url 如下 1?id=hello&amp;sign=md5(password+nonce)&amp;nonce=31415 同理，为了防止 nonce 被篡改，需要将 nonce 进行 MD5 加密到 sign 随机数的出现保证了请求的唯一性，但是存储 nonce 的集合会越来越大，为了防止 nonce 集合无限大，需要定期清理该集合，但是一旦该集合被清理，我们就无法验证被清理了的 nonce 参数了。比如，假设该集合平均1天清理一次的话，我们抓取到的该 url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的 nonce 参数，也是一笔不小的开销 当然随机数还得确保唯一性 时间戳+随机数时间戳屏蔽了 60s 后的请求，而 60s 内重复的请求可以用随机数来过滤 url 如下 1?id=hello&amp;sign=md5(password+timestamp+nonce)&amp;timestamp=10&amp;nonce=31415 配合时间戳，服务器只要每次有新的请求进来的时候，确保此次请求没有被篡改的前提下，如果新请求带来的 timestamp 比最后一次更新 nonce 集合的时间晚 60秒，那么就可以清除 nonce 缓存了 12345678910111213141516171819202122232425262728// 判断 time 参数是否有效if ($curTime - $time &gt; 60)&#123; die(&quot;请求超时&quot;);&#125;// 判断 nonce 参数是否在集合已存在if (in_array($nonce, $nonceArray))&#123; die(&quot;请求仅一次有效&quot;);&#125;// 验证数字签名 if ($sign != md5($password.$time.$nonce))&#123; die(&quot;数字签名验证失败&quot;);&#125;// 判断是否需要清理nonce集合if ($curTime - $nonceArray-&gt;lastModifyTime &gt; 60)&#123; $nonceArray = null;&#125;// 记录本次请求的 nonce 参数$nonceArray.push($nonce);//开始处理合法的请求 参考 Web安全防范—–防止重放攻击 基于timestamp和nonce的防止重放攻击方案","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"arch/面试/网络","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/C++多态/","text":"多态父类指针指向一个子类对象，调用父类声明的方法后，实际上调用的是子类的实 1234567891011121314151617class A&#123;public: virtual void f()&#123;&#125;; virtual void g()&#123;&#125;; int a;&#125;;class B : public A&#123;public: void g()&#123;&#125;; int b;&#125;;A *pA = new B();pA-&gt;g(); 多态的实现原理（虚函数的实现原理）多态是通过虚函数实现的，如果不声明 virtual 的情况下，无法正确调用到子类的实现： 编译器编译时需要确定每个对象调用的函数（非虚函数）的地址，这称为早期绑定，当子类对象的地址赋给父类指针后，C++ 编译器进行了类型转换，将子类对象当成父类处理，从而调用了父类的函数实现。 实现原理：虚函数表+虚表指针 每个类使用一个虚函数表，每个类对象用一个虚表指针。（注意对象和类的区别） 基类对象包含一个虚表指针，指向基类中的虚函数表。子类对象也将包含一个虚表指针，指向子类虚函数表 如果子类重写了基类的虚函数，该子类的虚函数表将保存重写的虚函数地址，而不是基类的虚函数地址 如果子类没有重写基类的虚函数，该子类的虚函数表将保存基类的虚函数地址。如果子类定义了新的虚函数，则该虚函数地址会被添加到子类的虚函数表中 内存布局： A 类的虚函数表（注意是类，而不是对象）： 12A::f 的地址A::g 的地址 B 类的虚函数表（注意是类，而不是对象）： 12A::f 的地址B::g 的地址 // 存放了重写的地址 如果执行 B b;，b 的内存布局如下 123vptr： 指向 B 的虚表 vtableB // 虚表指针int a： 继承 A 的成员 // 继承了 A，所以有 aint b： B 自己的成员 // 自己的成员变量 如果执行 A *pA = new B(); pA 的内存布局同普通的 A 对象一致，除了虚函数指针，如下 12vptr： 指向 B 的虚表 vtableB // 虚表指针int a： A 的成员 这种情况下 pA 是无法访问到定义在 B 中的 b 对象的 执行 pA-&gt;g(); 时，编译器知道的是，g 是一个声明为 virtual 的成员函数，而且其入口地址放在虚表的第二个（无论是A 的虚表还是B 的虚表），那么编译器就会去 B 的虚表中查找，得到了 B::g 的地址，从而实现了多态","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/C++ 与 Objetive-C 的区别/","text":"重载在 C++ 中，重载指的是函数名相同，但是参数类型或参数个数不同的函数；而在 OC 中是不支持重载的 C++ 区别函数是通过函数签名，函数签名包括函数名、参数类型和参数个数（注意没有返回值，因为只有返回值不同的函数编译器是无法确定应该调用哪个函数） OC 中 Method 的 key 是 Selector，这个只有方法名，不含参数类型和参数个数，因此无法支持重载 多态（重写） C++：子类的函数覆盖了父类的 virtual 同名函数；通过虚函数表、虚函数指针来实现，子类和父类有不同的虚函数表。单纯创建一个子类对象时，其类的内存布局是子类的，虚函数指针会指向子类虚函数表；而创建一个父类指针指向的子类对象时，其类的内存布局是父类的，其虚函数指针会指向子类的虚函数表 OC：objc_msgSend 过程中通过 isa 指针找到对应的类对象/元类对象，查找其方法列表，如果找不到则往继承链向上找 如果真的要联系对比，那么 C++ 中父类的虚函数表就好比 OC 中父类类对象的方法列表，表明其内存结构；而 C++ 中的虚函数指针就好比 OC 中的 isa 指针，表明真正指向的类 延伸阅读 C++多态 重定义 C++：子类的函数覆盖了父类的非 virtual 函数；此时子类的函数中将会屏蔽父类的同名函数 OC：同多态小节，OC 中的重写和重定义本质上都是消息发送，都是通过 isa 指针查找方法 在 C++ 中，区分重写和重定义的关键是看父类同名函数是否声明了 virtual，而由于在 OC 中没有 virtual 关键字，因此 OC 中没有重写和重定义的概念，只有在消息发送的时候利用 isa 指针去查找类/元类的方法列表 多重继承 C++ 支持多继承 OC 不支持多重继承，可以实现多个协议来完成多重继承的效果 虚基类 C++ 中的虚基类是为了消除多重继承时的歧义 C++虚继承和虚基类 OC 没有虚基类，因为不需要","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/C++头文件如何正确定义全局变量/","text":"背景我们项目里看到一个头文件，是专门定义各种常量的，有一天发现这里的常量定义既使用了 static，又使用了 const，这个文件没有类，全部都是字符串的定义 12345678// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hconst string VN_LIST = &quot;list&quot;;const string VN_CELL = &quot;cell&quot;;const string VN_VIEWPAPER = &quot;view-pager&quot;;static vector&lt;string&gt; VN_MULTICELLTYPE = &#123;VN_LIST, VN_VIEWPAPER&#125;;#endif /* QVNDefine_h */ 此时我们有一番讨论，松哥觉得应该在头文件里声明，在实现文件里定义会更好，即类似 12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hextern const string VN_LIST;#endif /* QVNDefine_h */ 123// QVNDefine.cpp#include &quot;QVNDefine.h&quot;extern const string VN_LIST = &quot;list&quot;; 虽然是自己写的代码，但其实自己对这里的知识不太熟悉，习惯性就写了 const，又不知道为什么写了 static，所以找了一下资料系统学习一下 声明与定义我们的问题是在 C++ 头文件中如何正确定义全局变量，首先要理解变量的声明和定义的区别是什么，翻了一下之前的笔记 1234extern int a; // 声明一个全局变量aint a; // 定义一个全局变量aextern int a = 0; // 定义一个全局变量a并给初值int a = 0; // 定义一个全局变量a并给初值 注意一下在 C++ 中 定义只能有1处，但声明可以有多处，这就是 ODR（定义与单一定义）规则 定义引起内存分配，声明则不会 注意变量的声明默认就是 extern 以上是针对变量的，如果是函数，还有点微妙的区别 函数的定义和声明一样是有区别的，定义函数要有函数体，声明函数没有函数体 所以与变量的区别就是没有函数体的函数是声明，而不是定义，如下例 12int a; // 这是一个变量的定义int fun(void); // 这是一个函数的声明，省略了extern，完整些是extern int fun(void); 头文件定义全局变量几种方式的比较根据以上信息，我们有以下几种定义全局变量的方式 第一种方法，直接定义12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hextern int a = 0;#endif /* QVNDefine_h */ 这是危险的，相当于 int a = 0，变量存放在同一个地址，是全局变量，多个实现文件包含该头文件是会发生重复定义问题，违背了 ODR 规则！ 第二种方法，使用 static12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hstatic int a = 0;#endif /* QVNDefine_h */ 这是可行的，在编译阶段，每个包含该头文件的 .cpp 会生成一个 static int a = 0，变量存放在不同的地址，不是全局变量 第三种方法，使用 const12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hconst int a = 0;#endif /* QVNDefine_h */ 这是可行的，在编译阶段，每个包含该头文件的 .cpp 会生成一个 const int a = 0，变量存放在不同的地址，不是全局变量，与 static 效果一样 第四种方法，使用 extern const 声明 + 实现文件定义12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hextern const int a;#endif /* QVNDefine_h */ 123// QVNDefine.cpp#include &quot;QVNDefine.h&quot;extern const int a = 1; 这是可行的，在编译阶段，其他包含该头文件的 .cpp 会生成一个 extern const int a，存放在同一个地址，是全局变量 除了方法一，其他方法都是可行的。那么它们有什么区别呢，谁才是最佳方式？ 先说结论，大多数情况下，方法三最好 先聊聊 static这里只阐述全局变量有无被 static 修饰的区别 一个全局变量（无论是定义在 .h 还是 .cpp），如果没有被 static 修饰，那么它是全局性的，假如该头文件被多次 include，在编译时就会产生重复链接的报错 而如果添加了 static，该全局变量就会变成静态全局变量，其作用域只在当前编译单元（比如 include 了该头文件的 .cpp）生效 所以实现文件的全局函数一般都要添加 static，这样不同的人编写不同的实现文件时，不用担心自己定义的函数，是否会与其它文件中的函数同名 根据这个特点，假如有一百个实现文件包含了该头文件，那么这个全局变量就会被定义一百次，这个会造成内存空间的浪费，应该避免使用这种方式 此时我们可以使用 extern 声明 + 实现文件定义的方法来解决多次定义的浪费问题 再聊聊 const const 的最初动机是取代预处理器 #define 来进行值替代，后来还被用于指针、函数变量、返回类型、类对象以及成员函数——《C++ 编程思想》 这里我们只阐述头文件中的 const 有什么特点 const 在 C++ 中默认为内部链接（这一点与 C 不同，注意），即只对包含该定义的文件里是可见的，而不会被其他编译单元看到，故不是一个全局变量（与 static 类似），这个特点保证了不会有重复定义的错误 既然 const 与 static 类似，那么是否一样会有多次定义的浪费问题呢？以及为什么比方法四（extern 声明 + 实现文件定义）好？答案都在书里 通常 C++ 编译器并不为 const 创建存储空间，相反它把这个定义保存在它的符号表里。大部分场合使用内部数据类型的情况，包括常量表达式，编译都能执行常量折叠——《C++ 编程思想》 不过以下情况，编译器会进行存储空间的分配： extern 成为 const 变量定义的一部分 取一个 const 的地址 const 修饰的是一个复杂的对象 如果 extern 成为 const 变量定义的一部分的时候，那么编译器会为强制进行了存储空间分配，extern 意味着使用外部连接，因此必须分配存储空间，这也就是说有几个不同的编译单元应当能够引用它，所以它必须存储空间 常量折叠何为常量折叠？常量折叠（Constant folding）和常量传播（constant propagation）都是一种编译器最佳化技术 常量折叠表面上的效果和宏替换是一样的，只是 “效果上是一样的”，而两者真正的区别在于，宏是字符常量，在预编译完宏替换完成后，该宏名字会消失，所有对宏的引用已经全部被替换为它所对应的值，编译器当然没有必要再维护这个符号 而常量折叠发生的情况是，对常量的引用全部替换为该常量的值，但是，常量名并不会消失，编译器会把他放入到符号表中 1i = 320 * 200 * 32; 比如上面的代码中，编译器通常会在编译时直接计算出320 * 200 * 32的值，而不会在此生成2个乘法指令 结论所以如果定义的都是内部数据类型，我们只要保证不对 const 变量进行取址操作（事实上也很少这样做），那么使用 const 的方式是最佳的，因为可以借助编译器的力量进行优化。最后回归背景问题，我们需要将 static 替换为 const 即可 参考文章 Defining global constant in C++ const、static、extern 在头文件中似的情况小结 《C++ 编程思想》第二版 8.1.1 头文件里的 const C++常量折叠（这一篇关于分配空间的说法有失偏颇）","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/C++头文件的全局变量/","text":"变量的定义与声明1234extern int a; // 声明一个全局变量aint a; // 定义一个全局变量aextern int a = 0; // 定义一个全局变量a并给初值int a = 0; // 定义一个全局变量a并给初值 定义只能有1处，但声明可以有多处 定义引起内存分配，声明则不会 注意变量和函数的声明默认就是 extern 函数的定义与声明函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体，所以函数定义和声明时都可以将 extern 省略掉 12int a; // 这是一个变量的定义int fun(void); // 这是一个函数的声明，省略了extern，完整些是extern int fun(void); 头文件中的全局变量1234567891011121314151617181920212223242526// test.h#ifndef _TEST_H_ #define _TEST_H_ // 这是可行的，在编译阶段，每个包含 test.h 的文件会生成一个 static int a = 0; // 存放在不同的地址，不是全局变量static int a = 0;// 这是可行的，在编译阶段，每个包含 test.h 的文件会生成一个 const int b = 0; // 存放在不同的地址，不是全局变量，与 static 一样const int b = 1;// 这是可行的，在编译阶段，每个包含 test.h 的文件会生成一个 extern int c; // 存放在同一个地址，是全局变量 // 使用的时候必须在其中一个&quot;.cpp&quot;文件定义 int c; 之后才可以正确运行// 因为 extern 的含义是变量定义在别的位置extern int c;// 这是危险的，相当于int d = 0// 存放在同一个地址，是全局变量 // 多个头文件包含是会发生重定义问题！！！extern int d = 0;// vector 同理// p.s. 对于 const 的迭代器访问，需要使用 const_iterator 而不是 iteratorconst std::vector&lt;std::string&gt; VN_MULTICELLTYPE = &#123;&quot;1&quot;, &quot;2&quot;&#125;;#endif 注意全局 const 默认为该编译单元的局部变量（内部链接性），即类似 static 修饰（C 和 C++ 不同，const 常量在 C 中依旧是外部链接性的 ） 在头文件中定义 static/const 变量会造成变量多次定义，造成内存空间的浪费，而且也不是真正的全局变量。应该避免使用这种定义方式 正确的方式是在头文件中使用声明，在某一个实现文件中定义，其他实现文件引用即可 1234567891011121314//tesh.h#ifndef _TEST_H_#define _TEST_H_extern int a; // 此处声明#endif// a.cpp#include &quot;test.h&quot;a = 2; // 此处定义cout &lt;&lt; a &lt;&lt; endl;// b.cpp#include &quot;test.h&quot;cout &lt;&lt; a &lt;&lt; endl; // 输出2 参考文章 NSNotification Name 最佳写法 const、static、extern 在头文件中似的情况小结 勿在头文件中定义static变量","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/C++拾遗/","text":"虚函数相关 定义一个函数为虚函数，不代表函数为不被实现的函数。 定义基类的函数为虚函数是为了允许用基类的指针来调用子类的这个函数（多态） 定义一个函数为纯虚函数，才代表函数没有被实现，规范继承这个类的子类必须实现这个函数 抽象类的定义：称带有纯虚函数的类为抽象类 抽象类无法实例化 继承抽象类的子类如果没有实现纯虚函数，则该子类也是抽象类 虚析构函数 v.s. 纯虚析构函数 实现多态时，父类的析构函数必须为虚析构函数，否则 delete 的时候父类的析构函数不会被调用 如果想实现一个抽象类，如果其中没有其他合适的函数，可以把析构函数定义为纯虚的 纯虚函数通常都不需要函数体，因为我们一般不会调用抽象类的这个函数，但是不代表不能有函数体 无论是虚析构函数还是纯虚析构函数，都必须有函数体。因为即使是抽象类，其析构函数也应该需要被调用到（会被子类的析构函数隐式调用到） 123456class Base&#123;public: Base()&#123;&#125; virtual ~Base()= 0;&#125;; 这段代码会编译错误，因此析构函数一定需要函数体，但是对于纯虚函数不能把实现和 =0 写在一起，因此需要改为这样 123456789101112class Base&#123;public: Base() &#123; &#125; virtual ~Base() = 0;&#125;;Base::~Base()&#123;&#125; virtual 的隐式继承virtual 修饰符是会隐式继承的：基类是 virtual 函数，子类不写 virtual 关键字，其函数依然是 virtual delete [] 和 delete 数组对象使用 delete 的话，虽然这块内存会正确地归还，但只会针对数组内的第一个对象执行析构函数，后续的对象的析构函数都无法被执行 基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的 但是对于类对象数组，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间 所以一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用 混编 OC 的 .h 和 .m 包含 C++ 类，它作为属性 C++ 的 .h 和 .cpp 包含 OC 类，它作为变量 C++类与 void的转换，OC 类与 void的转换 OC 类在 C++ 之间传递，用 void *、bridge【QVNImplementationUtils】 C++ 类在 OC 之间传递，用 void * C++ 类，有一个 OC 变量，OC 的生成和释放都是 ARC 管理的 写了 inline 就一定会内联吗？不写 inline 一定不会内联吗inline 仅仅是一个对编译器的建议，最后能否真正内联取决于编译器，它如果认为你的函数不复杂，能在调用点展开，并不是说声明了内联就会内联；同理，没有声明 inline 的也不一定不会内联，如下代码 比如以下代码极有可能会被内联 123static int Inc(int i) &#123;return i+1&#125;;int i;for (i=0; i&lt;999999; i = Inc(i)) &#123;&#125;; 变为 123static int Inc(int i) &#123;return i+1&#125;;int i;for (i=0; i&lt;999999; i = i+1) &#123;&#125;; inline 写在函数声明的地方是无效的如下风格的函数 Foo 不能成为内联函数： 12inline void Foo(int x, int y); // inline 仅与函数声明放在一起void Foo(int x, int y)&#123;&#125; 而如下风格的函数Foo 则成为内联函数： 12void Foo(int x, int y);inline void Foo(int x, int y) &#123;&#125;// inline 与函数定义体放在一起 所以说，inline 是一种 “用于实现的关键字”，而不是一种 “用于声明的关键字” 全局的 inline 函数要把实现写在头文件首先 inline 写在函数声明处是无效的；其次如果只在 .c 中声明 inline，.h 不声明，那么其他文件引用该 .h 的时候，根本不知道该函数是一个内联函数，所以只能把实现和 inline 关键字写在头文件 其次，定义在头文件中的 inline 需要配合 static 如果没有 static，那么编译器会认为该内联函数是全局的，会把该函数进行编译（即当成普通的全局函数而不是在调用处展开），那么就失去了内联的效果 https://medium.com/@hauyang/%E6%88%91%E6%9C%89%E6%89%80%E4%B8%8D%E7%9F%A5%E7%9A%84-static-inline-b363892b7450 C++ 的枚举写法有坑12345678910111213vector&lt;vector&lt;int&gt;&gt; ret;// 这种写法，修改 v 不会影响 ret，因为 v 是拷贝构造了for (auto v : ret) v.pop_back();// 这种写法，修改 v 会影响 ret，因为 v 是引用for (auto &amp;v : ret) v.pop_back();// 加引用的写法等同于这个写法for (int i = 0; i &lt; ret.size(); ++i) ret[i].pop_back(); C++变量的初始化 全局变量、静态变量：0 局部变量：随机 类的成员变量 全局：0 静态：0 局部：随机 123456789101112int g_var;int *g_pointer;static int g_static;int main()&#123; int l_var; int *l_pointer; static int l_static; cout&lt;&lt;g_var&lt;&lt;endl&lt;&lt;g_pointer&lt;&lt;endl&lt;&lt;g_static&lt;&lt;endl; // 0 0 0 cout&lt;&lt;l_var&lt;&lt;endl&lt;&lt;l_pointer&lt;&lt;endl&lt;&lt;l_static&lt;&lt;endl; // 非0 非0 0&#125;; 123456789101112class A&#123;public: int v;&#125;;A g_var;int main()&#123; A l_var; static A l_static; cout&lt;&lt;g_var.v&lt;&lt;&#x27; &#x27;&lt;&lt;l_var.v&lt;&lt;&#x27; &#x27;&lt;&lt;l_static.v&lt;&lt;endl; // 0 2407223 0 return 0;&#125; 一个类型转换的问题（待解决）123456789101112131415161718192021222324252627class A&#123;public: virtual void doA() = 0; virtual ~A()&#123;printf(&quot;~A\\n&quot;);&#125;;&#125;;class B&#123;public: virtual void doB() = 0; virtual void doC() = 0; virtual ~B()&#123;printf(&quot;~B\\n&quot;);&#125;;&#125;;class SubClass: public A, public B&#123;public: void doA() override; void doB() override; void doC() override; ~SubClass()&#123;printf(&quot;~SubClass\\n&quot;);&#125;;&#125;;void SubClass::doA()&#123;printf(&quot;doA\\n&quot;);&#125;;void SubClass::doB()&#123;printf(&quot;doB\\n&quot;);&#125;;void SubClass::doC()&#123;printf(&quot;doC\\n&quot;);&#125;; 测试代码如下 1234567891011121314151617181920212223A *a = new SubClass();a-&gt;doA(); // doAB *b = (B *)a;b-&gt;doB(); // doAb-&gt;doC(); // ~SubClass ~B ~AA *a = new SubClass();a-&gt;doA(); // doAB *b = (B *)a;b-&gt;doC(); // ~SubClass ~B ~Ab-&gt;doB(); // Crash:libc++abi.dylib: Pure virtual function called!A *a = new SubClass();a-&gt;doA(); // doASubClass *sub = dynamic_cast&lt;SubClass *&gt;(a);sub-&gt;doB(); // doBsub-&gt;doC(); // doCA *a = dynamic_cast&lt;A*&gt;(new SubClass());a-&gt;doA(); // doAB *b = dynamic_cast&lt;B*&gt;(a);b-&gt;doB(); // doBb-&gt;doC(); // doC A *a = new SubClass(); 这种写法和 A *a = dynamic_cast&lt;A*&gt;(new SubClass()); 本质上没有区别 但是 B *b = (B *)a; 和 SubClass *sub = dynamic_cast&lt;SubClass *&gt;(a); 是有区别的 注意以上代码都不应该打印析构函数的内容，因为没有调用 delete","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/C++默认参数/","text":"C++ 可以给参数设置默认值，当参数缺省的时候，使用默认值如果没有设置默认值，则调用的时候不能省略参数 12345678910111213void f(int i = 1, float f = 2.0f, double d = 3.0)&#123; cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; f &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; endl ;&#125;int main(void)&#123; f() ; // 1, 2, 3 f(10) ; // 10, 2, 3 f(10, 20.0f) ; // 10, 20, 3 f(10, 20.0f, 30.0) ; // 10, 20, 30 return 0 ;&#125; 参数默认值可以是一个函数123456789static int getValue()&#123; return 1;&#125;int f(int a, int b = getValue())&#123; return b;&#125; 如果某个参数是默认参数，那么它后面的参数必须都是默认参数所有有歧义的都是非法的 以下定义是非法的，因为有歧义。因为一旦只有两个参数，那么缺省的是第二个还是第三个呢？ 1void f(int i, float f = 2.0f, double d); 函数重载时谨慎使用默认参数值以下定义是非法的，因为有歧义。一旦只有一个参数，那么应该调用第一个函数还是第二个呢？ 123456789int f(int a)&#123; return a;&#125;int f(int a, int b = 1)&#123; return a + b;&#125;","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"dynamic_cast","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/dynamic_cast/","text":"C++ 中 如果是子类指针强制转换父类指针，则称为上行转换（upcasting） 如果是父类指针强制转换子类指针，则称为下行转换（downcasting） 例子123456789101112131415161718classB&#123;public: int m_iNum; virtual void foo();&#125;;classD : public B&#123;public: char *m_szName[100];&#125;;void func(B *pb)&#123; D *pd1 = static_cast&lt;D *&gt;(pb); D *pd2 = dynamic_cast&lt;D *&gt;(pb);&#125; 在上面的代码段中，如果 pb 指向一个 D 类型的对象，pd1 和 pd2 是一样的，并且对这两个指针执行 D 类型的任何操作都是安全的； 但是，如果 pb 指向的是一个 B 类型的对象，那么 pd1 将是一个指向该对象的指针，对它进行 D 类型的操作将是不安全的（如访问 m_szName），而 pd2 将是一个空指针，因而 dynamic_cast 更安全 结论如果进行上行转换，则使用 dynamic_cast 和 static_cast 的效果一样，都能得到正确的转换结果 如果进行下行转换，dynamic_cast 具有类型检查的功能，比 static_cast 更安全；如果类的关系是对的，则转换成功，返回一个指向子类的指针，否则返回 NULL 指针 注意dynamic_cast 转化时，如果父类不是一个多态类，也就是没有虚函数，那么编译失败，因此如果要实现 dynamic_cast 的转换，至少把父类的析构函数声明为虚函数（不必须是纯虚函数）；而 static_cast 会编译成功，不安全 为什么需要虚函数呢：从意义上说，类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。从技术上说，这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/unordered_map 与 map 的区别/","text":"map 是基于红黑树实现，O(lgn) 的时间复杂度完成查找、插入和删除，内部是有序的 unordered_map 是基于 hash_table 实现 map unordered_map 实现原理 红黑树 hash_table 有序性 有序 无序 时间复杂度 查找、插入和删除都是 O(lgn) 查找、插入和删除平均 O(1)，最坏 O(n) 内存占用 更少 更多 使用场景 需要数据有序；对内存敏感 大多数情况下选择 unordered_map，特别是需要查找的情况","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/C++/static变量与static函数/","text":"今天遇到一个 crash，追溯到最后竟然是因为在两个 .cpp 文件中声明了2个相同名称的全局变量，改用 staitc 修饰它们为静态全局变量就解决问题 1234567pair&lt;string, VN_CSS_TYPE_ALIAS_PAESER&gt; pairArray[] = &#123; make_pair(&quot;src&quot;, VN_RICH_CSS_VIDEO_SRC_ALIAS_PARSER)&#125;;ClassA::fun()&#123;&#125; 改为 1234567static pair&lt;string, VN_CSS_TYPE_ALIAS_PAESER&gt; pairArray[] = &#123; make_pair(&quot;src&quot;, VN_RICH_CSS_VIDEO_SRC_ALIAS_PARSER)&#125;;ClassA::fun()&#123;&#125; static 变量的特征： static 变量被放在程序的全局存储区中，这样在下一次调用的时候还可以保持原来的赋值 static 变量仅在其作用范围内可见。这一点是它与全局变量的区别。 Tips: 若全局变量仅在单个文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度； 若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； 函数前加 static 使得函数成为静态函数。是指对函数的作用域仅局限于本文件(所以又称内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名 全局变量、静态全局变量、静态局部变量和局部变量的区别变量可以分为 全局变量（外部变量） 静态全局变量 静态局部变量 局部变量 按存储区域分，全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。 按作用域分，全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，并且程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效 全局变量前再冠以 static 就构成了静态全局变量。 全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数用，因此可以避免在其它源文件中引起错误 从以上分析可以看出，把局部变量改变为静态局部变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态全局变量后是改变了它的作用域，限制了它的使用范围 全局变量、静态局部变量和静态全局变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"arch/面试/C","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/网络/HTTPS/","text":"假如客户端要登录，将用户名和密码传到服务器 如果使用 HTTP，会有什么问题HTTP 是明文传输，有以下问题 窃听风险：第三方可以获知通信内容（需要加密） 篡改风险：第三方可以修改通信内容（需要校验） 冒充风险：第三方可以冒充他人身份参与通信（需要信任——证书） 那我可以在客户端先加密，这样就不是明文传输了呀你这种属于对称加密，如果你的密钥是在通信过程中传输，那可能被截获，这样你的信息就泄漏了 那服务器和客户端事先约定好密钥，而不是在通信时才传输，这样就不会泄漏了可以的，但是实际上这样做会很麻烦 那你有什么更好的方法吗使用非对称加密，服务器维护公钥和密钥，通信时，客户端先向服务器端索要公钥，然后用公钥加密信息再传输，服务器收到密文后，用自己的私钥解密 这里的公钥和私钥是什么公开秘钥：简称公钥；私人秘钥：简称私钥 非对称加密的特点就是： 私钥加密后的密文，所有公钥都可以解密（比如数字证书的生成） 公钥加密后的密文，只有私钥可以解密（比如服务器和客户端的加密流程） 私钥只有一个人有，而公钥可以发给所有的人 那看起来很完美了呀 其实这样还有一个安全问题 非对称加密还存在什么安全问题如果第三方拦截住了客户端的公钥请求，然后模仿了服务器的行为，传输给你他自己的公钥 同时，第三方也模拟了客户端向服务器发送公钥请求，得到了服务器的公钥 接着客户端就会把攻击者当做服务器，用假公钥把信息加密传给第三方，第三方再使用自己的私钥解密得到信息 同时，第三方得到了信息之后，模拟客户端使用服务器的公钥进行加密，再传给服务器 这个就是所谓的“中间人攻击”，通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。 那有什么方法防止中间人攻击吗有，使用CA（数字证书认证机构）颁发的数字证书 证书就是服务器将信息（公钥、姓名、邮件等）提供给 CA，CA 把信息写到证书里，再用自己的私钥对这些信息进行加密形成证书的签名，再返回给服务器 简单理解：证书 = CA 私钥对服务器公钥的加密结果 现在服务器不再返回公钥给客户端，而是返回证书 客户端收到证书之后，只需要用 CA 的公钥解密证书的签名得到加密之前的散列值，再计算数字证书中信息（公钥、姓名、邮件等）的散列值，将两者进行对比，只要散列值一致，就证明这张证书没有被篡改过 这个中间人攻击看起来很像 Charles/WireShark 的抓包没错，抓包软件的原理就是中间人攻击，怪不得每次得信任证书是，只要客户端信任了 Charles 的证书，客户端就会把 Charles 当成服务器，Charles 变成了中间人，因此可以监听 HTTPS 的内容 那客户端怎么得到正确的 CA 的公钥呢简单点说，操作系统和浏览器在设备出厂的时候就会内置很多根证书 非对称加密计算量太大，如何减少耗用的时间？客户端得到正确的公钥之后，就可以使用对称加密来传播信息 客户端生成一个“会话密钥”，使用服务器的公钥对该密钥进行加密，将密钥密文传递给服务器。 服务器使用自己的密钥对密钥密文进行解密得到客户端密钥 接下来双方利用会话密钥，来实现对称加密的通信 每一次对话，客户端和服务器端都生成一个”会话密钥”（session key），用它来加密信息。由于”会话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”会话密钥”本身，这样就减少了加密运算的消耗时间 HTTPS 整个工作流程HTTPS 主要分为两个过程： 握手阶段：客户端向服务器端索要公钥；并协商 “会话密钥” 通信阶段：双方采用 “会话密钥” 进行加密通信 其中握手阶段的流程图如下： 我们看看整个流程： 客户端生成一个随机数 RNc（即 Random Number of Client）并发送给服务器【Client-Hello 阶段】 服务器收到后生成 RNs（即 Random Number Of Server），并把 RNs 和证书（含公钥）返回给客户端【Server-Hello 阶段】 客户端校验证书提取公钥并验证；生成 PMS（即 Pre Master Secret），使用公钥加密发送给服务器 服务器使用私钥进行解密得到 PMS 客户端和服务器都使用 RNc、RNs 和 PMS 生成会话密钥，接下来使用会话密钥对通信内容进行对称加密 为什么要使用三个随机数 不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于 RSA 密钥交换算法来说，pre-master-secret 本身就是一个随机数，再加上 hello 消息中的两个随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre-master-secret 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre-master-secret 就有可能被猜出来，那么仅适用 pre-master-secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 pre-master-secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了 关于安全信任 双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了 数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由上级 CA 证书的正确性保证的了 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了 关于完整性校验HTTPS 通过证书解决了冒充风险，通过加密解决了窃听风险，那么篡改风险如何规避呢？ 当握手阶段结束后，双方进入数据通信阶段。在这个阶段： 发送方会使用协商出来的“会话密钥”对原始消息进行加密，形成密文；同时也会使用哈希算法对原始消息进行计算，形成消息摘要；并将消息摘要和密文同时发送出去 接收方会使用“会话密钥”对密文进行解密，得到原始消息，然后对原始消息使用同样的哈希算法进行计算，将得到的值与消息摘要比较，以此判断是否被篡改过 哈希算法是不可逆的，可以把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射。无论多长的消息都被映射成长度固定的散列值，因此消息长短不会影响完整性校验的性能 More 对称加密：客户端用密钥将对信息进行加密，服务器用同一把密钥将对信息进行解密 发送方和接收方如何共享相同的密钥比较麻烦。一种方法是通过事先协商好而不是通过通信进行协商，避免被监听和截获；另一种是通过非对称加密通道进行对称加密的密钥的传输 对称加密的密钥是一对一的，若服务器要跟多个客户端通信则需要维护多对密钥 非对称加密：公钥和私钥；客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密 不存在密钥分发的问题，解码方可以自己生成密钥对，一个做私钥存起来，另外一个作为公钥进行发布 解决了密钥管理的复杂度问题，多个加密方都可以使用一个已知的公钥进行加密，但只有拥有私钥的一方才能解密 缺点是比对称加密慢 常见算法 常见的对称加密算法：DES、AES、RC2、RC4 常见的非对称加密算法：RSA、DSA 常见的完整性校验算法：MD5、SHA1、SHA256 参考来源 SSL/TLS协议运行机制的概述 一文完全理解HTTPS 完全图解 HTTPS","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"arch/面试/网络","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/算法/排序/基本排序/","text":"选择排序每次挑最小的放左边 123456789101112131415void selectionSort(int s[], int n)&#123; for (int i = 0; i &lt; n-1; ++i) &#123; int minIndex = i; for (int j = i+1; j &lt; n; ++j) &#123; if (s[j] &lt; s[minIndex]) &#123; minIndex = j; &#125; &#125; swap(s[i], s[minIndex]); &#125;&#125; 插入排序从左往右遍历，取出当前元素有序地插到其左半部分 1234567891011121314151617void insertionSort(int s[], int n)&#123; for (int i = 1; i &lt; n; ++i) &#123; for (int j = i; j &gt;= 1; --j) &#123; if (s[j] &lt; s[j-1]) &#123; swap(s[j], s[j-1]); &#125; else &#123; break; &#125; &#125; &#125;&#125; 冒泡排序从左往右进行两两比较，每一趟可以使最大值在最右边 12345678910111213void bubbleSort(int s[], int n)&#123; for (int i = n-1; i &gt; 0; --i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (s[j] &gt; s[j+1]) &#123; swap(s[j], s[j+1]); &#125; &#125; &#125;&#125; 改进冒泡排序：优化外层循环如果某一趟比较没有数值交换，则说明已经排好序；处理在排序过程中数组整体已经有序的情况 123456789101112131415161718192021void bubbleSort2(int s[], int n)&#123; for (int i = n-1; i &gt; 0; --i) &#123; bool isSorted = true; for (int j = 0; j &lt; i; ++j) &#123; if (s[j] &gt; s[j+1]) &#123; swap(s[j], s[j+1]); isSorted = false; &#125; &#125; if (isSorted) &#123; return; &#125; &#125;&#125; 改进冒泡排序：优化内层循环每一趟遍历记录最后一次交换的位置，这个位置后的元素其实都是有序的，不需要再次比较 123456789101112131415161718void bubbleSort3(int s[], int n)&#123; int endPos = n-1; for (int i = n-1; i &gt; 0; --i) &#123; int lastExchangeIndex = 0; for (int j = 0; j &lt; endPos; ++j) &#123; if (s[j] &gt; s[j+1]) &#123; swap(s[j], s[j+1]); lastExchangeIndex = j; &#125; &#125; endPos = lastExchangeIndex; &#125;&#125;","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"arch/面试/算法","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"arch/面试/算法/排序","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/算法/排序/堆排序/","text":"图解堆排序堆排序是什么 堆排序的步骤 将无序数组就地交换，堆化为最大堆 将堆顶元素与末尾元素交换，将最大元素沉到数组末端； 重复步骤 1 和 2，直到整个数组有序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// 构造小顶堆void adjustHeap(int s[], int n, int cur)&#123; int tmp = s[cur]; // 从 cur 的左子节点开始 for (int i = 2 * cur + 1; i &lt; n; i = i * 2 + 1) &#123; // 如果存在右子节点且右子节点更小 if (i + 1 &lt; n &amp;&amp; s[i + 1] &lt; s[i]) &#123; i++; &#125; // 找到左右节点中最小的元素与当前元素交换 if (tmp &gt; s[i]) &#123; s[cur] = s[i]; // 暂时不需要处理最初被交换的那个 cur = i; // 以同样的方法处理子节点 &#125; else &#123; // 如果当前元素比子节点都小，满足条件，退出 break; &#125; &#125; s[cur] = tmp;&#125;void heapSort(int s[], int n)&#123; // 步骤 1：建堆 // 从第一个非叶子结点从下至上，从右至左调整结构 for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(s, n, i); &#125; // 步骤 2：交换元素，重新调整堆 for (int i = n - 1; i &gt; 0; i--) &#123; swap(s[0], s[i]); adjustHeap(s, i, 0); &#125;&#125; 复杂度 建堆的复杂度是 O(N) 交换 N 次，调整的复杂度为 O(logN) 所以堆排序复杂度为：O(NlogN) 建堆时间复杂度为什么是 O(N) 应用找出无序数组中位数，要求O(N)复杂度找出无序数组中第 K 大元素考虑 K = 1 的时候如何处理，K = 2、3 呢？最终会考虑到最大堆的建立","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"arch/面试/算法","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"arch/面试/算法/排序","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/算法/搜索/回溯算法/","text":"回溯算法的框架解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题： 1、路径：也就是已经做出的选择。 2、选择列表：也就是你当前可以做的选择。 3、结束条件：也就是到达决策树底层，无法再做选择的条件。 如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。 代码方面，回溯算法的框架： 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。 全排列问题Leetcode：46.全排列 12345678910111213141516171819202122232425262728293031323334vector&lt;vector&lt;int&gt;&gt; ret;void backtrack(vector&lt;int&gt; &amp;path, vector&lt;int&gt; &amp;nums)&#123; // 满足结束条件 if (path.size() == nums.size()) &#123; ret.push_back(path); return; &#125; for (int num : nums) &#123; // 排除不合法的选择 // 这一步可以优化为 swap，但是理解起来比较复杂 if (find(path.begin(), path.end(), num) != path.end()) &#123; continue; &#125; // 做选择 path.push_back(num); // 递归 backtrack(path, nums); // 撤销选择 path.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; path; backtrack(path, nums); return ret;&#125; N 皇后问题N 皇后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859vector&lt;vector&lt;string&gt;&gt; res;/* 输入棋盘边长 n，返回所有合法的放置 */vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; // &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。 vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;)); backtrack(board, 0); return res;&#125;// 路径：board 中小于 row 的那些行都已经成功放置了皇后// 选择列表：第 row 行的所有列都是放置皇后的选择// 结束条件：row 超过 board 的最后一行void backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return; &#125; for (int col = 0; col &lt; board[row].size(); col++) &#123; // 排除不合法选择 if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = &#x27;Q&#x27;; // 进入下一行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = &#x27;.&#x27;; &#125;&#125;bool isValid(vector&lt;string&gt;&amp; board, int row, int col)&#123; int n = board.size(); // 检查【列】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后） for (int i = 0; i &lt;= row; i++) &#123; if (board[i][col] == &#x27;Q&#x27;) return false; &#125; // 检查【右上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后） for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (board[i][j] == &#x27;Q&#x27;) return false; &#125; // 检查【左上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后） for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (board[i][j] == &#x27;Q&#x27;) return false; &#125; return true;&#125; 字母大小全排列784. 字母大小写全排列 1234567891011121314151617181920212223242526272829303132333435363738394041vector&lt;string&gt; ret;void backtrack(string path, string S)&#123; if (path.size() == S.size()) &#123; ret.push_back(path); return; &#125; char c = S[path.size()]; path += c; backtrack(path, S); // 字母需要回溯，数字不需要 if (isalpha(c)) &#123; // 回退再选择一次 path = path.substr(0, path.size()-1); // 大写转小写；小写转大写 if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) &#123; path += tolower(c); &#125; else &#123; path += toupper(c); &#125; backtrack(path, S); &#125;&#125;vector&lt;string&gt; letterCasePermutation(string S) &#123; ret = &#123;&#125;; if (S.size() == 0) return ret; string path; backtrack(path, S); return ret;&#125; 参考 回溯算法详解","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"arch/面试/算法","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"arch/面试/算法/搜索","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/算法/排序/快速排序/","text":"123456789101112131415161718192021222324252627282930313233343536void quickSort(int s[], int l, int r)&#123; if (l &gt;= r) &#123; return; &#125; int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while (s[j] &gt;= x &amp;&amp; i &lt; j) &#123; j--; &#125; if (i &lt; j) &#123; s[i++] = s[j]; &#125; while (s[i] &lt; x &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; s[j--] = s[i]; &#125; &#125; s[i] = x; quickSort(s, l, i-1); quickSort(s, i+1, r);&#125;","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"arch/面试/算法","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"arch/面试/算法/排序","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/算法/数据结构/动态规划/","text":"最长回文子串https://leetcode-cn.com/problems/longest-palindromic-substring/ https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/ 12345678910111213141516171819202122232425262728293031323334353637383940string longestPalindrome(string s) &#123; int m = s.size(); if (m == 0) &#123; return &quot;&quot;; &#125; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(m, 0)); int start = 0; int length = 1; for (int i = 0; i &lt; m; i++) &#123; // 单个字符属于回文，例如 abcd dp[i][i] = 1; // 连续两个字符相同属于回文，例如 abb if (i &lt; m - 1) &#123; if (s[i] == s[i + 1]) &#123; dp[i][i + 1] = 1; start = i; length = 2; &#125; &#125; &#125; for (int len = 2; len &lt;= m; len++) &#123; for (int i = 0; i &lt; m - len; i++) &#123; int j = i + len; // 扩展长度 if (dp[i + 1][j - 1] == 1 &amp;&amp; s[i] == s[j]) &#123; dp[i][j] = 1; if (j - i + 1 &gt; length) &#123; start = i; length = j - i + 1; &#125; &#125; &#125; &#125; return s.substr(start, length);&#125;","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"arch/面试/算法","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"arch/面试/算法/数据结构","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/算法/数据结构/树/","text":"二叉树的最近公共祖先https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree 12345678910111213TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || root == p || root == q) return root; TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q); if (l &amp;&amp; r) return root; else if (l) return l; else return r;&#125; 判断是否是相同的树https://leetcode-cn.com/problems/same-tree/ 1234567bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; if (p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125; 判断是否是另一个树的子树https://leetcode-cn.com/problems/subtree-of-another-tree/ 12345678910111213bool isSubtree(TreeNode* s, TreeNode* t) &#123; if (!s || !t) return false; if (isSameTree(s, t)) return true; return isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);&#125;bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; if (p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125; 判断是否对称二叉树https://leetcode-cn.com/problems/symmetric-tree/ 123456789101112bool isSymmetric(TreeNode *root)&#123; return isMirror(root, root);&#125;bool isMirror(TreeNode *left, TreeNode *right)&#123; if (!left &amp;&amp; !right) return true; if (!left || !right) return false; if (left-&gt;val != right-&gt;val) return false; return isMirror(left-&gt;left, right-&gt;right) &amp;&amp; isMirror(left-&gt;right, right-&gt;left);&#125; 翻转二叉树https://leetcode-cn.com/problems/invert-binary-tree/ 12345678910TreeNode* invertTree(TreeNode* root) &#123; if (!root) return NULL; TreeNode *left = root-&gt;left; TreeNode *right = root-&gt;right; root-&gt;left = right; root-&gt;right = left; invertTree(left); invertTree(right); return root;&#125; BFShttps://leetcode-cn.com/problems/binary-tree-level-order-traversal/ BFS 时不携带层级信息 12345678910111213141516vector&lt;int&gt; bfs(TreeNode* root) &#123; vector&lt;int&gt; ret; if (!root) return ret; queue&lt;TreeNode *&gt; q; q.push(root); while (!q.empty()) &#123; TreeNode *cur = q.front(); q.pop(); ret.push_back(cur-&gt;val); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; return ret;&#125; BFS 时携带层级信息 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (!root) return ret; queue&lt;TreeNode *&gt; q; q.push(root); while (!q.empty()) &#123; vector&lt;int&gt; curLevel; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode *cur = q.front(); q.pop(); curLevel.push_back(cur-&gt;val); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; ret.push_back(curLevel); &#125; return ret;&#125;","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"arch/面试/算法","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"arch/面试/算法/数据结构","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","date":"2025-04-20T05:50:42.948Z","path":"arch/面试/算法/数据结构/链表/","text":"删除单向链表中的指定节点https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 只能访问当前节点，当前节点不是末尾节点 借尸还魂：将当前节点的值和 next 全部更新为其 next，再删除 next 123456void deleteNode(ListNode *node) &#123; ListNode *next = node-&gt;next; node-&gt;val = next-&gt;val; node-&gt;next = next-&gt;next; delete next;&#125; 移除未排序链表中的重复节点遍历的同时使用 map 记录； 或者 使用双指针，current 用于迭代，runner 用于检查后续节点有无重复 寻找链表中倒数第 K 个元素https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ 快慢指针 删除链表中某个节点，只能访问该节点，不能访问 headhttps://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 删除后续节点，并将后续节点的值复制到该节点 链表的加法，数字反向存放https://leetcode-cn.com/problems/add-two-numbers/ 迭代，记录进位 链表的加法，数字正向存放https://leetcode-cn.com/problems/add-two-numbers-ii/ 对短的链表补 0 封装 pair 结构记录 ListNode 和进位 递归求解 判断链表是否有环https://leetcode-cn.com/problems/linked-list-cycle/ 双指针必相遇 判断有环链表的环路起始点https://leetcode-cn.com/problems/linked-list-cycle-ii/ 假如链表起点距离环路起点为 k 创建双指针：fast 和 slow；slow 每走一步，fast 走两步 两者相碰时的节点必然距离环路起点 k slow 重置到 head，再以相同的速度移动 slow 和 fast 相碰时必是环路起点 两个链表的相交节点https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 双指针：先得到两个链表的长度，然后得到长度的差值 distance，两个指针分别从两个链表头部遍历，其中较长链表指针先走 distance 步，然后同时向后走，当两个指针相遇的时候，即链表的交点 链表的中间节点https://leetcode-cn.com/problems/middle-of-the-linked-list/ 123456789101112// 1-&gt;2-&gt;3-&gt;4 则返回 3；1-&gt;2-&gt;3 则返回 2ListNode* middleNode(ListNode* head) &#123; ListNode *fast = head, *slow = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125; 反转链表https://leetcode-cn.com/problems/reverse-linked-list/ 反转链表的递归解法非常直观； 1234567891011121314ListNode *reverseList(ListNode *head)&#123; if (!head || !head-&gt;next) &#123; return head; &#125; ListNode *next = head-&gt;next; // reverseList 作用：传入 1-&gt;2-&gt;3，结果为 1&lt;-2&lt;-3，并返回 3 ListNode *after = reverseList(next); next-&gt;next = head; head-&gt;next = NULL; return after;&#125; 迭代解法 12345678910111213ListNode *reverseList(ListNode *head)&#123; ListNode *last = nullptr; ListNode *cur = head; while (cur) &#123; ListNode *next = curNode-&gt;next; cur-&gt;next = last; last = cur; cur = next; &#125; return last;&#125; 判断是否回文链表https://leetcode-cn.com/problems/palindrome-linked-list/ 寻找后半部分的起点 反转后半部分链表 双指针比较前半部分和后半部分的是否相同","tags":[],"categories":[{"name":"arch","slug":"arch","permalink":"https://norcy.github.io/wiki/categories/arch/"},{"name":"面试","slug":"arch/面试","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"arch/面试/算法","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"arch/面试/算法/数据结构","permalink":"https://norcy.github.io/wiki/categories/arch/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","date":"2019-08-15T00:00:00.000Z","path":"tech/FrontEnd/JS 模块化/","text":"模块化模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面 模块化的优点如下： 可维护性。 因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进 命名空间。 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境 重用代码。 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库 CommonJS 和 AMD 是 JS 中关于模块化的 2 个规范，其中 CommonJS 一般用于服务器，AMD 一般用于浏览器 CommonJS在 CommonJS 中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量、函数和类，都是私有的，对其他文件是不可见的 CommonJS 有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global 注意 exports 要与 ES6 的 import &amp; export 区别开 实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用 exports），用 require 加载模块 123456789// 定义模块 math.jsvar basicNum = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; // 在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum&#125; 1234567// 引用自定义的模块时，参数包含路径，可省略. jsvar math = require(&#x27;./math&#x27;);math.add(2, 5);// 引用核心模块时，不需要带路径var http = require(&#x27;http&#x27;);http.createService(...).listen(3000); CommonJS 的 require 方法是同步的。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，数据需要从服务器获取，受限于网络速度，更合理的方案是使用异步加载 注意 module.exports 和 exports 的区别 123456789101112131415161718192021222324var basicNum = 0;function add(a, b) &#123; return a + b;&#125;// 方案 1：使用 module.exports 一个个导出（正确）module.exports.add = addmodule.exports.basicNum = basicNum// 方案 2：使用 exports 一个个导出（正确）exports.add = addexports.basicNum = basicNum// 方案 3：使用 module.exports 整体导出（正确）module.exports = &#123; add: add, basicNum: basicNum&#125;// 方案 4：使用 exports 整体导出（错误）exports = &#123; add: add, basicNum: basicNum&#125; 方案 4 是错误的，可以理解为在模块开始前 exports = module.exports，因为赋值之后 exports 失去了 对 module.exports 的引用，成为了一个模块内的局部变量 AMDAsynchronous Module Definition 规范，意为 “异步模块定义” AMD 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。主要包含 define 和 require 两个方法 模块化使得不会污染全局环境，能够清楚地显示依赖关系，允许异步加载模块，也可以根据需要动态加载模块 define：定义模块define 方法用于模块的定义 12345define( module_id /* 可选 */, [dependencies] /* 可选 */, factory: Function|Object /* 用来初始化模块或对象的函数 */); 第一个参数 id 参数被省略的时候，我们说这个模块是匿名的 第二个参数 dependencies 参数代表了一组对所定义的模块来说必须的依赖项；如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”] 第三个参数 factory，既可以是函数，也可以是对象。如果是对象，此对象应该为模块的输出值。如果是一个函数，它应该只被执行一次；包裹着模块的具体实现，等到依赖加载完成之后，它才会运行。注意 Function 的参数是各个依赖项的输出，顺序与依赖项一一对应，返回值就是该新定义模块的输出 当第三个参数是 Object 的时候，如下例，生成了一个拥有 method1、method2 两个方法的模块 1234define(&#123; method1: function() &#123;&#125;, method2: function() &#123;&#125;&#125;); 当第三个参数是 Function 的时候，等价的写法如下，这种写法的自由度更高一点，可以在函数体内写一些模块初始化代码 123456define(function () &#123; return &#123; method1: function() &#123;&#125;, method2: function() &#123;&#125; &#125;;&#125;); 一个更具体的例子 1234567891011121314151617181920212223define(&#x27;myModule&#x27;, [&#x27;foo&#x27;, &#x27;bar&#x27;], // 模块定义函数 // 依赖项（foo 和 bar）被映射为函数的参数 function (foo, bar) &#123; // 返回一个定义了模块导出接口的值 // （也就是我们想要导出后进行调用的功能） // 在这里创建模块 var myModule = &#123; doStuff:function()&#123; console.log(&#x27;Yay! Stuff&#x27;); &#125; &#125; return myModule; &#125;); // 另一个例子可以是...define(&#x27;myModule&#x27;, [&#x27;jquery&#x27;, &#x27;./math.js&#x27;, &#x27;foo&#x27;], function($, math, foo) &#123; // $ 是 jquery 模块的输出 $(&#x27;body&#x27;).text(&#x27;hello world&#x27;);&#125;); 一个使用了简单 CommonJS 转换的模块定义：没有 return 值，输出使用 exports 123456define(function (require, exports, module) &#123; var a = require(&#x27;a&#x27;), b = require(&#x27;b&#x27;); exports.action = function () &#123;&#125;;&#125;); require：加载模块AMD 也采用 require() 语句加载模块，但是不同于 CommonJS，它是异步的，所以多了一个 callback 方法： require([module], callback); 第一个参数是一个数组，里面的成员就是要加载的模块 第二个参数 callback，等加载的模块全部加载成功之后的回调函数 1234567// 假设&#x27;foo&#x27; 和&#x27;bar&#x27; 是两个外部模块// 在本例中，这两个模块被加载后的&#x27;exports&#x27; 被当做两个参数传递到了回调函数中// 所以可以像这样来访问他们require([&#x27;foo&#x27;, &#x27;bar&#x27;], function (foo, bar) &#123; // 这里写其余的代码 foo.doSomething();&#125;); require 方法也可以放在 define 内部，比如当 define 的依赖项很多时，参数与模块一一对应的写法非常麻烦 123456define( [&#x27;dep1&#x27;, &#x27;dep2&#x27;, &#x27;dep3&#x27;, &#x27;dep4&#x27;, &#x27;dep5&#x27;, &#x27;dep6&#x27;, &#x27;dep7&#x27;, &#x27;dep8&#x27;], function(dep1, dep2, dep3, dep4, dep5, dep6, dep7, dep8)&#123; ... &#125;); 为了避免像上面代码那样繁琐的写法，RequireJS 提供一种更简单的写法 12345678910111213define( function (require) &#123; var dep1 = require(&#x27;dep1&#x27;), dep2 = require(&#x27;dep2&#x27;), dep3 = require(&#x27;dep3&#x27;), dep4 = require(&#x27;dep4&#x27;), dep5 = require(&#x27;dep5&#x27;), dep6 = require(&#x27;dep6&#x27;), dep7 = require(&#x27;dep7&#x27;), dep8 = require(&#x27;dep8&#x27;); ... &#125;); 动态加载模块12345678910111213define(function ( require ) &#123; var isReady = false, foobar; require([&#x27;foo&#x27;, &#x27;bar&#x27;], function (foo, bar) &#123; isReady = true; foobar = foo() + bar(); &#125;); return &#123; isReady: isReady, foobar: foobar &#125;;&#125;); 上面代码所定义的模块，内部加载了 foo 和 bar 两个模块，在没有加载完成前，isReady 属性值为 false，加载完成后就变成了 true。因此，可以根据 isReady 属性的值，决定下一步的动作 ES6 模块export 和 importES6 的模块功能主要由两个命令构成：export 和 import 定义模块 math.js，并输出两个对象 12345var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;; 12345/** 引用模块 **/import &#123; basicNum, add &#125; from &#x27;./math&#x27;;function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; export defaultES6 还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号 123456789/** export default **/// 定义输出export default &#123; basicNum, add &#125;;// 引入import math from &#x27;./math&#x27;;function test(ele) &#123; ele.textContent = math.add(99 + math.basicNum);&#125; ES6 与 CommonJS 的模块差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 一旦输出一个值，模块内部的变化就影响不到这个值 ES6 中，JS 引擎编译时遇到模块加载命令 import，就会生成一个只读引用，模块内部的变化会影响已输出的值 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为 “运行时加载” 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为 “编译时加载” ES6 常见的导出导入语法`js// 例子 1：使用 defalutexport default defaultName; // 注意导出的 default 只能有一个import defaultName from ‘./modules.js’; // 例子：2 import default 时可以随意指定命名export default defaultName;import myName from ‘./modules.js’; // 例子：3 不使用 defaultexport {export1, export2}import {export1, export2} from ‘./module.js’ // 例子：4 import 使用别名export {export1, export2}import {export1 as ex1, export2 as ex2} from ‘./module.js’ // 例子：5 export 使用别名export {export1 as ex1, export2 as ex2}import {ex1, ex2} from ‘./module.js’ // 例子：6 混合使用export default defaultNameexport {export1, exprot2}import defaultName, {export1, export2} from ‘./module.js’ 参考文章 《前端模块化：CommonJS,AMD,CMD,ES6》 《Javascript 模块化编程（二）：AMD 规范》 《AMD 规范》 《使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript》 《RequireJS 和 AMD 规范》 《AMD (中文版)》) javascript中import和export用法总结","tags":[],"categories":[{"name":"tech","slug":"tech","permalink":"https://norcy.github.io/wiki/categories/tech/"},{"name":"FrontEnd","slug":"tech/FrontEnd","permalink":"https://norcy.github.io/wiki/categories/tech/FrontEnd/"}]}]}