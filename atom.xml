<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小笔记</title>
  
  
  <link href="https://norcy.github.io/wiki/atom.xml" rel="self"/>
  
  <link href="https://norcy.github.io/wiki/"/>
  <updated>2025-04-20T05:50:08.000Z</updated>
  <id>https://norcy.github.io/wiki/</id>
  
  <author>
    <name>Norcy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小笔记</title>
    <link href="https://norcy.github.io/wiki/tech/index/"/>
    <id>https://norcy.github.io/wiki/tech/index/</id>
    <published>2025-04-20T05:50:42.956Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/iOS%20%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/iOS%20%E7%8A%B6%E6%80%81%E6%A0%8F/</id>
    <published>2025-04-20T05:50:42.956Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Info.plist 中设置 <code>View controller-based status bar appearance</code> 控制 App 状态栏显隐接受全局配置（NO）或者各控制器各自配置（YES）</p><ul><li><p><code>View controller-based status bar appearance = NO</code> 时，使用 <code>[[UIApplication sharedApplication] setStatusBarHidden:hidden]</code> 来控制全局状态栏的显隐</p></li><li><p><code>View controller-based status bar appearance = YES</code> 时，重写 ViewController 的 prefersStatusBarHidden 方法来决定当前 Controller 的状态栏显隐</p></li></ul></li></ol><ol start="2"><li><p>设置 Status bar is initially hidden -&gt; YES 可以隐藏启动页展示过程的状态栏；默认不隐藏</p></li><li><p>ViewController 的相关方法</p></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样式</span></span><br><span class="line">- (<span class="built_in">UIStatusBarStyle</span>)preferredStatusBarStyle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.visibleViewController preferredStatusBarStyle];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显隐</span></span><br><span class="line">- (<span class="type">BOOL</span>)prefersStatusBarHidden </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.visibleViewController prefersStatusBarHidden];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记状态栏需要更新，同 setNeedsLayout</span></span><br><span class="line">[<span class="keyword">self</span> setNeedsStatusBarAppearanceUpdate];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Info.plist 中设置 &lt;code&gt;View controller-based status bar appearance&lt;/code&gt; 控制 App 状态栏显隐接受全局配置（NO）或者各控制器各自配置（YES）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;c</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/iOS%20%E8%A7%A6%E6%91%B8%E6%9C%BA%E5%88%B6/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/iOS%20%E8%A7%A6%E6%91%B8%E6%9C%BA%E5%88%B6/</id>
    <published>2025-04-20T05:50:42.956Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>iOS 把用户触摸事件打包成一个 <strong>UIEvent</strong> 对象，作为事件传递的消息载体，放入当前活跃的 APP 的消息队列中，然后通过 <strong>Hit-Test 机制</strong> 来找到响应者，响应者通过<strong>响应链（Responder Chain）</strong>的传递做出响应，这就是 iOS 事件分发机制的实现原理</p><h2 id="UIEvent-有哪些"><a href="#UIEvent-有哪些" class="headerlink" title="UIEvent 有哪些"></a>UIEvent 有哪些</h2><p>UIEvent 包含最常见的三种事件：Touch Events(触摸事件)、Motion Events(运动事件，比如重力感应和摇一摇等)、Remote Events(远程事件，比如用耳机控制手机)。这里我们只讨论触摸事件</p><h2 id="Hit-Test-机制"><a href="#Hit-Test-机制" class="headerlink" title="Hit-Test 机制"></a>Hit-Test 机制</h2><p>如图，我点击了 E，Hit-Test 机制是如何找到这个 View 呢？</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/12/160e94dac2ffc35c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="Hit-Test"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 判断能否接受事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled || <span class="keyword">self</span>.hidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断是否在当前 View 内</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event] == <span class="literal">NO</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 逆序遍历子视图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> [<span class="keyword">self</span>.subviews reverseObjectEnumerator])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 坐标转换，将当前坐标系的点转化为子视图的坐标系的点</span></span><br><span class="line">        <span class="built_in">CGPoint</span> childP = [<span class="keyword">self</span> convertPoint:point toView:subview];</span><br><span class="line">        <span class="built_in">UIView</span> *hitView = [subview hitTest:childP withEvent:event];</span><br><span class="line">        <span class="keyword">if</span> (hitView)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> hitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 不在子视图，则返回自己</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 UIView 的 <code>pointInside:withEvent:</code> 方法的作用是，判断当前的点是否在当前 View 的 bounds 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(<span class="keyword">self</span>.bounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以下情况，Hit-Test 函数返回 nil</p><ol><li>view.isHidden = YES</li><li>view.alpha &lt;= 0.01</li><li>view.userInterfaceEnable=NO</li><li>control.enable = NO（如果是 UIControl）</li></ol><p>其次注意，子视图的遍历是逆序的，为了保证相同层级下的子视图，离用户越近的优先得到响应</p><h2 id="Responder-Chain（响应链）"><a href="#Responder-Chain（响应链）" class="headerlink" title="Responder Chain（响应链）"></a>Responder Chain（响应链）</h2><p>在 UIKit 中，UIApplication、UIView、UIViewController 这几个类都是直接继承自 UIResponder 类；而响应链是由 UIResponder 组合而成的数组，起始于 FirstResponder，结束于 UIApplication</p><p>用户触摸屏幕后，系统通过 Hit-Test 机制找到响应的 UIView，即 FirstResponder；如果该 UIResponder 不处理该事件，则会交给它 的下一个 UIResponder，如果该 UIResponder 处理则停止，否则继续递归直到响应链结束</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/12/160e94dac3b40720~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><ol><li>UIView 的 nextResponder 属性，如果有管理此 view 的 UIViewController 对象，则为此 UIViewController 对象；否则 nextResponder 即为其 superview</li><li>UIViewController 的 nextResponder 属性为其管理 view 的 superview</li><li>UIWindow 的 nextResponder 属性为 UIApplication 对象</li><li>UIApplication 的 nextResponder 属性为 nil。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="寻找-UIView-所在的-Controller"><a href="#寻找-UIView-所在的-Controller" class="headerlink" title="寻找 UIView 所在的 Controller"></a>寻找 UIView 所在的 Controller</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">Controller</span>)</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)viewController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIResponder</span> *responder = [<span class="keyword">self</span> nextResponder];</span><br><span class="line">    <span class="keyword">while</span> (responder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ([responder isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;</span><br><span class="line">        &#125;</span><br><span class="line">        responder = [responder nextResponder];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="扩大按钮点击区域"><a href="#扩大按钮点击区域" class="headerlink" title="扩大按钮点击区域"></a>扩大按钮点击区域</h3><p>重写以下方法即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> relativeFrame = <span class="keyword">self</span>.bounds;</span><br><span class="line">    <span class="comment">// 上下左右扩大 15 像素</span></span><br><span class="line">    <span class="built_in">UIEdgeInsets</span> hitTestEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">-15</span>, <span class="number">-15</span>, <span class="number">-15</span>, <span class="number">-15</span>);</span><br><span class="line">    <span class="built_in">CGRect</span> hitFrame = <span class="built_in">UIEdgeInsetsInsetRect</span>(relativeFrame, hitTestEdgeInsets);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(hitFrame, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子-view-超出了父-view-的-bounds-响应事件"><a href="#子-view-超出了父-view-的-bounds-响应事件" class="headerlink" title="子 view 超出了父 view 的 bounds 响应事件"></a>子 view 超出了父 view 的 bounds 响应事件</h3><p>正常情况下，子 View 超出父 View 的 bounds 的那一部分是不会响应事件的</p><p><img src="https://upload-images.jianshu.io/upload_images/144142-3b8eacb1afb47c93.png" alt></p><p>解决方法1：重写父 View 的 pointInside 方法</p><p>这种方法会导致如果点击在父 View （而不是其子 View）上时，不会再响应任何事件，父 View 就像变透明了一样</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这是默认实现</span></span><br><span class="line">    <span class="comment">// return CGRectContainsPoint(self.bounds, point);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> <span class="keyword">self</span>.subviews)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(view.frame, point))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法2：重写父 View 的 hitTest 方法（推荐）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    UIView *view = [super hitTest:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (view == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果默认返回 nil，说明此次点击确实不在父 View 范围内</span></span><br><span class="line">        <span class="comment">// 此时我们再多加一层判断是否在子 View 内，如果满足则返回子 View</span></span><br><span class="line">        <span class="keyword">for</span> (UIView *subview in [self.subviews reverseObjectEnumerator])</span><br><span class="line">        &#123;</span><br><span class="line">            CGPoint childP = [self convertPoint:point toView:subview];</span><br><span class="line">            UIView *hitView = [subview hitTest:childP withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitView)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> hitView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个透明的-View，点击子-View-有效，点击自身无效"><a href="#实现一个透明的-View，点击子-View-有效，点击自身无效" class="headerlink" title="实现一个透明的 View，点击子 View 有效，点击自身无效"></a>实现一个透明的 View，点击子 View 有效，点击自身无效</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器中用到的 QNBPlayerIntellectView</span></span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    UIView *hitTestView = [super hitTest:point withEvent:event];</span><br><span class="line">    <span class="comment">// 如果点击的对象是自己，则当没事发生</span></span><br><span class="line">    <span class="keyword">if</span> (hitTestView == self)</span><br><span class="line">    &#123;</span><br><span class="line">        hitTestView = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitTestView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;iOS 把用户触摸事件打包成一个 &lt;strong&gt;UIEvent&lt;/strong&gt; 对象，作为事件传递的消息载体，放入当前活跃的 APP 的</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%90%AF%E5%8A%A8/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%90%AF%E5%8A%A8/</id>
    <published>2025-04-20T05:50:42.956Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>App 的启动流程分为两个阶段：pre-main 和 main</p><p><a href="https://naotu.baidu.com/file/ec6650477377c4dd5c6a15d776a8eef6">脑图</a></p><h2 id="pre-main-阶段"><a href="#pre-main-阶段" class="headerlink" title="pre-main 阶段"></a>pre-main 阶段</h2><ol><li>读取 App 的可执行文件（Mach-O 文件），从里面获得 dyld 的路径</li><li>加载 dyld</li><li><p>dyld 加载动态库</p><ol><li><p>加载动态库</p><p> dyld 从主执行文件的 header 中获取到需要加载的所依赖动态库列表，然后它需要找到每个 dylib，而应用所依赖的 dylib 文件可能会再依赖其他 dylib，最终递归加载所有动态库</p></li><li><p>rebase 和 binding</p><ul><li>rebase 修正镜像内部的指针</li><li>binding 修正镜像外部的指针</li></ul></li><li><p>objc setup</p><ul><li>注册 objc 类（class registration）</li><li>将分类的方法插到类的方法列表里（category registration）</li><li>确保 selector 的唯一性（selector uniquing）</li></ul></li><li><p>initializer</p><ul><li>调用 objc 类和分类的 load 方法</li><li>C++ 的构造函数属性函数</li><li>非基本类型的 C++ 静态全局变量的创建（即类 or 结构体）</li></ul></li></ol></li></ol><p>以上整个过程由 dyld 主导，结束后，dyld 调用真正的 main 函数</p><blockquote><p>小问题：那什么是 Mach-O 呢</p></blockquote><p>Mach-O 是 OSX 和 iOS 系统中可执行文件的格式，主要包括以下几种类型：</p><ul><li>Executable：应用的主要二进制</li><li>Dylib：动态链接库</li><li>Bundle：不能被链接，只能在运行时使用 dlopen 加载</li><li>Image：镜像文件，包含 Executable、Dylib 和 Bundle</li><li>Framework：包含 Dylib、资源文件和头文件的文件夹</li></ul><blockquote><p>小问题：dyld 是什么？</p></blockquote><p>dyld（dynamic loader），是苹果的动态链接器，用于加载动态链接库</p><blockquote><p>小问题：为什么需要 rebase 和 binding</p></blockquote><p>iOS 采用 ASLR 技术来保证 App 的安全。</p><p>ASLR（Address Space Layout Randomization）：地址空间布局随机化，是操作系统中使用的一种安全技术。可执行文件的地址空间有一个起始地址，而 ASLR 使得这个起始地址在 App 每次启动后是随机的。如果是固定的，那么黑客很容易就可以由起始地址+偏移量找到函数的地址</p><p>一个 Mach-O 文件内部有很多符号，有指向当前 Mach-O 的，也有指向其他 dylib 的，由于 ASLR 的存在，这些符号的地址都是不对的。</p><p>比如在运行时，代码如何准确的找到 printf 函数的地址或者 NSObject 类的地址呢？</p><p>rebase 的作用把 Mach-O 文件读入内存，然后在当前 Mach-O 的起始地址添加一个偏移量，以此修正当前可执行文件内部符号的地址，解决可执行文件内部的符号引用。注意 rebase 的意思就是变基，顾名思义，修改的是起始地址</p><p>binding 的作用是使用字符串匹配的方式去查找符号表，以修正可执行文件外部符号的地址，解决可执行文件外部的符号引用。这个过程相对于 rebase 会略慢。比如当前的 Mach-O 文件没有 NSObject 这个符号，它是属于 Foundation 框架的，那么 binding 的作用就是将 NSObject 这个符号与其真正的地址进行绑定</p><p><img src="https://img-blog.csdn.net/20171023100523145?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSGVsbG9fSHdj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><blockquote><p>小问题：什么是确保 selector 的唯一性</p></blockquote><p>分类有可能有和本类同名的方法，对于普通方法，会优先调用分类的方法；如果不同的分类实现了相同的方法，则编译顺序靠后的会被调用</p><p>确保 selector 唯一性就是找到同名方法的真正调用地址</p><blockquote><p>小问题：什么是热启动和冷启动</p></blockquote><ul><li>冷启动是指 app 进程不存在的情况下启动 App，需要创建和初始化进程</li><li>热启动是指 app 进程就驻在内存中，进程状态可能是激活的，可能是睡着的，系统将该进程激活，并放到前台。也就是没有了创建和初始化的过程，只有状态的切换</li></ul><h2 id="main-阶段"><a href="#main-阶段" class="headerlink" title="main 阶段"></a>main 阶段</h2><p>dyld 调用 main -&gt; 调用 UIApplicationMain -&gt; 最终调用 didFinishLaunchingWithOptions</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>见<a href="https://naotu.baidu.com/file/ec6650477377c4dd5c6a15d776a8eef6">脑图</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/entry/5b63fb115188257bca291fbc">iOS启动优化</a></li><li><a href="https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html">美团外卖iOS App冷启动治理</a></li><li><a href="https://blog.csdn.net/Hello_Hwc/article/details/78317863">关于 rebase 和 binding 的参考</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;App 的启动流程分为两个阶段：pre-main 和 main&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://naotu.baidu.com/file/ec6650477377c4dd5c6a15d776a8eef6&quot;&gt;脑图&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;pre-mai</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%BC%B1%E5%BC%95%E7%94%A8%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%BC%B1%E5%BC%95%E7%94%A8%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1/</id>
    <published>2025-04-20T05:50:42.956Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSPointerArray"><a href="#NSPointerArray" class="headerlink" title="NSPointerArray"></a>NSPointerArray</h2><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><p>NSPointerArray 是 NSArray 的通用版本，和 NSArray/NSMutableArray 不同的是，NSPointerArray 具有下面这些特性</p><ul><li>与 NSArray/NSMutableArray 相对应，NSArray/NSMutableArray 强引用集合对象</li><li>NSPointerArray 可以弱引用集合对象，一旦对象没人持有了，NSPointerArray 中对应的项会被变成 <code>NULL</code></li><li>NSPointerArray 是可变的，没有不可变的版本</li><li>NSPointerArray 可以存储 <code>NULL</code>，<code>NULL</code> 参与 count 计算</li><li>NSPointerArray 的 count 可以被设置，如果直接设置 count，多余的位置会使用 <code>NULL</code> 占位</li><li>NSPointerArray 存储的是指针类型 <code>void *</code> 而不是对象，所以需要 <code>__bridge</code> 进行转换</li><li>使用 addPointer 和 pointerAtIndex 来存取指针</li></ul><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithOptions:(<span class="built_in">NSPointerFunctionsOptions</span>)options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPointerFunctions:(<span class="built_in">NSPointerFunctions</span> *)functions;</span><br></pre></td></tr></table></figure><p>首先来看一下 NSPointerFunctionsOptions，它是个 option，主要分为三大类：</p><p>内存管理</p><blockquote><ul><li>NSPointerFunctionsStrongMemory：默认值，强引用集合对象</li><li>NSPointerFunctionsZeroingWeakMemory：废弃</li><li>NSPointerFunctionsMallocMemory 与 NSPointerFunctionsMachVirtualMemory： 用于 Mach 的虚拟内存管理</li><li>NSPointerFunctionsWeakMemory：弱引用集合对象</li></ul></blockquote><p>特性，用于标明对象判等方式</p><blockquote><ul><li>NSPointerFunctionsObjectPersonality：hash、isEqual、对象描述</li><li>NSPointerFunctionsOpaquePersonality：pointer 的 hash 、直接判等</li><li>NSPointerFunctionsObjectPointerPersonality：pointer 的 hash、直接判等、对象描述</li><li>NSPointerFunctionsCStringPersonality：string 的 hash、strcmp 函数、UTF-8 编码方式的描述</li><li>NSPointerFunctionsStructPersonality：内存 hash、memcmp 函数</li><li>NSPointerFunctionsIntegerPersonality：值的 hash</li></ul></blockquote><p>内存标识</p><blockquote><ul><li>NSPointerFunctionsCopyIn：根据第二类的选择，来具体处理。如果是 NSPointerFunctionsObjectPersonality，则根据 NSCopying 来拷贝</li></ul></blockquote><p>这里只关注弱引用，对象判别方式和 NSPointerFunctions 的初始化不展开</p><h3 id="提供-compact-方法剔除-NULL-元素"><a href="#提供-compact-方法剔除-NULL-元素" class="headerlink" title="提供 compact 方法剔除 NULL 元素"></a>提供 compact 方法剔除 <code>NULL</code> 元素</h3><p>NSPointerArray 可以存储 <code>NULL</code>，作为补充，它也提供了 compact 方法，用于剔除数组中为 NULL 的成员。但是 compact 函数有个已经报备的 bug，每次 compact 之前需要添加一个 <code>NULL</code>，否则会 compact 失败</p><h3 id="弱引用测试代码"><a href="#弱引用测试代码" class="headerlink" title="弱引用测试代码"></a>弱引用测试代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPointerArray</span> *pointerArray = [[<span class="built_in">NSPointerArray</span> alloc] initWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>];</span><br><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    [pointerArray addPointer:(__bridge <span class="type">void</span> *)obj];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;NSPointerArray is: %p count: %@&quot;</span>, [pointerArray pointerAtIndex:<span class="number">0</span>], @(pointerArray.count));</span><br><span class="line">    <span class="comment">// 输出 NSPointerArray is: 0x60000000e800 count: 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;After Release NSPointerArray is: %p count: %@&quot;</span>, [pointerArray pointerAtIndex:<span class="number">0</span>], @(pointerArray.count));</span><br><span class="line"><span class="comment">// 输出 After Release NSPointerArray is: 0x0 count: 1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 每次 compact 之前需要添加 NULL，规避系统 Bug</span></span><br><span class="line">[pointerArray addPointer:<span class="literal">NULL</span>];</span><br><span class="line">    </span><br><span class="line">[pointerArray compact];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;After Compact NSPointerArray count: %@&quot;</span>, @(pointerArray.count));</span><br><span class="line"><span class="comment">// 输出 After Compact NSPointerArray count: 0</span></span><br></pre></td></tr></table></figure><h3 id="与-NSArray-NSMutableArray-的区别"><a href="#与-NSArray-NSMutableArray-的区别" class="headerlink" title="与 NSArray/NSMutableArray 的区别"></a>与 NSArray/NSMutableArray 的区别</h3><p> NSArray/NSMutableArray 配合 NSValue 可以实现数组的弱引用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = @[].mutableCopy;</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">[array addObject:[<span class="built_in">NSValue</span> valueWithNonretainedObject:obj]];</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="built_in">NSValue</span> *value = array[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSObject</span> *obj2 = [value nonretainedObjectValue];</span><br></pre></td></tr></table></figure><p>注意：使用 NSValue 的方式，确实可以实现对对象的弱引用（即被添加到集合中时，对象的引用计数不会+1），但是当对象被释放的时候，数组中对应的对象会变成野指针，因此需要手动删除 NSArray 中对应对象的值，否则会在执行 <code>[value nonretainedObjectValue]</code> 时崩溃；而使用 NSPointerArray 不会有这个问题，对象的释放会使得集合中的对象变为 <code>NULL</code></p><h2 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h2><h3 id="特性介绍-1"><a href="#特性介绍-1" class="headerlink" title="特性介绍"></a>特性介绍</h3><p>NSHashTable 是 NSSet 的通用版本，和 NSSet / NSMutableSet 不同的是，NSHashTable 具有下面这些特性</p><ul><li>与 NSSet/NSMutableSet 相对应，NSSet/NSMutableSet 强引用集合对象</li><li>NSHashTable 可以弱引用集合对象，一旦对象没人持有了，NSHashTable 中的值也会被移除</li><li>NSHashTable 是可变的，没有不可变的版本</li><li>除了存储对象，NSHashTable 也可以存储任意指针，比如 <code>void *</code></li></ul><h3 id="初始化参数-1"><a href="#初始化参数-1" class="headerlink" title="初始化参数"></a>初始化参数</h3><p>可以在初始化 NSHashTable 时指定 NSHashTableOptions 来确定其内存引用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSHashTable</span>&lt;ObjectType&gt; *)hashTableWithOptions:(<span class="built_in">NSPointerFunctionsOptions</span>)options;</span><br></pre></td></tr></table></figure><p>NSHashTableOptions 的取值如下：</p><blockquote><ul><li>NSHashTableStrongMemory: 默认值，强引用集合对象，与 NSSet 一样</li><li>NSHashTableWeakMemory: 弱引用集合对象</li><li>NSHashTableZeroingWeakMemory: 废弃，请使用 NSHashTableWeakMemory</li><li>NSHashTableCopyIn: 在将对象添加到集合之前，会拷贝对象</li><li>NSHashTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等</li></ul></blockquote><h3 id="弱引用测试代码-1"><a href="#弱引用测试代码-1" class="headerlink" title="弱引用测试代码"></a>弱引用测试代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSHashTable</span> *hashTable = [<span class="built_in">NSHashTable</span> hashTableWithOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span>];</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    [hashTable addObject:obj];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;hashTable is: %@&quot;</span>, hashTable);</span><br><span class="line">    <span class="comment">// hashTable is: NSHashTable &#123;[3] &lt;NSObject: 0x6000035e3f60&gt;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;hashTable is: %@&quot;</span>, hashTable);</span><br><span class="line"><span class="comment">// hashTable is: NSHashTable &#123;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h2><h3 id="特性介绍-2"><a href="#特性介绍-2" class="headerlink" title="特性介绍"></a>特性介绍</h3><p>NSMapTable 是 NSDictionary 的通用版本，和 NSDictionary/NSMutableDictionary 不同的是，NSMapTable 具有下面这些特性</p><ul><li>与 NSDictionary/NSMutableDictionary 相对应，NSDictionary/NSMutableDictionary 对 Key 拷贝，对 Value 强引用</li><li>key 和 value 的内存管理方式可以分开，如：key 是强引用，value 是弱引用</li><li>NSMapTable 可以弱引用 Key 和 Value，一旦 Key 或 Value 中的某一个没人持有了，NSMapTable 中对应的项也会被移除</li><li>NSMapTable 是可变的，没有不可变的版本</li><li>除了存储对象，NSMapTable 也可以存储任意指针，比如 <code>void *</code></li></ul><p>总结起来一共有 4 种可能：</p><ul><li>key 为 strong，value 为 strong </li><li>key 为 strong，value 为 weak</li><li>key 为 weak，value 为 strong</li><li>key 为 weak，value 为 weak</li></ul><p>当用 weak 修饰 key 或 value 时，有一方被释放，则该键值对移除。</p><h3 id="初始化参数-2"><a href="#初始化参数-2" class="headerlink" title="初始化参数"></a>初始化参数</h3><p>可以在初始化 NSMapTable 时指定 NSPointerFunctionsOptions 来分别确定对 Key 和 Value 的内存引用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMapTable</span>&lt;KeyType, ObjectType&gt; *)mapTableWithKeyOptions:(<span class="built_in">NSPointerFunctionsOptions</span>)keyOptions valueOptions:(<span class="built_in">NSPointerFunctionsOptions</span>)valueOptions;</span><br></pre></td></tr></table></figure><blockquote><ul><li>NSMapTableStrongMemory: 默认值，强引用 Key/Value</li><li>NSMapTableWeakMemory: 弱引用 Key/Value</li><li>NSHashTableZeroingWeakMemory: 废弃，请使用 NSMapTableWeakMemory</li><li>NSMapTableCopyIn: 在将对象添加到集合之前，会拷贝对象</li><li>NSMapTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等</li></ul></blockquote><h3 id="弱引用测试代码-2"><a href="#弱引用测试代码-2" class="headerlink" title="弱引用测试代码"></a>弱引用测试代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMapTable</span> *mapTable = [<span class="built_in">NSMapTable</span> weakToStrongObjectsMapTable];</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *key = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSObject</span> *value = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    [mapTable setObject:value forKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mapTable is: %@&quot;</span>, mapTable);</span><br><span class="line">    <span class="comment">// mapTable is: NSMapTable &#123;&lt;NSObject: 0x6000008df890&gt; -&gt; &lt;NSObject: 0x6000008df870&gt;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;mapTable is: %@&quot;</span>, mapTable);</span><br><span class="line"><span class="comment">// mapTable is: NSMapTable &#123;&#125;</span></span><br><span class="line"><span class="comment">// key 是 weak 引用，所以析构之后 NSMapTable 就会移除对应的项</span></span><br></pre></td></tr></table></figure><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>NSHashTable 和 NSMapTable 都比 NSSet 和 NSDictionary 都更加强大，但是大部分情况下，我们用 NSSet 和 NSDictionary 就已经足够，只有在对内存有特别要求的情况下，才使用 NSHashTable 和 NSMapTable</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://nshipster.cn/nshashtable-and-nsmaptable/">NSHash​Table &amp; NSMap​Table</a></li><li><a href="http://www.saitjr.com/ios/nspointerarray-nsmaptable-nshashtable.html">Cocoa 集合类型：NSPointerArray，NSMapTable，NSHashTable</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NSPointerArray&quot;&gt;&lt;a href=&quot;#NSPointerArray&quot; class=&quot;headerlink&quot; title=&quot;NSPointerArray&quot;&gt;&lt;/a&gt;NSPointerArray&lt;/h2&gt;&lt;h3 id=&quot;特性介绍&quot;&gt;&lt;a href=&quot;#特</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%9D%82/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%9D%82/</id>
    <published>2025-04-20T05:50:42.956Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSNotification-接收通知时所在的线程取决于发送的线程还是注册的线程"><a href="#NSNotification-接收通知时所在的线程取决于发送的线程还是注册的线程" class="headerlink" title="NSNotification 接收通知时所在的线程取决于发送的线程还是注册的线程"></a>NSNotification 接收通知时所在的线程取决于发送的线程还是注册的线程</h2><p>发送的线程。</p><p>如果是注册的线程，则 NSNotificationCenter 需要维护监听者和其注册时所在线程的表，实现较为复杂；其次注册时所在的线程有可能被销毁，等到接收通知时不一定存在</p><h2 id="如果是子线程发送通知，如何在主线程接受通知"><a href="#如果是子线程发送通知，如何在主线程接受通知" class="headerlink" title="如果是子线程发送通知，如何在主线程接受通知"></a>如果是子线程发送通知，如何在主线程接受通知</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@&quot;MyNoti&quot;</span> object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;我在主线程接收到通知&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@&quot;MyNoti&quot;</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="多线程比较"><a href="#多线程比较" class="headerlink" title="多线程比较"></a>多线程比较</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2016/11/29/7b7e7bf06f7f325f981656d49ecf6099~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><h2 id="Xcode-编译"><a href="#Xcode-编译" class="headerlink" title="Xcode 编译"></a>Xcode 编译</h2><p>基本的编译过程分为四个步骤：</p><ul><li>预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。</li><li>编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s 文件。</li><li>汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。</li><li>链接（Link）：对.o 文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）</li></ul><h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a><a href="https://juejin.im/post/5d7765736fb9a06b2a2068a8">内存分布</a></h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/11/16d20e5f6ca8e299~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><ul><li><p>栈区  0x7 开头</p><p>  通常存放局部变量、函数参数等。栈在运行时可动态地扩展和收缩</p><p>  栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是一个编译时就确定的常数，如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</p></li><li><p>堆区 0x6 开头</p><p>  那些由 new/alloc 创建的对象所分配的内存块，内存由开发者申请和销毁；堆在运行时可动态地扩展和收缩</p><p>  堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p></li><li><p>静态区(未初始化数据) bss 段</p><p>  存放未初始化的全局变量和静态变量，程序结束后由系统释放；如 int a;</p></li><li><p>常量区(已初始化数据) data 段</p><p>  专门用于存放常量，程序结束后由系统释放；如 int a = 0;</p></li><li><p>代码区</p><p>  用于存放程序运行时的代码，代码会被编译成二进制存进内存的程序代码区</p></li></ul><blockquote><p>全局区又可分为未初始化全局区：.bss 段和初始化全局区：data 段</p></blockquote><blockquote><p>栈区从上往下走，堆区会从下往上走，当两个相遇的时候，则会发生堆栈溢出</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="type">char</span> *p;  <span class="comment">// 全局未初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b; <span class="comment">// 栈</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span> <span class="comment">// 栈</span></span><br><span class="line">    <span class="type">char</span> *p1; <span class="comment">// 栈 </span></span><br><span class="line">    <span class="type">char</span> *p2 = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 123456 在常量区，p2 在栈上。</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c =<span class="number">0</span>； <span class="comment">// 全局（静态）初始化区 </span></span><br><span class="line">    <span class="type">int</span> array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];    <span class="comment">// 堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h2><ol><li><p>方案一：<a href="https://github.com/Tencent/matrix/wiki/Matrix-for-iOS-macOS-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86">基于Runloop</a><br>Matrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。</p></li><li><p><a href="https://philm.gitbook.io/philm-ios-wiki/mei-zhou-yue-du/ui-xian-cheng-qia-dun-jian-kong">子线程 Ping</a></p></li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul><li>自旋锁</li><li>dispatch_semaphore</li><li>递归锁</li><li>NSLock</li><li>NSConditionLock</li><li>pthread_mutex 互斥锁</li><li>@synchronized</li><li>dispatch_barrier_async</li><li>atomic</li></ul><p><a href="https://bestswifter.com/ios-lock/">https://bestswifter.com/ios-lock/</a></p><h2 id="内存检测"><a href="#内存检测" class="headerlink" title="内存检测"></a>内存检测</h2><ol><li>hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法</li><li>调用以下代码，有误判，需要建立白名单</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [weakSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NSNotification-接收通知时所在的线程取决于发送的线程还是注册的线程&quot;&gt;&lt;a href=&quot;#NSNotification-接收通知时所在的线程取决于发送的线程还是注册的线程&quot; class=&quot;headerlink&quot; title=&quot;NSNotificati</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</id>
    <published>2025-04-20T05:50:42.956Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>layer.cornerRadius 不会触发离屏渲染，该属性只是对边框和背景颜色起作用，适用于内部没有其他控件的 view。</li><li>CAShapeLayer+UIBezierPath 会触发离屏渲染。</li><li>最好的方式就是使用 Core Graphics 的方式绘制圆角图片。</li><li>当然，还是那句话，根据场景来使用，如果界面中圆角的地方不多，第一种方式是最简单快捷，效率最高的。如果用到的圆角很多，那还是使用 Core Graphics 的方式</li></ol><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>cornerRadius+clipsToBounds</li><li>shadow</li><li>group opacity</li><li>mask</li><li><p>UIBlurEffect</p></li><li><p>AsyncDisplayKit(Texture) 作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看我之前的一些介绍</p></li><li>对于图片的圆角，使用 CoreGraphics 为图片裁剪圆角</li><li>对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的 layer 盖住四个角，从视觉上制造圆角的效果</li><li>对于 view 的圆形边框，如果没有 backgroundColor，可以放心使用 cornerRadius 来做</li><li>对于所有的阴影，使用 shadowPath 来规避离屏渲染</li><li>对于特殊形状的 view，使用 layer mask 并打开 shouldRasterize 来对渲染结果进行缓存<br>对于模糊效果，不采用系统提供的 </li><li>UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果</li></ol><p><a href="https://zhuanlan.zhihu.com/p/72653360">https://zhuanlan.zhihu.com/p/72653360</a><br><a href="http://lemon2well.top/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/">http://lemon2well.top/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/</a><br><a href="https://bestswifter.com/efficient-rounded-corner/">https://bestswifter.com/efficient-rounded-corner/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;layer.cornerRadius 不会触发离屏渲染，该属性只是对边框和背景颜色起作用，适用于内部没有其他控件的 view。&lt;/li&gt;
&lt;li&gt;CAShapeLayer+UIBezierPath 会触发离屏渲染。&lt;/li&gt;
&lt;li&gt;最好的方式就是使用 Core</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/Runtime/weak%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/Runtime/weak%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文解决的问题"><a href="#本文解决的问题" class="headerlink" title="本文解决的问题"></a>本文解决的问题</h2><ul><li>weak 的代码实现原理</li><li>当对象释放的时候，如何实现将 weak 指针置为 nil</li><li>weak 指针的线程安全</li></ul><h2 id="阅读本文的前提"><a href="#阅读本文的前提" class="headerlink" title="阅读本文的前提"></a>阅读本文的前提</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> __<span class="keyword">weak</span> weakObj = obj;</span><br></pre></td></tr></table></figure><ul><li>obj 在本文中称之为【被引用对象】，即 referent</li><li>weakObj 在本文中称之为【弱引用对象】，即 referrer</li></ul><h2 id="weak-的代码实现原理"><a href="#weak-的代码实现原理" class="headerlink" title="weak 的代码实现原理"></a>weak 的代码实现原理</h2><p>以上例子中的代码的 Clang 实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id weakObj;</span><br><span class="line"><span class="built_in">objc_initWeak</span>(&amp;weakObj, obj);</span><br></pre></td></tr></table></figure><p><code>objc_initWeak</code> 源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *addr, id val)</span> </span>&#123;</span><br><span class="line">    *addr = <span class="number">0</span>; <span class="comment">// 初始化 weakObj = nil</span></span><br><span class="line">    <span class="keyword">if</span> (!val) <span class="keyword">return</span> nil;   <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">objc_storeWeak</span>(addr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化版 <code>objc_storeWeak</code> 源码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> objc_storeWeak(<span class="type">id</span> *location, <span class="type">id</span> newObj) &#123;</span><br><span class="line">    <span class="comment">// 获取 oldObj(这个例子中应为 nil)</span></span><br><span class="line">    <span class="type">id</span> oldObj = *location;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 oldObj 对应的 SideTable</span></span><br><span class="line">    SideTable *oldTable = SideTable::tableForPointer(oldObj);</span><br><span class="line">    <span class="comment">// 获取 newObj 对应的 SideTable</span></span><br><span class="line">    SideTable *newTable = SideTable::tableForPointer(newObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 SideTable 的 weak_table 中移除 oldObj 和它的 weak pointer</span></span><br><span class="line">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    <span class="comment">// 从 SideTable 的 weak_table 中添加 newObj 和它的 weak pointer</span></span><br><span class="line">    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj, location);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给 weak 指针赋值</span></span><br><span class="line">    *location = newObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个例子中返回值外部没用到</span></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关类的简化版源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局有若干个 SideTable，并不是和 referent 一一对应，多个 referent 可能共享一个 SideTable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line">    RefcountMap refcnts;    <span class="comment">// 这个是负责引用计数的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SideTable *<span class="title">tableForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> a = (<span class="type">uintptr_t</span>)p;</span><br><span class="line">        <span class="type">int</span> index = ((a &gt;&gt; <span class="number">4</span>) ^ (a &gt;&gt; <span class="number">9</span>)) &amp; (SIDE_TABLE_STRIPE - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (SideTable *)&amp;table_buf[index * SIDE_TABLE_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SideTable *oldTable = SideTable::tableForPointer(oldObj);</code> </p><p>可能看完这句代码，我们会错以为 SideTable 和 obj 是一一对应的，其实并不是</p><p>SideTable 有一个成员 <code>table_buf</code>，它是 static 的，全局唯一</p><p>由 tableForPointer 的源码我们可以知道，只是根据对象的地址来获取 <code>table_buf</code> 中的其中一张 SideTable</p><p>由此可见，SideTable 并不是和 obj 对象一一对应，而是全局有多份，多个对象可能共享同一个 SideTable</p><p>另外，可以看到 SideTable 还负责相关对象的引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的弱引用表，与 SideTable 一一对应，Key 是 referent，值是该对象相关的所有弱引用信息（即 weak_entry_t）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_table_t</span> &#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries; <span class="comment">// 所有 referent 对应的 weak_entry_t，这是一个数组</span></span><br><span class="line">    <span class="type">size_t</span>    num_entries;      <span class="comment">// 一共有多少个 referent，即 weak_entries 数组的长度</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责维护和存储指向一个对象的所有弱引用 hash 表</span></span><br><span class="line"><span class="comment">// 与 referent 一一对应</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_entry_t</span> &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent; <span class="comment">// 即被引用的对象 obj</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">weak_referrer_t</span> *referrers;     <span class="comment">// 所有弱引用该对象的指针的哈希表</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The address of a __weak object reference</span></span><br><span class="line"><span class="comment">// typedef struct objc_object *id;</span></span><br><span class="line"><span class="comment">// 可以看到 weak_referrer_t 其实就是一个 id 的指针</span></span><br><span class="line"><span class="keyword">typedef</span> objc_object ** <span class="type">weak_referrer_t</span>;</span><br></pre></td></tr></table></figure><p>为了更好的理解 <code>weak_table_t</code> 与 obj 之间的对应关系，我们看下 <code>weak_register_no_lock</code> 的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adds an (object, weak pointer) pair to the weak table.</span></span><br><span class="line"><span class="function">id <span class="title">weak_register_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent, id *referrer)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">// weak_entry_for_referent 的实现应该是，遍历 weak_entries 数组，寻找并返回与 referent 对应的 weak_entry_t</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 如果该 referent 已经存在 weak_entry_t（即在此之前已经有弱引用信息），则添加 referrer 到 weak_entry_t</span></span><br><span class="line">        <span class="built_in">append_referrer</span>(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果该 referent 没有 weak_entry_t（即在此之前没有弱引用信息），则新增 weak_entry_t 到 weak_table</span></span><br><span class="line">        <span class="type">weak_entry_t</span> <span class="built_in">new_entry</span>(referent, referrer);</span><br><span class="line">        <span class="built_in">weak_entry_insert</span>(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes an (object, weak pointer) pair from the weak table.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">weak_unregister_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent, id *referrer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">// weak_entry_for_referent 的实现应该是，遍历 weak_entries 数组，寻找并返回与 referent 对应的 weak_entry_t</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 如果该 referent 已经存在 weak_entry_t（即在此之前已经有弱引用信息），则从 weak_entry_t 中删除 referrer</span></span><br><span class="line">        <span class="comment">// remove_referrer 这个方法会把这个 referrer 置为 nil（这个就是 weak 指针自动变 nil 的原因哦）</span></span><br><span class="line">        <span class="built_in">remove_referrer</span>(entry, referrer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 视情况从 weak_table 中删除 referent 对应的 weak_entry_t</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果调用正确，理论上 weak_entries 数组应该会有 referent 的 weak_entry_t 信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/99e3e31egy1gb5ec55d05j20id0jlq48.jpg" alt="关系图.png"><br><!-- ![](http://solacode.github.io/img/Screen%20Shot%202015-10-21%20at%2021.42.02.png) --></p><h2 id="当对象释放的时候，如何实现将-weak-指针置为-nil"><a href="#当对象释放的时候，如何实现将-weak-指针置为-nil" class="headerlink" title="当对象释放的时候，如何实现将 weak 指针置为 nil"></a>当对象释放的时候，如何实现将 weak 指针置为 nil</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject.m</span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _objc_rootDealloc(<span class="type">id</span> obj) &#123;</span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> objc_object::rootDealloc() &#123;</span><br><span class="line">    ...</span><br><span class="line">    object_dispose((<span class="type">id</span>)<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> object_dispose(<span class="type">id</span> obj)  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *objc_destructInstance(<span class="type">id</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="type">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没找到 clearDeallocating 源码，但是大致实现如下</span></span><br><span class="line"><span class="type">void</span> objc_object::clearDeallocating() &#123;</span><br><span class="line">    SideTable *table = SideTable::tableForPointer(<span class="variable language_">this</span>);</span><br><span class="line">    weak_clear_no_lock(&amp;table-&gt;weak_table, (<span class="type">id</span>)<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> weak_clear_no_lock(weak_table_t *weak_table, <span class="type">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// 从 weak_table 中寻找该 referent 对应的 weak_entry_t</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    referrers = entry-&gt;referrers;</span><br><span class="line">    count = TABLE_SIZE(entry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除所有 referrer 的值</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="comment">// referrer 指向的值，不出意外应该与 referent 相等</span></span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                <span class="comment">// 置空，这个就是为什么 weak 会自动置 nil 的原因</span></span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 weak_table 中删除对应的 weak_entry_t</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以看到对象释放时会调用 dealloc，</li><li>一步步调用到了 clearDeallocating，然后调用 tableForPointer 寻找对应的 SideTable，拿到 <code>weak_table_t</code></li><li>最终调用 <code>weak_clear_no_lock</code>，将所有的 referrer 指向的值（即 weak 指针），置为 nil，并从 <code>weak_table_t</code> 表中删除该对象的 <code>weak_entry_t</code></li></ol><p>通俗解释：</p><p>系统会把 weakObj 会放入一个 hash 表中。 用 obj 的内存地址作为 key，当 obj 的引用计数为 0 的时候会执行其 dealloc，此时会在这个 weak 表中搜索，找到所有以 &amp;obj 为 key 的对象，设置为 nil</p><h2 id="weak-指针的线程安全"><a href="#weak-指针的线程安全" class="headerlink" title="weak 指针的线程安全"></a>weak 指针的线程安全</h2><p>问题：当一个对象正在 delloc 时，如果在另一个线程获取了 weak 指针，这时获取到的 weak 指针有没有可能是野指针？</p><p>以下的代码例子模拟了这样一个过程，多个线程正在访问 weakObj，其中一个线程对 self.obj 释放了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @property (nonatomic, strong) NSObject *obj;</span></span><br><span class="line"><span class="keyword">self</span>.obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line"><span class="type">int</span> n = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj = <span class="keyword">self</span>.obj;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">480</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.obj = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@----%@&quot;</span>, weakObj, @(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：不会挂，不可能是野指针。weak 的访问是线程安全的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person *obj = [[Person alloc] init];</span><br><span class="line"><span class="type">id</span> __<span class="keyword">weak</span> weakObj = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, weakObj);</span><br></pre></td></tr></table></figure><p>通过 <code>clang -rewrite-objc MyBlock.c</code> 重写后得到的伪代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> weakObj;</span><br><span class="line">objc_initWeak(&amp;weakObj, obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 NSLog(@&quot;%@&quot;, weakObj) 转为以下代码</span></span><br><span class="line"><span class="type">id</span> tmp = objc_loadWeakRetained(&amp;obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, tmp);</span><br><span class="line">objc_release(tmp);</span><br></pre></td></tr></table></figure><p>当我们访问 weakObj 的时候，编译器会转为 <code>objc_loadWeakRetained</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> objc_loadWeakRetained(<span class="type">id</span> *location)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> obj;</span><br><span class="line">    <span class="type">id</span> result;</span><br><span class="line">    Class cls;</span><br><span class="line">    SideTable *table;</span><br><span class="line">    </span><br><span class="line"> retry:</span><br><span class="line">    obj = *location;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">    table = &amp;SideTables()[obj];</span><br><span class="line">    </span><br><span class="line">    table-&gt;lock();</span><br><span class="line">    <span class="keyword">if</span> (*location != obj) &#123;</span><br><span class="line">        table-&gt;unlock();</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result = obj;</span><br><span class="line"></span><br><span class="line">    cls = obj-&gt;ISA();</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;hasCustomRR()) &#123;</span><br><span class="line">        <span class="comment">// 一般情况下会走到这里</span></span><br><span class="line">        <span class="keyword">if</span> (! obj-&gt;rootTryRetain()) &#123;</span><br><span class="line">            result = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此处省略不重要的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    table-&gt;unlock();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取 weak 指针时，会调用 <code>objc_loadWeakRetained</code></li><li>不讨论 isTaggedPointer 这种特殊情况</li><li>hasCustomRR 在重写 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 等方法时会返回true，一般情况会返回 false。这里只讨论返回 false 的情况</li><li>rootTryRetain 会尝试对该对象进行 retain，里面会判断该对象是否正在 deallocating，如果是则返回 nil</li><li>通俗概括以上代码：获取 weak 时调用 <code>objc_loadWeakRetained</code>，获取过程会加锁。如果该对象已经释放或正在释放则返回 nil，否则对该对象进行 retain 并返回。因此我们得出结论：对 weak 指针的访问是线程安全的</li><li>那么问题来了，既然有 retian，那什么时候 release 呢？答案是 ARC 下会在 weak 指针访问完成后，自动插 release 代码，如下</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意 NSLog(@&quot;%@&quot;, weakObj) 转为以下代码</span></span><br><span class="line"><span class="type">id</span> tmp = objc_loadWeakRetained(&amp;obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, tmp);</span><br><span class="line">objc_release(tmp);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://solacode.github.io/2015/10/21/Runtime%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0weak%E5%B1%9E%E6%80%A7%EF%BC%9F/">Runtime如何实现weak属性？</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-647/runtime/objc-weak.h">objc-weak.h 源码</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-647/runtime/NSObject.mm">SiteTable 源码</a></li><li><a href="https://www.codenong.com/j5defc55351882512327/">详解获取weak对象的过程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本文解决的问题&quot;&gt;&lt;a href=&quot;#本文解决的问题&quot; class=&quot;headerlink&quot; title=&quot;本文解决的问题&quot;&gt;&lt;/a&gt;本文解决的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;weak 的代码实现原理&lt;/li&gt;
&lt;li&gt;当对象释放的时候，如何实现将 weak 指针</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="Runtime" scheme="https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><ul><li>关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？</li><li>为什么 AssociationsHashMap 是使用 <code>unordered_map</code>，而 ObjectAssociationMap 使用 <code>map</code></li><li>使用关联对象有什么需要注意的地方</li><li>为什么内存管理策略中没有 weak 选项，即 <code>OBJC_ASSOCIATION_WEAK</code></li></ul><h2 id="阅读本文的前提"><a href="#阅读本文的前提" class="headerlink" title="阅读本文的前提"></a>阅读本文的前提</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure><p>其中 self 我们称之为<strong>被关联对象</strong>，proxy 我们称之为 <strong>关联对象</strong></p><h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><p><strong>理解好以下几个结构之后，几乎不需要看源码就能推测 set/get 的原理</strong></p><h3 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h3><p>单例，全局唯一</p><h3 id="AssociationsHashMap"><a href="#AssociationsHashMap" class="headerlink" title="AssociationsHashMap"></a>AssociationsHashMap</h3><p>AssociationsManager 的属性，全局唯一</p><p><code>std::unordered_map</code>，存放对象与 ObjectAssociationMap（这里的对象指的是添加属性的分类）</p><h3 id="ObjectAssociationMap"><a href="#ObjectAssociationMap" class="headerlink" title="ObjectAssociationMap"></a>ObjectAssociationMap</h3><p><code>std::map</code>，存放 key 与 ObjcAssociation</p><h3 id="ObjcAssociation"><a href="#ObjcAssociation" class="headerlink" title="ObjcAssociation"></a>ObjcAssociation</h3><p>存放 value 和 policy</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _object_set_associative_reference(<span class="type">id</span> object, <span class="type">void</span> *key, <span class="type">id</span> value,</span><br><span class="line">    uintptr_t policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化一个旧值</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acquireValue 会对新的值进行 retain or copy，可以看下下面的源码</span></span><br><span class="line">    <span class="type">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 全局单例</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 全局的 unordered_map</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="comment">// 将被关联对象转化一下，DISGUISE 仅仅对 object 做了位运算</span></span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (new_value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 新值不为空，则开始插入</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果被关联对象已经在全局的 unordered_map 注册过，则找到对应的 map</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// map 找到了则记录旧值以备释放，并更新新值</span></span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// map 找不到则直接插入</span></span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果被关联对象没有在全局的 unordered_map 注册过，则创建 map 并注册</span></span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                <span class="comment">// 将值插入到新的 map 中</span></span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 新的值为空，准备删除旧值（如果有的话）</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end())</span><br><span class="line">            &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 记录旧值等待释放并从 map 中移除</span></span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放旧值（如果需要的话）</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue())</span><br><span class="line">        ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> id <span class="title">acquireValue</span><span class="params">(id value, <span class="type">uintptr_t</span> policy)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">            <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">        <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">            <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(value, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DISGUISE 仅仅对 object 做了位运算</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">disguised_ptr_t</span> <span class="title">DISGUISE</span><span class="params">(id value)</span> </span>&#123; <span class="keyword">return</span> ~<span class="built_in">uintptr_t</span>(value); &#125;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li><p>关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？</p><p>  关联对象并不是存放在被关联对象本身的内存中，而是存放在一个全局的 <code>unordered_map</code> 中</p><p>  其中 <code>unordered_map</code> 存储着被关联的对象与 <code>map</code>，其中 map 存放着关联对象的 key 和关联对象</p><p>  获取关联对象时，首先通过被关联对象的地址找到 <code>map</code>，然后通过关联对象的 key 找到关联对象并返回</p></li><li><p>为什么 AssociationsHashMap 是使用 <code>unordered_map</code>，而 ObjectAssociationMap 使用 <code>map</code></p><p>  <code>unordered_map</code> 查找更加高效，大多数情况下应该选择 <code>unordered_map</code>，而 ObjectAssociationMap 使用 <code>map</code> 应该是出于内存考虑</p><p>  详细可参考 <a href="https://norcy.github.io/wiki/arch/面试/C++/unordered_map%20与%20map%20的区别"><code>unordered_map</code> 与 <code>map</code> 的区别</a></p></li></ul><ul><li><p>为什么内存管理策略中没有 weak 选项，即 <code>OBJC_ASSOCIATION_WEAK</code></p><p>  可参考 <a href="../如何为分类添加属性/">如何为分类添加属性</a></p></li><li><p>关联对象如果真的有需要使用 weak 的话，怎么办？</p><p>  可参考 <a href="../如何为分类添加属性/">如何为分类添加属性</a></p></li></ul><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul><li><a href="../如何为分类添加属性/">如何为分类添加属性</a></li><li><a href="https://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/">Objective-C Associated Objects 的实现原理</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-532/runtime/objc-references.mm.auto.html">源码</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;提问&quot;&gt;&lt;a href=&quot;#提问&quot; class=&quot;headerlink&quot; title=&quot;提问&quot;&gt;&lt;/a&gt;提问&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？&lt;/li&gt;
&lt;li&gt;为什么 AssociationsHashMap</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="Runtime" scheme="https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%88%86%E7%B1%BB/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%88%86%E7%B1%BB/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分类的源码"><a href="#分类的源码" class="headerlink" title="分类的源码"></a>分类的源码</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;                           <span class="comment">// 原类名，而不是分类名</span></span><br><span class="line">    <span class="comment">// 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象</span></span><br><span class="line">    classref_t cls;                             </span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;      <span class="comment">// 分类中新增的对象方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;         <span class="comment">// 分类中新增的类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;          <span class="comment">// 分类中新增的协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties; <span class="comment">// 分类中新增的属性列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分类为什么不能添加实例变量"><a href="#分类为什么不能添加实例变量" class="headerlink" title="分类为什么不能添加实例变量"></a>分类为什么不能添加实例变量</h2><ol><li>从底层结构上看：没有实例变量的相关字段，所以分类是无法添加实例变量的（即分类在编译时无法保存实例变量的信息，而 instanceProperties 的存在说明属性是可以的）</li><li>从内存结构上看：在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局（即使分类保存了实例变量的信息，运行时也无法向本类添加实例变量）</li></ol><p>如何理解<strong>在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局</strong>？</p><p>那为什么添加方法就不会呢？还得从 <code>objc_class</code> 的结构说起</p><blockquote><p>注：本文关于 <code>objc_class</code> 的源码都是基于老版本的源码，其结构更容易理解</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class</span><br><span class="line">&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class   OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info           OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars            OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists   OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="type">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="type">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ivars 是一个一级指针，指向的是一个 <code>objc_ivar_list</code> 类，其中 <code>ivar_list</code> 的大小是可变的；这个可以在 <code>class_addIvar</code> 的实现中找到</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="type">char</span> *name, size_t size, </span><br><span class="line">              uint8_t alignment, <span class="keyword">const</span> <span class="type">char</span> *type)</span><br><span class="line">&#123;    </span><br><span class="line">    ivar_list_t *oldlist, *newlist;</span><br><span class="line">    <span class="keyword">if</span> ((oldlist = (ivar_list_t *)cls-&gt;data()-&gt;ro-&gt;ivars)) &#123;</span><br><span class="line">        size_t oldsize = oldlist-&gt;byteSize();</span><br><span class="line">        <span class="comment">// 重新分配内存，影响的是 ivar_list 的大小</span></span><br><span class="line">        newlist = (ivar_list_t *)calloc(oldsize + oldlist-&gt;entsize(), <span class="number">1</span>);</span><br><span class="line">        memcpy(newlist, oldlist, oldsize);</span><br><span class="line">        free(oldlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newlist = (ivar_list_t *)calloc(<span class="keyword">sizeof</span>(ivar_list_t), <span class="number">1</span>);</span><br><span class="line">        newlist-&gt;entsizeAndFlags = (uint32_t)<span class="keyword">sizeof</span>(ivar_t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t offset = cls-&gt;unalignedInstanceSize();</span><br><span class="line">    uint32_t alignMask = (<span class="number">1</span>&lt;&lt;alignment)<span class="number">-1</span>;</span><br><span class="line">    offset = (offset + alignMask) &amp; ~alignMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对这块内存进行复写</span></span><br><span class="line">    ivar_t&amp; ivar = newlist-&gt;get(newlist-&gt;count++);</span><br><span class="line">    ivar.offset = (int32_t *)malloc(<span class="keyword">sizeof</span>(int32_t));</span><br><span class="line">    *ivar.offset = offset;</span><br><span class="line">    ivar.name = name ? strdupIfMutable(name) : <span class="literal">nil</span>;</span><br><span class="line">    ivar.type = strdupIfMutable(type);</span><br><span class="line">    ivar.alignment_raw = alignment;</span><br><span class="line">    ivar.size = (uint32_t)size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向这个新的 list</span></span><br><span class="line">    ro_w-&gt;ivars = newlist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 instance_size</span></span><br><span class="line">    cls-&gt;setInstanceSize((uint32_t)(offset + size));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用 <code>class_addIvar</code> 会添加一个实例变量，影响 <code>instance_size</code> 和 ivars 所指向的空间的大小。但是仍然无法解释为什么不能添加 ivars</p><p>此时还得知道一个 ivar 是如何被系统访问的，如果按照以下这种方式访问 ivar，整个流程要经过好多次指针转移：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> -&gt; <span class="keyword">class</span>.rw_data -&gt; <span class="keyword">class</span>.rw_data.ro_data -&gt; <span class="keyword">class</span>.rw_data.ro_data.ivars -&gt; </span><br><span class="line">-&gt; <span class="keyword">class</span>.rw_data.ro_data.ivars.first[n]</span><br></pre></td></tr></table></figure><p>如果是这样，那么动态添加 ivar 似乎变得可行，因为 ivar 是指针，往指针指向的内容扩充并不会影响类的大小，访问时只要遍历所有 ivar list 就可以找到对应的 ivar，但是这样访问，大量使用 ivar 肯定很耗时。事实上 Runtime 不是这样访问 ivar 的</p><p>那么，对于 ivar 的访问究竟是怎么样的呢？</p><p>这篇 <a href="https://satanwoo.github.io/2018/02/04/iOS-iVar/">《谈谈 ivar 的直接访问》</a> 提到，对 ivar 的访问，其实是在编译期将 ivar 相对于类本身的偏移量存储在一个全局变量里，全局变量的值在编译的时候就确定了，这个全局变量的地址就存在 <code>objc_ivar</code> 的 <code>ivar_offset</code></p><p>即编译时，系统会将对这个 ivar 的读写访问的代码转为，本类地址加上对应的全局偏移量，就能访问到对应 ivar 的值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> myInt;</span><br><span class="line"><span class="keyword">self</span>.myInt = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>编译后的代码为</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">unsigned</span> <span class="type">long</span> OBJC_IVAR_$_MyObject$_myInt;</span><br><span class="line">(*(<span class="built_in">NSInteger</span> *)((<span class="type">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_MyObject$_myInt)) = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>而正是由于这种关系，在运行时如果想添加一个 ivar，势必会导致所有全局偏移量不正确</p><blockquote><p>有人会说，如果加在 ivar list 的前面会影响旧的 ivar 的全局偏移量，那加在 ivar list 后面不就影响不了吗？<br>答案是，类是可以被继承的，给父类的 ivar list 尾部添加一个 ivar，尽管不影响父类自己的 ivar 偏移，却影响了子类的 ivar 偏移</p></blockquote><p>这个就是所谓的<strong>在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局</strong></p><p>对于方法的访问与 ivar 的访问不同，是通过 <code>objc_msgSend</code> 找到对应的方法列表，所以可以动态添加方法</p><p>那运行时如何给类添加实例变量呢？</p><p>只能在 <code>objc_allocateClassPair</code> 与 <code>objc_registerClassPair</code> 两个函数之间为类添加变量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">id</span>), log2(<span class="keyword">sizeof</span>(<span class="type">id</span>)), <span class="keyword">@encode</span>(<span class="type">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">id</span>), log2(<span class="keyword">sizeof</span>(<span class="type">id</span>)), <span class="keyword">@encode</span>(<span class="type">id</span>));</span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><h2 id="分类方法的加载与覆盖"><a href="#分类方法的加载与覆盖" class="headerlink" title="分类方法的加载与覆盖"></a>分类方法的加载与覆盖</h2><p>我们主要探究四个问题：</p><ol><li>分类的方法什么时候被添加到本类</li><li>分类的方法在运行时会覆盖本类，那么在内存结构中是否覆盖了本类</li><li>分类在运行时是怎么覆盖本类方法</li><li>如果有多个分类有同名的方法，其调用顺序是怎样的</li></ol><h3 id="分类插入本类方法的源码"><a href="#分类插入本类方法的源码" class="headerlink" title="分类插入本类方法的源码"></a>分类插入本类方法的源码</h3><p>启动时，<code>_objc_init</code> 里面的调用的 <code>map_images</code> 最终会调用 objc-runtime-new.mm 里面的 <code>_read_images</code> 方法有以下的代码片段，我们删除一些无用代码得到</p><blockquote><p>注：如果一个类实现了 +load 方法，那么它就会在启动时被加载，会调用 realizeClass 进行加载，加载后 isRealized 将会返回 true；如果没实现 +load 方法，那么就会懒加载这个类，直到给这个类发送消息时才会去 realizeClass。懒加载和非懒加载处理分类的时机是不一样的，但是原理大致相同。我们这里只讨论类和分类都实现了 +load 的情况，更多情况请参考 <a href="https://juejin.im/post/5e20898c6fb9a02fd46faf99">iOS 底层探索 - 分类的加载</a></p></blockquote><p>以下是处理分类的代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. </span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// hi 表示 headerInfo</span></span><br><span class="line">    <span class="comment">// 从每一个 headerInfo 中获取分类列表以及分类个数</span></span><br><span class="line">    category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的 count 指的是一个头文件定义的分类个数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取分类实例</span></span><br><span class="line">        category_t *cat = catlist[i];</span><br><span class="line">        <span class="comment">// 获取分类指向的本类</span></span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理本类不存在的异常</span></span><br><span class="line">        <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">            <span class="comment">// 此处省略...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始处理分类</span></span><br><span class="line">        <span class="comment">// 第一步，注册分类到本类（addUnattachedCategoryForClass）</span></span><br><span class="line">        <span class="comment">// 第二步，重建这个类的方法列表（remethodizeClass）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理实例方法、协议、属性</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">            ||  cat-&gt;instanceProperties) </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照同样的逻辑处理类方法、协议、类属性</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols) </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls-&gt;ISA());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要告诉我们，在启动初始化 objc 的时候分类的方法列表会被插到本类的方法中</p><p>它主要实现了，遍历所有头文件获取所有分类列表，并对每个分类：</p><ol><li>把 category 的实例方法、协议以及属性添加到类上</li><li>把 category 的类方法和协议添加到类的 metaclass 上</li></ol><p>这里我们只研究实例方法的插入，其他项是同理的</p><p>addUnattachedCategoryForClass 只是负责把类和 category 做一个关联映射，并没有修改类的结构，我们暂不关心</p><p>真正生效的是 remethodizeClass，它负责重新对方法列表进行排列，但其实也是一个壳，主要调用了 attachCategories</p><blockquote><p>注：由于我们对分类和类写了 +load，所以执行到这里的时候，类已经被加载过了，所以 isRealized 是 true</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新对方法列表进行排列</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unattachedCategoriesForClass，我们暂不关心</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> attachCategories(Class cls, category_list *cats, <span class="type">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本类的所有分类的所有方法列表</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="comment">// 本类的所有分类的所有属性列表</span></span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="comment">// 本类的所有分类的所有协议列表</span></span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法个数</span></span><br><span class="line">    <span class="type">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 属性个数</span></span><br><span class="line">    <span class="type">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 协议个数</span></span><br><span class="line">    <span class="type">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 分类的个数，这里一般是 1 个，因为参数是每个头文件中的每个分类</span></span><br><span class="line">    <span class="type">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="type">bool</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">// 从后往前数，获取每一个分类</span></span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理方法</span></span><br><span class="line">        <span class="comment">// 获取该分类的所有方法</span></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="comment">// 并插到临时变量 mlists 的尾部</span></span><br><span class="line">            <span class="comment">// 注意分类的遍历顺序，最终会导致分类列表中靠后的分类的方法排在 mlists 前面</span></span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理属性列表，同理</span></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理协议，同理</span></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rw 代表原类的信息</span></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会对同个分类的方法进行排序，比如 test2 排在 test 前面</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</span><br><span class="line">    <span class="comment">// 将获取到的分类的所有方法，添加到原类的方法前面</span></span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了两件事，以实例方法为例，属性和协议同理</p><p>注意这里虽然是数组，但是一般只有一个类，即 <code>cats-&gt;count</code> = 1</p><ol><li>把所有分类的方法读取出来放到一个数组里，越靠后的分类的方法在数组中的位置越靠前</li><li>把这个方法数组添加到原类方法的首部，见 attachLists</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        <span class="comment">// void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1</span></span><br><span class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!list &amp;&amp; addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        list = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = list;</span><br><span class="line">        uint32_t oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 attachLists 方法，就是分类方法覆盖本类方法的关键所在</p><p>首先，我们要明确，每次进入这个方法的参数 addedLists，是指一个分类的所有方法；这个方法实现的是将一个分类的所有方法添加到类结构的方法列表前面（虽然这里的参数可能是一个 <code>method_list_t</code>，不过实测下来这个数组只会有一个元素，因此暂时理解为一个元素）</p><p>然后我们看看这里是怎么实现的，这里主要处理如何将一个元素添加进数组，根据数组的情况分为 3 种情况</p><ol><li>类的方法列表中没有 <code>method_list_t</code> 时，把单个新增元素这个赋值给指针（0 lists -&gt; 1 list）</li><li>类的方法列表中只有一个 <code>method_list_t</code> 时，重新申请内存，把老的第 0 个元素挪到最后，再把新增元素拷贝到最前</li><li>类的方法列表中有多个 <code>method_list_t</code> 时，重新申请内存，把老的元素通过 memmove 挪到最后，再把新增元素拷贝到最前</li></ol><p>如果一个类自身没有声明方法时，当第一个分类进来的时候就会进到情况 1；再继续处理第二个分类或者本类已经有方法的时候回进入到情况 2，其他会进入情况 3。这一点还是很好理解的，主要看现在的类结构里面有没有方法列表</p><blockquote><p><code>void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1</code></p><p><code>void *memcpy(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1</code></p><p>在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。</p></blockquote><h3 id="加载分类同名方法的源码"><a href="#加载分类同名方法的源码" class="headerlink" title="加载分类同名方法的源码"></a>加载分类同名方法的源码</h3><p>我们先看看 <code>objc_class</code> 结构中 methodLists 这个二级指针。首先，<code>**methodLists</code> 是个二级指针，它指向的是一个数组，这个数组就是由 <code>objc_method_list</code> 构成，它是一个一维数组，即 <code>*methodLists</code>，如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/1655773-07d479dfb23de929.png" alt></p><blockquote><p>注：在最新的 Runtime 源码中，<code>objc_method_list</code> 被替换为 <code>method_list_t</code>，所以 methodLists 也可以看是 <code>method_list_t</code> 的二级指针</p></blockquote><p>假如本类有 a、b 方法，分类 1 有 a、c、d 方法，分类 2 有 a、e 方法，分类 1 先声明，则 methodLists 的方法列表应该如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*methodLists = [[a, e], [a, c, d], [a, b]];</span><br></pre></td></tr></table></figure><p>其中 [a, e]、[a, c, d] 和 [a, b] 都是一个 <code>method_list_t</code>。</p><p>从 <code>category_t</code> 的结构中我们可以看出，一个分类拥有一个 <code>method_list_t</code>，即分类本身的方法列表；而本类的方法列表存放的是一个指针，指向的是一个数组，这个数组的元素是 <code>method_list_t</code></p><p>关于这个数据结构的证明我们除了从这篇文章可以得到 <a href="https://www.jianshu.com/p/50667aa7eca0">二级指针指向的数据结构是什么样的？</a>，也可以从方法的调用中一探究竟</p><p>首先，我们看下方法调用的栈</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend -&gt; _class_lookupMethodAndLoadCache3 -&gt; lookUpImpOrForward</span><br></pre></td></tr></table></figure><p>lookUpImpOrForward 关键代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="type">id</span> inst, </span><br><span class="line">                       <span class="type">bool</span> initialize, <span class="type">bool</span> cache, <span class="type">bool</span> resolver)</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line"><span class="comment">// 1. 找缓存</span></span><br><span class="line">imp = cache_getImp(cls, sel);</span><br><span class="line"><span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 找本类</span></span><br><span class="line">&#123;</span><br><span class="line">    Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 找父类</span></span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br></pre></td></tr></table></figure><p>可以看到先找缓存，再找本类，最后找父类，最关键的是 <code>getMethodNoSuper_nolock</code>，源码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *getMethodNoSuper_nolock(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        method_t *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的 methods 是 <code>objc_class</code> 中的结构，是新版本源码，我们这里关于 <code>objc_class</code> 是老的源码，但这并不妨碍我们理解</p></blockquote><p><code>objc_class</code> 的 methods 是一个二级指针，其指向一个数组，数组的每个元素都是一个 <code>method_list_t *</code></p><p><code>cls-&gt;data()-&gt;methods.beginLists()</code> 返回的是该数组的第一个元素的迭代器（类比 C++ STL 中的 list 的 begin()），对其解引用后可以得到一个 <code>method_list_t *</code>。这个也是 <code>search_method_list</code> 的入参</p><p><code>search_method_list</code> 的源码可以直接简化如下，对这个一维数组进行顺序查找，找到立刻返回</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *search_method_list(<span class="keyword">const</span> method_list_t *mlist, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">        <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结成一句话就是，方法查找时，从类的 method 列表中开始顺序查找，列表的每个元素是一个 <code>method_list_t</code>，这个结构里面存储着一个分类或本类的方法列表，遍历这个 <code>method_list_t</code> 与调用的方法的名字是否一致，一致则返回</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li><p>分类的方法什么时候被添加到本类</p><p> 答：在启动的时候，<code>objc_setup</code> 阶段会进行 objc 类的注册，将分类的方法插到本类的方法列表</p></li><li><p>分类的方法在运行时会覆盖本类，那么在内存结构中是否覆盖了本类</p><p> 答：对于 load 方法来说比较特殊，见下节；对于普通方法来说，<strong>内存结构中分类的方法并没有覆盖本类，而是插到了本类的方法列表前面</strong></p></li><li><p>分类在运行时是怎么覆盖本类方法</p><p> 答：<code>objc_msgSend</code> 时，会从类的方法列表中查找对应的 method，是从头往后查找的，<strong>由于分类的方法被插在了本类的方法前面，因此会优先找到，从而达到了覆盖的效果</strong></p></li><li><p>如果有多个分类有同名的方法，其调用顺序是怎样的</p><p> 答：分类的顺序是按照在编译选项中的顺序决定的，越靠后的分类的方法会被放到本类方法列表的越前面，会被优先调用到。</p></li></ol><h2 id="如何调试-Runtime"><a href="#如何调试-Runtime" class="headerlink" title="如何调试 Runtime"></a>如何调试 Runtime</h2><p>可以<a href="https://github.com/SimonYHB/objc4-750.git">下载源码</a></p><p>Xcode 11.4 无法编译成功，改为 11.3.1 才可。另外 10.15 系统版本的 Mac 需要选择 Deployment Target 为 10.14 才能编译成功</p><p>使用以下源码来判断正在处理哪一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cls-&gt;<span class="built_in">data</span>()-&gt;ro-&gt;name, <span class="string">&quot;Person&quot;</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="如何为分类添加属性"><a href="#如何为分类添加属性" class="headerlink" title="如何为分类添加属性"></a><a href="../如何为分类添加属性">如何为分类添加属性</a></h3><p>关联对象</p><h3 id="分类的-load-方法顺序"><a href="#分类的-load-方法顺序" class="headerlink" title="分类的 load 方法顺序"></a><a href="../../基础/iOS%20的%20initialize%20和%20load%20区别/">分类的 load 方法顺序</a></h3><p>父类 &gt; 本类 &gt; 分类</p><h3 id="分类的-initialize-方法顺序"><a href="#分类的-initialize-方法顺序" class="headerlink" title="分类的 initialize 方法顺序"></a><a href="../../基础/iOS%20的%20initialize%20和%20load%20区别/">分类的 initialize 方法顺序</a></h3><p>父类 &gt; 本类 &gt; 分类</p><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><ul><li><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm64.s.auto.html">objc_msgSend 汇编源码</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-750/runtime/objc.h.auto.html">objc_object 源码</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-runtime-old.h.auto.html">objc_class 源码（老）</a></li><li><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-runtime-new.mm.auto.html">其他相关源码</a> </li><li><a href="https://opensource.apple.com/source/objc4/objc4-750/runtime/objc-runtime-new.h.auto.html"><code>category_t</code> 定义源码</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分类的源码&quot;&gt;&lt;a href=&quot;#分类的源码&quot; class=&quot;headerlink&quot; title=&quot;分类的源码&quot;&gt;&lt;/a&gt;分类的源码&lt;/h2&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="Runtime" scheme="https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%A6%82%E4%BD%95%E4%B8%BA%E5%88%86%E7%B1%BB%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%A6%82%E4%BD%95%E4%B8%BA%E5%88%86%E7%B1%BB%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Runtime-原理"><a href="#Runtime-原理" class="headerlink" title="Runtime 原理"></a>Runtime 原理</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;                           <span class="comment">// 原类名，而不是分类名</span></span><br><span class="line">    <span class="comment">// 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象</span></span><br><span class="line">    classref_t cls;                             </span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;      <span class="comment">// 分类中新增的对象方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;         <span class="comment">// 分类中新增的类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;          <span class="comment">// 分类中新增的协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties; <span class="comment">// 分类中新增的属性列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，但不可以添加成员变量</p><p>instanceProperties 的存在是我们可以通过 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 向分类中增加实例变量的原因，不过这个和一般的实例变量是不一样的</p><p>所以，Category 可以使用 <code>@property</code>，但不会生成带下划线的成员变量，也不会生成 getter 和 setter（<code>@property</code> 只是帮助声明了 setter/getter，并没有提供实现）。我们可以使用 Runtime 为已有的类添加新的属性并生成 getter 和 setter 方法</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> objc_setAssociatedObject (<span class="type">id</span> object, <span class="type">void</span> *key, <span class="type">id</span> value, objc_AssociationPolicy policy);</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> objc_getAssociatedObject(<span class="type">id</span> object, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> objc_removeAssociatedObject(<span class="type">id</span> object);    <span class="comment">// 移除 object 上的所有关联对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li>id object：被关联的对象（一般为 self）</li><li>const void <code>*key</code>：关联的key，要求唯一，因此避免使用 @””（一般为新增属性的 getter）</li><li>id value：关联的对象（一般为新增的属性）</li><li>objc_AssociationPolicy policy：内存管理的策略</li></ul><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>关联的 key 值有三种推荐值</p><ol><li>声明 <code>static char kAssociatedObjectKey;</code>，使用 &amp;kAssociatedObjectKey 作为 key 值</li><li>声明 <code>static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey;</code> ，使用 kAssociatedObjectKey 作为 key 值</li><li>用 selector ，使用 getter 方法的名称作为 key 值（推荐）</li></ol><p>设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。</p><p>所以 key 值最好定义为一个全局静态变量，而不能每次都用 @”xxx”</p><p>推荐使用 selector，因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性</p><h3 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h3><p>其中 objc_AssociationPolicy 是关联对象的属性，如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN             --- <span class="keyword">assign</span></span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC   --- <span class="keyword">nonatomic</span>, <span class="keyword">retain</span></span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC     --- <span class="keyword">nonatomic</span>, <span class="keyword">copy</span></span><br><span class="line">OBJC_ASSOCIATION_RETAIN             --- <span class="keyword">retain</span>(<span class="keyword">strong</span>)</span><br><span class="line">OBJC_ASSOCIATION_COPY               --- <span class="keyword">copy</span></span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">VN_ShortCut</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UICollectionView</span> *vn_cellCollectionView;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">VN_ShortCut</span>)</span></span><br><span class="line">- (<span class="built_in">UICollectionView</span> *)vn_cellCollectionView </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vn_cellCollectionView));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setVn_cellCollectionView:(<span class="built_in">UICollectionView</span> *)cellCollectionView </span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vn_cellCollectionView), cellCollectionView, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="为什么内存管理策略中没有-weak-选项，即-OBJC-ASSOCIATION-WEAK"><a href="#为什么内存管理策略中没有-weak-选项，即-OBJC-ASSOCIATION-WEAK" class="headerlink" title="为什么内存管理策略中没有 weak 选项，即 OBJC_ASSOCIATION_WEAK"></a>为什么内存管理策略中没有 weak 选项，即 <code>OBJC_ASSOCIATION_WEAK</code></h2><p>如果真的有 weak 选项，我们期望的结果是当被关联对象被释放之后，从关联对象身上取出的“属性”是 nil</p><p>首先我们要搞懂 weak 属性的实现原理，简单来说，Runtime 在底层维护一个全局的 weak 表，每次当一个 weak 指针被赋值对象的时候，会将对象地址和 weak 指针地址注册到 weak 表中，其中对象地址作为 key；当对象被废弃时，可根据对象地址快速寻找到指向它的所有 weak 指针，并将 weak 指针置为 nil，同时移出 weak 表</p><p>所以，实现 weak 的前提是存在一个 weak 指针指向到被引用对象的地址，而通过对以上源码的研究，我们可以知道关联对象和被关联对象之间并没有这样一个 weak 指针，因此无法实现 <code>OBJC_ASSOCIATION_WEAK</code></p><p>更具体的，如下代码，一个 weak 指针或属性，都会在编译时就变转化成 <code>objc_initWeak</code>，这样运行时才能正确往 weak 表里面添加变量。但是关联对象并没有实例变量，所以不能实现 weak</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况 1，weak 变量</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>; <span class="comment">// weakSelf 是指向原对象的指针，会被存进 weak 表</span></span><br><span class="line"><span class="comment">// 情况 2，weak 属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> delegate;</span><br><span class="line"><span class="comment">// 本质是转换为 setter</span></span><br><span class="line">- (<span class="type">void</span>)setDelegate:(<span class="type">id</span>)delegate &#123;</span><br><span class="line">    <span class="keyword">if</span> (_delegate != delegate) &#123;</span><br><span class="line">        objc_initWeak(&amp;_delegate, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p.s. 注意<a href="https://juejin.im/post/5af86b276fb9a07aa34a59e6">这篇文章</a>的解释是错的</p><h2 id="如何实现-weak-属性"><a href="#如何实现-weak-属性" class="headerlink" title="如何实现 weak 属性"></a>如何实现 weak 属性</h2><p>注意 <code>OBJC_ASSOCIATION_ASSIGN</code> 的作用是 assign 而不是 weak，所以当关联的对象被释放的时候并不会被自动置为 nil，因此获取到的对象将会是一个野指针。</p><h3 id="直观的方法-1"><a href="#直观的方法-1" class="headerlink" title="直观的方法 1"></a>直观的方法 1</h3><p>如果要实现 weak 的效果，解决方法是新建一个替身，weak 引用住该对象，然后使用 <code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 存储该替身。</p><p>以上面的例子为例，代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UICollectionView</span> *)vn_cellCollectionView</span><br><span class="line">&#123;</span><br><span class="line">    QVNWeakProxy *proxy = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vn_cellCollectionView));</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">UICollectionView</span> *)proxy.target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setVn_cellCollectionView:(<span class="built_in">UICollectionView</span> *)cellCollectionView</span><br><span class="line">&#123;</span><br><span class="line">    QVNWeakProxy *proxy = [[QVNWeakProxy alloc] initWithTarget:cellCollectionView];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 QVNWeakProxy 只要继承自 NSObject 并拥有一个 weak 的 target 的属性即可</p><h3 id="优雅的方法-2"><a href="#优雅的方法-2" class="headerlink" title="优雅的方法 2"></a>优雅的方法 2</h3><p>变量用 <code>__weak</code> 修饰，因此被 block 捕获的时候不会增加引用计数；block 使用 copy 修饰，可以将栈 block 转为堆 block，防止被释放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UICollectionView</span> *)vn_cellCollectionView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> (^block)(<span class="type">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vn_cellCollectionView));</span><br><span class="line">    <span class="keyword">return</span> (block ? block() : <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setVn_cellCollectionView:(<span class="built_in">UICollectionView</span> *)cellCollectionView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> __<span class="keyword">weak</span> weakObject = cellCollectionView;</span><br><span class="line">    <span class="type">id</span> (^block)(<span class="type">void</span>) = ^&#123;<span class="keyword">return</span> weakObject;&#125;;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vn_cellCollectionView), block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Runtime-原理&quot;&gt;&lt;a href=&quot;#Runtime-原理&quot; class=&quot;headerlink&quot; title=&quot;Runtime 原理&quot;&gt;&lt;/a&gt;Runtime 原理&lt;/h2&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="Runtime" scheme="https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%8F%E8%AE%AE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/Runtime/%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8D%8F%E8%AE%AE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果是协议中的属性，编译器不会自动合成实例变量，相当于只是声明了 setter/getter（注意是声明，没有实现）</p><p>第一步，声明协议</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QVNImageProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;QVNInnerImageLoadDelegate&gt; vn_imageDelegate;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>第二步，实现协议的人需要自动合成实例变量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QVNImageView</span> &lt;<span class="title">QVNImageLoadDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QVNImageView</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> vn_imageDelegate;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>问题来了，自动合成的属性会不会拥有 weak/assign/readonly 等属性呢</p><p>实测下来是会的，@synthesize 帮你合成的 setter/getter 会根据协议中 @property 的修饰词来确定</p><p>当然你也可以模仿 @synthesize 的作用，手动添加成员变量和 setter/getter</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QVNImageView</span> &lt;<span class="title">QVNImageLoadDelegate</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span>&lt;QVNInnerImageLoadDelegate&gt; _vn_imageDelegate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QVNImageView</span></span></span><br><span class="line">- (<span class="type">id</span>&lt;QVNInnerImageLoadDelegate&gt;)vn_imageDelegate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _vn_imageDelegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setVn_imageDelegate:(<span class="type">id</span>&lt;QVNInnerImageLoadDelegate&gt;)vn_imageDelegate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (vn_imageDelegate != _vn_imageDelegate)</span><br><span class="line">    &#123;</span><br><span class="line">        _vn_imageDelegate = vn_imageDelegate;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>问题：这种情况能否使用 @property 来代替 @synthesize</p><p>回答：可以但不建议。因为使用 @property 会有代码重复和歧义，原来协议中定义的修饰符会被你新增的 property 修饰符覆盖，并且后续协议中的属性修改后，这里的代码不会有任何报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果是协议中的属性，编译器不会自动合成实例变量，相当于只是声明了 setter/getter（注意是声明，没有实现）&lt;/p&gt;
&lt;p&gt;第一步，声明协议&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="Runtime" scheme="https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/Runtime/%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/Runtime/%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 Method</span></span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保这两个方法一定存在（要么在本类，要么在其父类里）</span></span><br><span class="line">    <span class="keyword">if</span> (originalMethod &amp;&amp; swizzledMethod)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果本类没有 origin 方法，则给 originalSelector 添加 swizzled 实现（origin 方法在父类，因为 originalMethod 不为空），返回 YES</span></span><br><span class="line">        <span class="comment">// 如果本类有 origin 方法，则添加失败，返回 NO</span></span><br><span class="line">        <span class="type">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加成功，表示已实现 originalSelector -&gt; swizzledIMP</span></span><br><span class="line">            <span class="comment">// 接下来实现 swizzledSelector -&gt; originalIMP</span></span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加失败，表示类里原本就有 originalIMP，只需要交换这两个方法的实现即可</span></span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        swizzleMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidLoad), <span class="keyword">@selector</span>(my_viewDidLoad));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)my_viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;View Did Load&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> my_viewDidLoad];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如何交换类方法</p><p> 只要把 self 换成 <code>object_getClass(self)</code> 即可</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        swizzleMethod(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(originClassMethod), <span class="keyword">@selector</span>(swizzleClassMethod));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>为什么不能直接调用 <code>method_exchangeImplementations</code></p><p> 比如</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 Method</span></span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">    </span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 直接交换 IMP 是很危险的。因为如果这个类中没有实现这个方法，<code>class_getInstanceMethod()</code> 返回的是某个父类的 Method 对象，这样 <code>method_exchangeImplementations()</code> 就把父类的原始实现（IMP）跟这个类的 Swizzle 实现交换了。这样其他父类及其其他子类的方法调用就会出问题，最严重的就是 Crash。但如果这个类中实现了此方法，那么是没任何问题的</p><p> 参见：<a href="https://dandan2009.github.io/2018/04/08/runtime-method-swizzling/">方法交换的图示</a></p></li><li><p>方法交换为什么写在 +load 中而不是 initialze</p></li><li><p>方法交换为什么要 dispatch_once 中执行</p><p> 参见：<a href="https://norcy.github.io/wiki/arch/面试/C++/C++%20%E4%B8%8E%20Objetive-C%20%E7%9A%84%E5%8C%BA%E5%88%AB">iOS 的 initialize 和 load 区别</a></p></li></ol><h2 id="class-getInstanceMethod"><a href="#class-getInstanceMethod" class="headerlink" title="class_getInstanceMethod"></a>class_getInstanceMethod</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method class_getInstanceMethod(Class cls, SEL name);</span><br></pre></td></tr></table></figure><p>获取指定 SEL 的 Method</p><p>如果该类没有指定 SEL 的 Method，父类里面可能有</p><p>所以如果该类和其父类都没有该 SEL 的实现，才返回 NULL</p><h2 id="class-addMethod"><a href="#class-addMethod" class="headerlink" title="class_addMethod"></a>class_addMethod</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="type">char</span> *types);</span><br></pre></td></tr></table></figure><p>给指定 SEL 添加新实现。如果添加成功则返回 YES，否则返回 NO（比如该类已经有对应 SEL 的 IMP）</p><p>注意，该方法会覆盖父类的实现，但不会替换本类原有的实现。如果要替换本类原有实现，使用 <code>method_setImplementation</code></p><h2 id="class-replaceMethod"><a href="#class-replaceMethod" class="headerlink" title="class_replaceMethod"></a>class_replaceMethod</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="type">char</span> *types);</span><br></pre></td></tr></table></figure><p>替换指定 SEL 的实现，返回值为被替换掉的 IMP</p><ul><li>如果本类不存在该 name 的 Method，则 <code>class_addMethod</code> 会被调用</li><li>如果本类存在该 name 的 Method，则 <code>method_setImplementation</code> 会被调用</li></ul><h2 id="method-exchangeImplementations"><a href="#method-exchangeImplementations" class="headerlink" title="method_exchangeImplementations"></a>method_exchangeImplementations</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_exchangeImplementations(Method m1, Method m2)</span><br></pre></td></tr></table></figure><p>交换两个方法的实现</p><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><ol><li>AOP（Aspect of programming），给所有的 Controller 的 viewWillAppear 等生命函数添加数据上报、日志等</li><li>API 安全性保护，替换 NSArray 的 addObject 方法，防止插入 nil 对象，Debug 下报错，详见 <a href="https://github.com/Norcy/Runtime_Example/blob/master/NSMutableArray%2BSafe.m">Github Demo</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h1&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="Runtime" scheme="https://norcy.github.io/wiki/categories/tech/iOS/Runtime/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Weak-Strong%20Dance/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Weak-Strong%20Dance/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Weak-Strong-Dance"><a href="#Weak-Strong-Dance" class="headerlink" title="Weak-Strong Dance"></a>Weak-Strong Dance</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">    [weakSelf.property removeObserver:weakSelf forKeyPath:<span class="string">@&quot;pathName&quot;</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设 block 被放在子线程中执行，而且执行过程中 self 在主线程被释放了。由于 weakSelf 是一个弱引用，因此会自动变为 nil</p><p>而这个例子的 KVO 中，这会导致崩溃</p><p>解决以上问题的方法很简单，新增一行代码即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">    __<span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>) __<span class="keyword">strong</span> strongSelf = weakSelf;</span><br><span class="line">    [strongSelf.property removeObserver:strongSelf forKeyPath:<span class="string">@&quot;pathName&quot;</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>self 所指向对象的引用计数变成 2，即使主线程中的 self 因为超出作用于而释放，对象的引用计数依然为 1，避免了对象的销毁</p><ol><li><p>Q：下面这行代码，将一个弱引用的指针赋值给强引用的指针，可以起到强引用效果么？</p><p> <code>__typeof(&amp;*self) __strong strongSelf = weakSelf;</code></p><p> A：会的。引用计数描述的是对象而不是指针。strongSelf 会强引用 weakSelf 指向的那个对象。因此对象的引用计数会加一</p></li><li><p>Q：block 内部定义了 strongSelf，会不会因此强引用了 strongSelf？</p><p> A：不会。block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题</p></li><li><p>Q：如果在 block 内部没有强引用，而是通过 if 判断，是不是也可以，比如这样写：</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">wself.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weakSelf)</span><br><span class="line">    &#123;</span><br><span class="line">        [weakSelf.property removeObserver:weakSelf forKeyPath:<span class="string">@&quot;pathName&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> A：不可以！考虑到多线程执行，也许在判断的时候，self 还没释放，但是执行 self 里面的代码时，就刚好释放了</p></li><li><p>Q：那按照这个说法，block 内部强引用也没用啊。也许 block 执行以前，self 就释放了</p><p> A：有用！如果在 block 执行以前，self 就释放了，那么 block 的引用计数降为 0，所以自己就会被释放。这样它根本就不会被执行</p></li><li><p>Q：如果在执行 block 的过程中，block 被释放了怎么办？</p><p> A：简单来说，block 还会继续执行，但是它捕获的指针会变成 nil</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> ObjectA * weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.completion = ^&#123;</span><br><span class="line">    weakSelf.completion = <span class="literal">nil</span>;</span><br><span class="line">    [weakSelf doSomethingElse];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 当我们这样调用时，执行到 <code>weakSelf.completion = nil</code> 时，block 会被释放但会继续执行，weakSelf 会变为 nil，因此 doSomethingElse 不会被执行</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_completion(); <span class="comment">// 直接使用成员变量</span></span><br></pre></td></tr></table></figure><p> 如果这样调用就可以避免 block 的释放，这个会在栈上创建一个 block 的 copy，原始的 block 对象会被释放，但是新的对象会继续正常执行，weakSelf 也不会变 nil</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.completion();</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用系统-API-需不需要使用-weak"><a href="#使用系统-API-需不需要使用-weak" class="headerlink" title="使用系统 API 需不需要使用 weak"></a>使用系统 API 需不需要使用 weak</h2><p>正常情况下是不需要的，比如</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:duration</span><br><span class="line">                     animations:^&#123;</span><br><span class="line">                     [<span class="keyword">self</span>.superview layoutIfNeeded];</span><br><span class="line">                 &#125;];</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.someProperty = xyz;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@&quot;someNotification&quot;</span></span><br><span class="line">                                                  object:<span class="literal">nil</span></span><br><span class="line">                                                   queue:[<span class="built_in">NSOperationQueue</span> mainQueue]</span><br><span class="line">                                              usingBlock:^(<span class="built_in">NSNotification</span> *notification) &#123;</span><br><span class="line">                                              <span class="keyword">self</span>.someProperty = xyz;</span><br><span class="line">                                          &#125;];</span><br></pre></td></tr></table></figure><p>但是如果系统的 API 对 self 有引用的时候就要考虑，比如</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// self-&gt;operationsGroup/operationsQueue-&gt;block-&gt;self</span></span><br><span class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123;</span><br><span class="line">    __typeof__(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    [strongSelf doSomething];</span><br><span class="line">    [strongSelf doSomethingElse];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// self-&gt;observer-&gt;block-&gt;self</span></span><br><span class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">_observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@&quot;testKey&quot;</span></span><br><span class="line">            object:<span class="literal">nil</span></span><br><span class="line">             queue:<span class="literal">nil</span></span><br><span class="line">        usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</span><br><span class="line">      __typeof__(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">      [strongSelf dismissModalViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="封装常用的宏"><a href="#封装常用的宏" class="headerlink" title="封装常用的宏"></a>封装常用的宏</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WS __typeof(&amp;*self) __weak weakSelf = self</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SS __typeof(&amp;*self) __strong strongSelf = weakSelf</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Weak-Strong-Dance&quot;&gt;&lt;a href=&quot;#Weak-Strong-Dance&quot; class=&quot;headerlink&quot; title=&quot;Weak-Strong Dance&quot;&gt;&lt;/a&gt;Weak-Strong Dance&lt;/h2&gt;&lt;figure class</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="内存管理" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/autorelease/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/autorelease/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="autorelease-的伪代码实现"><a href="#autorelease-的伪代码实现" class="headerlink" title="autorelease 的伪代码实现"></a>autorelease 的伪代码实现</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj autorelease];</span><br></pre></td></tr></table></figure><p>等同于以下代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject.m:</span></span><br><span class="line">- (<span class="type">id</span>)autorelease </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSAutoreleasePool. 类方法</span></span><br><span class="line">+ (<span class="type">void</span>)addObject:(<span class="type">id</span>)anObj </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = 获取正在使用中的 pool；</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">nil</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        [pool addObject:anObj];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSAutoreleasePool.m 实例方法</span></span><br><span class="line">- (<span class="type">void</span>)addObject:(<span class="type">id</span>)anObj </span><br><span class="line">&#123;</span><br><span class="line">    [array addObject:anObj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关于获取正在使用中的 pool，以下例子的 obj 在调用 autorelease 时取到的 autoreleasepool 就是 poo2</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool1 = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool2 = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">[obj autorelease]</span><br><span class="line"></span><br><span class="line">[poo1 drain];</span><br><span class="line">[poo2 drain];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drain 的实现</span></span><br><span class="line">- (<span class="type">void</span>)drain</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> emptyPool];</span><br><span class="line">    [array release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)emptyPool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> array)</span><br><span class="line">    &#123;</span><br><span class="line">        [obj release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="autorelease-苹果的实现"><a href="#autorelease-苹果的实现" class="headerlink" title="autorelease 苹果的实现"></a>autorelease 苹果的实现</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="type">void</span> *push() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 相当于生成或持有 NSAutoreleasePool 类对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="type">id</span> autorelease(<span class="type">id</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 相当于 NSAutoreleasePool 类的 addObject 类方法</span></span><br><span class="line">        AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的 AutoreleasePoolPage 实例；</span><br><span class="line">        autoreleasePoolPage-&gt;add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">id</span> *add(<span class="type">id</span> obj) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将对象追加到内部数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="type">void</span> *pop(<span class="type">void</span> *token)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 相当于废弃 NSAutoreleasePool 类对象</span></span><br><span class="line">        releaseAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> releaseAll() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用内部数组中对象的 release 实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> *objc_autoreleasePoolPush(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> objc_autoreleasePoolPop(<span class="type">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">id</span> *objc_autorelease(<span class="type">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于 objc_autoreleasePoolPush()</span></span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool=[[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="comment">// 等同于 objc_autorelease(obj)</span></span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 obic_autoreleasePoolPop(pool)</span></span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure><h2 id="AutoreleasePool-的底层实现"><a href="#AutoreleasePool-的底层实现" class="headerlink" title="AutoreleasePool 的底层实现"></a>AutoreleasePool 的底层实现</h2><ol><li>AutoreleasePool 是由一个个 AutoreleasePoolPage 组成的双向链表</li><li>AutoreleasePoolPage 内部维护一个栈；栈满的时候会新建一个 AutoreleasePoolPage 节点</li><li>AutoreleasePool Push 时会压入一个边界对象表示一个 AutoreleasePool 的开始，Pop 时会清理堆栈直到遇到一个边界对象；边界对象是界定 AutoreleasePool 的分割线</li></ol><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638c0ede96e603e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><h2 id="AutoreleasePool-与-RunLoop"><a href="#AutoreleasePool-与-RunLoop" class="headerlink" title="AutoreleasePool 与 RunLoop"></a>AutoreleasePool 与 RunLoop</h2><p>App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，区别是优先级不同</p><p>第一个 Observer 优先级最高，保证创建释放池发生在其他所有回调之前，监视了一个事件：</p><ul><li>Entry（即将进入 Loop），其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。</li></ul><p>第二个 Observer 优先级最低，保证其释放池子发生在其他所有回调之后，监视了两个事件：</p><ul><li>BeforeWaiting（准备进入休眠）时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；</li><li>Exit(即将退出 Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。</li></ul><p>在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/5b052282f265da0b7156a2aa">AutoreleasePool 底层实现原理</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;autorelease-的伪代码实现&quot;&gt;&lt;a href=&quot;#autorelease-的伪代码实现&quot; class=&quot;headerlink&quot; title=&quot;autorelease 的伪代码实现&quot;&gt;&lt;/a&gt;autorelease 的伪代码实现&lt;/h2&gt;&lt;figure c</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="内存管理" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dealloc%20%E6%8E%A2%E7%A9%B6/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dealloc%20%E6%8E%A2%E7%A9%B6/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>dealloc 是在最后一次 release 执行后调用</li><li>ARC 下，对象的实例变量的释放时机是：编译器在 NSObject 插入的 <code>.cxx_desctruct</code> 方法释放</li><li>ARC 下 <code>[super dealloc]</code> 方法是由编译器自动插入，所以不需要手动调用</li><li>dealloc 主要干三件事：<ol><li>释放对象的实例变量</li><li>释放对象的关联对象（即释放该类的分类里设置的关联属性）</li><li>将所有指向该对象的 weak 指针置为 nil</li></ol></li></ol><h2 id="源码探讨"><a href="#源码探讨" class="headerlink" title="源码探讨"></a>源码探讨</h2><p>通过 apple 的 runtime 源码，不难发现 NSObject 执行 dealloc 最后执行到 <code>objc_destructInstance</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        Class isa_gen = _object_getClass(obj);</span><br><span class="line">        <span class="type">class_t</span> *isa = <span class="built_in">newcls</span>(isa_gen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = <span class="built_in">hasCxxStructors</span>(isa);</span><br><span class="line">        <span class="type">bool</span> assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="built_in">object_cxxDestruct</span>(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UseGC) <span class="built_in">objc_clear_deallocating</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单明确的干了三件事：</p><ol><li><code>object_cxxDestruct</code>：strong 修饰的变量执行 objc_storeStrong(&amp;ivar, nil) release 对象，ivar 赋值 nil；weak 修饰的变量执行 objc_destroyWeak(&amp;ivar) -&gt; storeWeak(&amp;ivar, nil ) -&gt; weak_unregister_no_lock，将变量指向 nil，且删除变量对象的 weak 相关信息（referrers 移除 weak 地址）</li><li>执行 <code>_object_remove_assocations</code> 去除和这个对象 assocate 的对象（常用于 category 中添加带变量的属性）</li><li>执行 <code>objc_clear_deallocating</code>，清空引用计数表并清除弱引用表，将所有 weak 引用指 nil（这也就是 weak 变量能安全置空的所在）</li></ol><h2 id="面试题：引用计数减为-0-会立即释放吗"><a href="#面试题：引用计数减为-0-会立即释放吗" class="headerlink" title="面试题：引用计数减为 0 会立即释放吗"></a>面试题：引用计数减为 0 会立即释放吗</h2><p>答案：会。dealloc 是在最后一次 release 执行后调用</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC 下 dealloc 过程及.cxx_destruct 的探究</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;dealloc 是在最后一次 release 执行后调用&lt;/li&gt;
&lt;li&gt;ARC 下，对象的实例变量的释放时机是：编译器在 N</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="内存管理" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/KVC/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/KVC/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>KVC 是 Key-Value Coding 的缩写，让开发者可以通过 Key 直接访问或设置对象的属性/成员变量，而不需要调用存取方法</li><li>KVC 可以直接获取、修改类不想暴露的私有变量，所以会破坏面向对象的编程思想</li><li>UITextView 设置 <code>_placeholderLabel</code> 可用到</li></ul><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;                          <span class="comment">// 直接通过 Key 来取值</span></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;          <span class="comment">// 通过 Key 来设值</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;                  <span class="comment">// 通过 KeyPath 来取值</span></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;  <span class="comment">// 通过 KeyPath 来设值</span></span><br></pre></td></tr></table></figure><p>通过 Key 来访问直接的属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// age 是 b 的属性</span></span><br><span class="line">[b setValue:@<span class="number">23</span> forKey:<span class="string">@&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure><p>通过 KeyPath 来访问属性的属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b 是 a 的一个属性</span></span><br><span class="line">[a setValue:@<span class="number">23</span> forKeyPath:<span class="string">@&quot;b.age&quot;</span>];</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="KVC-setter-的查找过程"><a href="#KVC-setter-的查找过程" class="headerlink" title="KVC setter 的查找过程"></a>KVC setter 的查找过程</h3><p>以 <code>[b setValue:@23 forKey:@&quot;age&quot;];</code> 举例</p><ol><li>查找 B 中的 <code>setAge:</code>、<code>_setAge:</code> 方法；找到则调用，结束</li><li>查看 B 的 <code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回值，若为 NO 则调用 B 的 <code>setValue:forUndefinedKey:</code> 并抛异常，结束（默认值为 YES）</li><li>查找 B 中的 <code>_age</code>、<code>_isAge</code>、<code>age</code>、<code>isAge</code>，找到则直接访问；否则调用 B 的 <code>setValue:forUndefinedKey:</code> 并抛异常</li></ol><h3 id="KVC-getter-的查找过程"><a href="#KVC-getter-的查找过程" class="headerlink" title="KVC getter 的查找过程"></a>KVC getter 的查找过程</h3><p>以 <code>[b valueForKey:@&quot;age&quot;];</code> 举例</p><ol><li>查找 B 中的 <code>getAge</code>、<code>age</code>、<code>isAge</code>、<code>_getAge</code>、<code>_age</code>、<code>_isAge</code> 方法；找到则调用，结束</li><li>查找一些集合类的特有方法，比如 count/sum/average 等，这里不展开</li><li>查看 B 的 <code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回值，若为 NO 则调用 B 的 <code>valueForUndefinedKey:</code> 并抛异常，结束（默认值为 YES）</li><li>查找 B 中的 <code>_age</code>、<code>_isAge</code>、<code>age</code>、<code>isAge</code>，找到则直接访问；否则调用 B 的 <code>valueForUndefinedKey:</code> 并抛异常</li></ol><blockquote><p>accessInstanceVariablesDirectly 方法，顾名思义，是否允许直接访问成员变量，默认 YES</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;KVC 是 Key-Value Coding 的缩写，让开发者可以通过 Key 直接访问或设置对象的属性/成员变</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/KVO/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/KVO/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>KVO 是 Key-Value Observing 的缩写，用于监听对象的某一属性改变</li><li>KVO 是 Objective-C 对观察者模式的实现</li></ul><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><a href="https://www.cnblogs.com/chenyg32/p/4808246.html">我的博客园</a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>KVO 是使用 isa 混写技术（isa-swizzing）实现</p><p>当一个对象使用了 KVO 监听，iOS 系统会修改这个对象的 isa 指针，使其指向通过 Runtime 动态创建的子类，该子类重写了 set 方法，内部实现会调用 willChangeValueForKey、父类的 setter、didChangeValueForKey。在 didChangeValueForKey 方法中又会调用监听器的监听方法</p><p>原理如图所示</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2149899/94pqoq2lrt.png" alt><br><img src="https://ask.qcloudimg.com/http-save/yehe-2149899/dl4xa5lq3k.png" alt></p><p>重点如下：</p><ol><li><p>动态创建了子类（修改了 isa 指针的指向）</p><blockquote><p>RuntimeAPI : objc_allocateClassPair 和 objc_registerClassPair，动态生成 NSKVONotifying_XXX</p></blockquote></li><li><p>重写了 setter 方法</p><ol><li>调用 willChangeValueForKey</li><li>调用 super 的 setter</li><li>调用 didChangeValueForKey</li><li>didChangeValueForKey 中调用 observeValueForKeyPath:ofObject:change:context:</li></ol></li></ol><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><h3 id="1-什么是-isa-混写-KVO-的实现原理"><a href="#1-什么是-isa-混写-KVO-的实现原理" class="headerlink" title="1. 什么是 isa 混写 / KVO 的实现原理"></a>1. 什么是 isa 混写 / KVO 的实现原理</h3><p>见上节</p><h3 id="2-如何手动触发-KVO"><a href="#2-如何手动触发-KVO" class="headerlink" title="2. 如何手动触发 KVO"></a>2. 如何手动触发 KVO</h3><p>手动调用 willChangeValueForKey 和 didChangeValueForKey，缺一不可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">[p addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">[p willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">[p didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="3-直接修改成员变量会触发-KVO-吗"><a href="#3-直接修改成员变量会触发-KVO-吗" class="headerlink" title="3. 直接修改成员变量会触发 KVO 吗"></a>3. 直接修改成员变量会触发 KVO 吗</h3><p>比如 <code>_age = 20</code> 这样的调用不会触发 KVO，因为没有调用 setter 方法</p><h3 id="4-KVC-会触发-KVO-吗"><a href="#4-KVC-会触发-KVO-吗" class="headerlink" title="4. KVC 会触发 KVO 吗"></a>4. KVC 会触发 KVO 吗</h3><p>KVC 访问属性既可以通过 setter，也可能通过直接访问成员变量（<code>+ (BOOL)accessInstanceVariablesDirectly</code> 返回 NO 的时候就不会触访问成员变量）；会不会触发 KVO 本质上是取决于会不会触发 setter 函数</p><h2 id="细节探究"><a href="#细节探究" class="headerlink" title="细节探究"></a>细节探究</h2><h3 id="创建的子类的伪代码实现"><a href="#创建的子类的伪代码实现" class="headerlink" title="创建的子类的伪代码实现"></a>创建的子类的伪代码实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSKVONotifying_Person</span></span></span><br><span class="line">- (Class)<span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Person <span class="keyword">class</span>];  <span class="comment">// 而不是 return object_getClassName(self);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="built_in">NSInteger</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    _NSSetLongLongValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _NSSetLongLongValueAndNotify()</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">    [<span class="variable language_">super</span> setAge:age];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    [oberser observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="动态创建子类以及重写-class-方法的代码验证"><a href="#动态创建子类以及重写-class-方法的代码验证" class="headerlink" title="动态创建子类以及重写 class 方法的代码验证"></a>动态创建子类以及重写 class 方法的代码验证</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;添加监听之前 %@, %@&quot;</span>, object_getClass(p), [p <span class="keyword">class</span>]);</span><br><span class="line">[p addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;添加监听之后 %@, %@&quot;</span>, object_getClass(p), [p <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加监听之前 Person, Person</span><br><span class="line">添加监听之后 NSKVONotifying_Person, Person</span><br></pre></td></tr></table></figure><ol><li>可以看到 p 的 isa 指针已经被改变了，指向了一个 <code>NSKVONotifying_</code> 开头的类，该类是动态生成的。</li><li>尽管如此，p 的 class 函数还是返回了用户的类，实际上是苹果重写了该方法，目的是不想让这个内部细节暴露给开发者；不重写的话，使用 <code>[person class]</code> 就会返回 <code>NSKVONotifying_Person</code>，这是苹果所不希望看到的，注意，class 方法的默认实现如下</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (Class)<span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);   <span class="comment">// 将会返回 isa 指针的实际指向，即 NSKVONotifying_Person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写子类-set-方法的代码验证"><a href="#重写子类-set-方法的代码验证" class="headerlink" title="重写子类 set 方法的代码验证"></a>重写子类 set 方法的代码验证</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;添加监听之前的方法地址：%p&quot;</span>, [p methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line">[p addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;添加监听之后的方法地址：%p&quot;</span>, [p methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure><p>输出如下，可以使用 p 命令将地址强制转为函数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加监听之前的方法地址：0x10c9f0bc0</span><br><span class="line">添加监听之后的方法地址：0x7fff257228bc</span><br><span class="line"></span><br><span class="line">(lldb) p (IMP)0x10c9f0bc0</span><br><span class="line">(IMP) <span class="variable">$0</span> = 0x000000010c9f0bc0 (ForTest`-[Person setAge:] at Person.h:14)</span><br><span class="line">(lldb) p (IMP)0x7fff257228bc</span><br><span class="line">(IMP) <span class="variable">$1</span> = 0x00007fff257228bc (Foundation`_NSSetLongLongValueAndNotify)</span><br></pre></td></tr></table></figure><p>因为 age 是 NSInteger，所以调用了 <code>_NSSetLongLongValueAndNotify</code>，如果是其他数据类型就会调用对应的方法</p><p>使用以下命令可以查看 Foundation 中包含 ValueAndNotify 的方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">000000000015ca93 t __NSSetBoolValueAndNotify</span><br><span class="line">00000000000553ab t __NSSetCharValueAndNotify</span><br><span class="line">00000000000c6bfb t __NSSetDoubleValueAndNotify</span><br><span class="line">0000000000101f6a t __NSSetFloatValueAndNotify</span><br><span class="line">00000000001321e9 t __NSSetIntValueAndNotify</span><br><span class="line">0000000000052c7b t __NSSetLongLongValueAndNotify</span><br><span class="line">00000000001c02c7 t __NSSetLongValueAndNotify</span><br><span class="line">0000000000070df9 t __NSSetObjectValueAndNotify</span><br><span class="line">00000000000cc7f1 t __NSSetPointValueAndNotify</span><br><span class="line">00000000001c07be t __NSSetRangeValueAndNotify</span><br><span class="line">0000000000092242 t __NSSetRectValueAndNotify</span><br><span class="line">00000000001c053f t __NSSetShortValueAndNotify</span><br><span class="line">00000000000cc624 t __NSSetSizeValueAndNotify</span><br><span class="line">00000000001c0183 t __NSSetUnsignedCharValueAndNotify</span><br><span class="line">00000000000d4d60 t __NSSetUnsignedIntValueAndNotify</span><br><span class="line">000000000008cd85 t __NSSetUnsignedLongLongValueAndNotify</span><br><span class="line">00000000001c0401 t __NSSetUnsignedLongValueAndNotify</span><br><span class="line">00000000001c0678 t __NSSetUnsignedShortValueAndNotify</span><br><span class="line">00000000001bf600 t __NSSetValueAndNotifyForKeyInIvar</span><br><span class="line">00000000001bf662 t __NSSetValueAndNotifyForUndefinedKey</span><br><span class="line">00000000001c091e t ____NSSetBoolValueAndNotify_block_invoke</span><br><span class="line">00000000000554eb t ____NSSetCharValueAndNotify_block_invoke</span><br><span class="line">00000000000c6d45 t ____NSSetDoubleValueAndNotify_block_invoke</span><br><span class="line">00000000001020b3 t ____NSSetFloatValueAndNotify_block_invoke</span><br><span class="line">0000000000136a41 t ____NSSetIntValueAndNotify_block_invoke</span><br><span class="line">0000000000052e23 t ____NSSetLongLongValueAndNotify_block_invoke</span><br><span class="line">00000000001c0989 t ____NSSetLongValueAndNotify_block_invoke</span><br><span class="line">0000000000091811 t ____NSSetObjectValueAndNotify_block_invoke</span><br><span class="line">0000000000125637 t ____NSSetPointValueAndNotify_block_invoke</span><br><span class="line">00000000001c0a4a t ____NSSetRangeValueAndNotify_block_invoke</span><br><span class="line">00000000000923db t ____NSSetRectValueAndNotify_block_invoke</span><br><span class="line">00000000001c09ed t ____NSSetShortValueAndNotify_block_invoke</span><br><span class="line">0000000000122c1a t ____NSSetSizeValueAndNotify_block_invoke</span><br><span class="line">00000000001c0958 t ____NSSetUnsignedCharValueAndNotify_block_invoke</span><br><span class="line">00000000000d4e9d t ____NSSetUnsignedIntValueAndNotify_block_invoke</span><br><span class="line">00000000000ab280 t ____NSSetUnsignedLongLongValueAndNotify_block_invoke</span><br><span class="line">00000000001c09b6 t ____NSSetUnsignedLongValueAndNotify_block_invoke</span><br><span class="line">00000000001c0a1a t ____NSSetUnsignedShortValueAndNotify_block_invoke</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cloud.tencent.com/developer/article/1403599">面试驱动技术 - KVO &amp;&amp; KVC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;KVO 是 Key-Value Observing 的缩写，用于监听对象的某一属性改变&lt;/li&gt;
&lt;li&gt;KVO</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/NSString%20%E7%9A%84%E5%9D%91/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/NSString%20%E7%9A%84%E5%9D%91/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSCFConstantString"><a href="#NSCFConstantString" class="headerlink" title="__NSCFConstantString"></a><code>__NSCFConstantString</code></h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@&quot;ab&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p isa: %@&quot;</span>, str1, [str1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str2 = str1;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p isa: %@&quot;</span>, str2, [str2 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str3 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@&quot;ab&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p isa: %@&quot;</span>, str3, [str3 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ab&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p isa: %@&quot;</span>, str4, [str4 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x1097013f8 isa: __NSCFConstantString</span><br><span class="line">0x1097013f8 isa: __NSCFConstantString</span><br><span class="line">0x1097013f8 isa: __NSCFConstantString</span><br><span class="line">0xaeadd56e72cd6d4d isa: NSTaggedPointerString</span><br></pre></td></tr></table></figure><p>其中 str1/str2/str3 的指向的内容地址相同，类都是 <code>__NSCFConstantString</code></p><p>这是字符串常量，编译时分配内存，存储在常量区，引用计数是不会变的</p><p>而 str4 是一个 <code>__NSTaggedPointerString</code></p><h2 id="NSTaggedPointerString"><a href="#NSTaggedPointerString" class="headerlink" title="__NSTaggedPointerString"></a><code>__NSTaggedPointerString</code></h2><p>这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。</p><p>64 位环境下指针变量长达 8 位，苹果把指针指向的内容直接放在了指针变量的内存地址中</p><p>这种指针不通过解引用 isa 来获取其所属类（通过其地址的部分保留字段），因此可以当作一种伪对象</p><p>这是一个单例常量，不会被释放。</p><p>对于 NSString 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 NSTaggedPointerString 类型</p><p>如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 <code>__NSCFString</code> 类型</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str5 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdedfgh&quot;</span>];  <span class="comment">// 长度&lt;=9</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p isa: %@&quot;</span>, str5, [str5 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str6 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdedfghi&quot;</span>]; <span class="comment">// 长度&gt;9</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p isa: %@&quot;</span>, str6, [str6 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *str7 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;你&quot;</span>];          <span class="comment">// 非 ASCII</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p isa: %@&quot;</span>, str7, [str7 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x8166d7f2baa92699 isa: NSTaggedPointerString</span><br><span class="line">0x600002be0240 isa: __NSCFString</span><br><span class="line">0x600002e128c0 isa: __NSCFString</span><br></pre></td></tr></table></figure><h2 id="NSString-与引用计数"><a href="#NSString-与引用计数" class="headerlink" title="NSString 与引用计数"></a>NSString 与引用计数</h2><ul><li><code>__NSCFConstantString</code> 的引用计数无限大</li><li><code>__NSTaggedPointerString</code> 的引用计数无限大</li><li><code>__NSCFString</code> 的引用计数正常，对一个 <code>__NSCFString</code> 进行 copy 操作会使得该对象的引用计数 +1</li></ul><blockquote><p>可以通过 <code>po @(CFGetRetainCount((__bridge CFTypeRef)(s)))</code> 查看其引用计数</p></blockquote><h3 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *str;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdedfghi&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能挂在这里</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0  0x00007fff51a9033a in __pthread_kill ()</span></span><br><span class="line"><span class="comment">#1  0x00007fff51b3ae60 in pthread_kill ()</span></span><br><span class="line"><span class="comment">#2  0x00007fff51a1fb7c in abort ()</span></span><br><span class="line"><span class="comment">#3  0x00007fff51b1ba63 in malloc_vreport ()</span></span><br><span class="line"><span class="comment">#4  0x00007fff51b1bde6 in malloc_zone_error ()</span></span><br><span class="line"><span class="comment">#5  0x00007fff23d9f945 in _CFRelease ()</span></span><br><span class="line"><span class="comment">#6  0x000000010dcd4e0f in -[ViewController setStr:]</span></span><br></pre></td></tr></table></figure><p>原因是多个线程调用 string 的 setter 时，当 <code>_str</code> 引用计数为 1 时，release 被调用了，过度释放造成 crash</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setStr:(<span class="built_in">NSString</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_str != str)</span><br><span class="line">    &#123;</span><br><span class="line">        [_str release]; <span class="comment">// arc 自动加上</span></span><br><span class="line">        _str = [str <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改为 <code>self.str = [NSString stringWithFormat:@&quot;abcdedfgh&quot;];</code> 就不会挂了，因为 <code>__NSTaggedPointerString</code> 的引用计数无限大，多次 release 也没事</li><li>同理，改为 <code>self.str = @&quot;abcdedfgh&quot;</code> 也不会挂，因为 <code>__NSCFConstantString</code> 的引用计数无限大</li><li>改为 atomic 也可以防止 crash</li></ul><p>另外在 autoreleasepool pop 的时候也会调用 release，也可能会挂，堆栈如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0  0x00007fff50aed94b in objc_release ()</span></span><br><span class="line"><span class="comment">#1  0x00007fff50aef077 in AutoreleasePoolPage::releaseUntil(objc_object**) ()</span></span><br><span class="line"><span class="comment">#2  0x00007fff50aeef96 in objc_autoreleasePoolPop ()</span></span><br><span class="line"><span class="comment">#3  0x0000000101ed1e77 in _dispatch_last_resort_autorelease_pool_pop ()</span></span><br><span class="line"><span class="comment">#4  0x0000000101ee3825 in _dispatch_root_queue_drain ()</span></span><br><span class="line"><span class="comment">#5  0x0000000101ee3ca6 in _dispatch_worker_thread2 ()</span></span><br><span class="line"><span class="comment">#6  0x00007fff51b379f7 in _pthread_wqthread ()</span></span><br><span class="line"><span class="comment">#7  0x00007fff51b36b77 in start_wqthread ()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NSCFConstantString&quot;&gt;&lt;a href=&quot;#NSCFConstantString&quot; class=&quot;headerlink&quot; title=&quot;__NSCFConstantString&quot;&gt;&lt;/a&gt;&lt;code&gt;__NSCFConstantString&lt;/co</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/Native%20%E4%B8%8E%20JS%20%E4%BA%A4%E4%BA%92/"/>
    <id>https://norcy.github.io/wiki/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/Native%20%E4%B8%8E%20JS%20%E4%BA%A4%E4%BA%92/</id>
    <published>2025-04-20T05:50:42.955Z</published>
    <updated>2025-04-20T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIWebView-WKWebView-拦截请求"><a href="#UIWebView-WKWebView-拦截请求" class="headerlink" title="UIWebView/WKWebView 拦截请求"></a>UIWebView/WKWebView 拦截请求</h2><ol><li>Native 调用 JS</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[webView stringByEvaluatingJavaScriptFromString:<span class="string">@&quot;Math.random();&quot;</span>];</span><br></pre></td></tr></table></figure><ol start="2"><li>JS 调用 Native<br>Native 拦截 UIWebView 的所有请求，判断 Scheme，如果是约定好的 Schema 就拦截请求、解析参数并调用 Native 相应的逻辑</li></ol><p>JS 发起请求有两种方式：1. 通过 localtion.href；2. 通过 iframe 方式</p><p>前者如果短时间内连续多次修改 localtion.href 的值，Native 只会收到最后一次请求，因此 JS 侧采用 iframe 的方式发起请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;jsbridge://doAction?title=标题&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">iframe.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">iframe.<span class="property">src</span> = url;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    iframe.<span class="title function_">remove</span>();</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.URL 是自定义的 Schema)</span><br><span class="line">    &#123;</span><br><span class="line">        解析 URL 的参数</span><br><span class="line">        处理函数</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;  <span class="comment">// 不发起请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">// 正常发起请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：不需要等到整个 HTML 页面加载完成就能调用 Native？</li><li>缺点：需要繁琐地解释字符串得到相应的方法名和传值，且调用的方法也不能传递返回值；</li></ul><h2 id="UIWebView-获取-JSContext"><a href="#UIWebView-获取-JSContext" class="headerlink" title="UIWebView 获取 JSContext"></a>UIWebView 获取 JSContext</h2><p>在 webViewDidFinishLoad 通过 KVC 的方法获取 JSContext</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.jsContext = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.jsContext[<span class="string">@&quot;NativeBridge&quot;</span>] = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">        context.exception = exceptionValue;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;异常信息：%@&quot;</span>, exceptionValue);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSContext 属于 JSCore，见下节</p><ul><li>优点：需要等到整个 HTML 页面加载完成才能调用 JS？</li><li>缺点：WKWebView 无法使用 JSCore</li></ul><h2 id="WKWebView-使用-userContentController"><a href="#WKWebView-使用-userContentController" class="headerlink" title="WKWebView 使用 userContentController"></a>WKWebView 使用 userContentController</h2><p>WKWebView 无法使用 JSCore</p><ol><li>Native 调用 JS</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">WKUserContentController</span> *userContentController;</span><br></pre></td></tr></table></figure><p>Native 和 H5 交互基本全靠这个对象， 在 WKWebVeiw 中，我们使用我们有两种方式来调用 JS，</p><ul><li>使用 WKUserScript</li><li>直接调用 JS 字符串</li></ul><p>1.1 使用 WKUserScript</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source 就是我们要调用的 JS 函数或者我们要执行的 JS 代码</span></span><br><span class="line"><span class="comment">// injectionTime 这个参数我们需要指定一个时间，在什么时候把我们在这段 JS 注入到 WebVeiw 中，它是一个枚举值，WKUserScriptInjectionTimeAtDocumentStart 或者 WKUserScriptInjectionTimeAtDocumentEnd</span></span><br><span class="line"><span class="comment">// MainFrameOnly 因为在 JS 中，一个页面可能有多个 frame，这个参数指定我们的 JS 代码是否只在 mainFrame 中生效</span></span><br><span class="line">- initWithSource:injectionTime:forMainFrameOnly:</span><br></pre></td></tr></table></figure><p>至此，我们已经构建了一个 WKUserScript，然后呢，我们要做的就是要把它添加进来</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- addUserScript:</span><br></pre></td></tr></table></figure><p>至此使用 WKUserScript 调用 JS 完成</p><p>1.2 直接调用 JS 字符串</p><p>在 WKWebView 中，我们也可以直接执行 JS 字符串</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)evaluateJavaScript:completionHandler:</span><br></pre></td></tr></table></figure><p>我们通过调用这个方法来执行 JS 字符串，然后在 completionHandler 中拿到执行这段 JS 代码后的返回值。</p><p>至此，Native 调用 JS 完成</p><ol start="2"><li>JS 调用 Native</li></ol><p>2.1 向 JS 注入一个字符串</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_webView.configuration.userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@&quot;nativeMethod&quot;</span>];</span><br></pre></td></tr></table></figure><p>我们向 JS 注入了一个方法，叫做 nativeMethod</p><p>2.2 JS 调用 Native</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span>.<span class="property">nativeMethod</span>.<span class="title function_">postMessage</span>(value);</span><br></pre></td></tr></table></figure><p>一句话调用，我们就可以在 Native 中接收到 value</p><p>2.3 接收 JS 调用</p><p>上边我们调用 addScriptMessageHandler:name 的时候，我们要遵守 WKScriptMessageHandler 协议，然后实现这个协议。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * name = message.name  <span class="comment">// 就是上边注入到 JS 的哪个名字，在这里是 nativeMethod</span></span><br><span class="line">    <span class="type">id</span> param = message.body         <span class="comment">// 就是 JS 调用 Native 时，传过来的 value</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> do your stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完了，Native 调用 JS 就这么简单</p><p>优点：简单易用<br>缺点：JS 调用 Native 后回调较难，见 <a href="https://juejin.im/entry/59f6e836f265da431a427a57">https://juejin.im/entry/59f6e836f265da431a427a57</a></p><h2 id="JSCore"><a href="#JSCore" class="headerlink" title="JSCore"></a>JSCore</h2><ol><li>Native 调用 JS</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line"><span class="built_in">NSString</span> *js = <span class="string">@&quot;function add(a,b) &#123;return a+b&#125;&quot;</span>;</span><br><span class="line">[context evaluateScript:js];    <span class="comment">// 注入 JS 函数</span></span><br><span class="line">[context[<span class="string">@&quot;add&quot;</span>] callWithArguments:@[<span class="string">@&quot;2&quot;</span>, <span class="string">@&quot;3&quot;</span>]];</span><br><span class="line"><span class="comment">//[mJsValue invokeMethod:@&quot;printHello&quot; withArguments:@[@&quot;1&quot;]];</span></span><br></pre></td></tr></table></figure><ol start="2"><li>JS 调用 Native</li></ol><p>借助 JSCore，我们并不一定要写 JS，可以直接使用 JSCore 模拟 JS 调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">[context evaluateScript:<span class="string">@&quot;var a = 1;var b = 2;&quot;</span>];</span><br><span class="line">JSValue *ret = [context evaluateScript:<span class="string">@&quot;a + b&quot;</span>];</span><br><span class="line"><span class="built_in">NSInteger</span> sum = [ret toInt32]; <span class="comment">// sum=3</span></span><br></pre></td></tr></table></figure><p>Native 注入函数到 JS</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">context[<span class="string">@&quot;NativeBridge&quot;</span>] = [QLJSInterface new];</span><br></pre></td></tr></table></figure><p>Native 实现 JSExport</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">QLJSProtocol</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line">JSExportAs(open, - (<span class="type">void</span>)open:(<span class="built_in">NSString</span> *)url);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QLJSInterface</span> : <span class="title">NSObject</span>&lt;<span class="title">QLJSProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QLKTH5Interface</span></span></span><br><span class="line">- (<span class="type">void</span>)open:(<span class="built_in">NSString</span> *)url</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;URL is %@&quot;</span>: url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>JS 调用 Native，可以使用 JSCore 模拟，也可以在 JS 侧调用（需要把 JS 文件注入到 JSContext）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">context[<span class="string">@&quot;NativeBridge&quot;</span>] = [QLJSInterface new];</span><br><span class="line">[context evaluateScript:<span class="string">@&quot;NativeBridge.open(&#x27;HomePage&#x27;)&quot;</span>];</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">NativeBridge</span>.<span class="title function_">open</span>(<span class="string">&#x27;HomePage&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：不依赖 WebView</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UIWebView-WKWebView-拦截请求&quot;&gt;&lt;a href=&quot;#UIWebView-WKWebView-拦截请求&quot; class=&quot;headerlink&quot; title=&quot;UIWebView/WKWebView 拦截请求&quot;&gt;&lt;/a&gt;UIWebView/WKWe</summary>
      
    
    
    
    <category term="tech" scheme="https://norcy.github.io/wiki/categories/tech/"/>
    
    <category term="iOS" scheme="https://norcy.github.io/wiki/categories/tech/iOS/"/>
    
    <category term="未分类" scheme="https://norcy.github.io/wiki/categories/tech/iOS/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
