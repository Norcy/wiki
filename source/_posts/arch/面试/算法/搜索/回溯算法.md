## 回溯算法的框架
解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

代码方面，回溯算法的框架：

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。

## 全排列问题
[Leetcode：46.全排列](https://leetcode-cn.com/problems/permutations/)

```cpp
vector<vector<int>> ret;

void backtrack(vector<int> &path, vector<int> &nums)
{
    // 满足结束条件
    if (path.size() == nums.size())
    {
        ret.push_back(path);
        return;
    }

    for (int num : nums)
    {
        // 排除不合法的选择
        // 这一步可以优化为 swap，但是理解起来比较复杂
        if (find(path.begin(), path.end(), num) != path.end())
        {
            continue;
        }
        // 做选择
        path.push_back(num);
        // 递归
        backtrack(path, nums);
        // 撤销选择
        path.pop_back();
    }
}

vector<vector<int>> permute(vector<int>& nums) 
{
    vector<int> path;
    backtrack(path, nums);
    return ret;
}
```

## N 皇后问题
[N 皇后](https://leetcode-cn.com/problems/n-queens/)

```cpp
vector<vector<string>> res;

/* 输入棋盘边长 n，返回所有合法的放置 */
vector<vector<string>> solveNQueens(int n) {
    // '.' 表示空，'Q' 表示皇后，初始化空棋盘。
    vector<string> board(n, string(n, '.'));
    backtrack(board, 0);
    return res;
}

// 路径：board 中小于 row 的那些行都已经成功放置了皇后
// 选择列表：第 row 行的所有列都是放置皇后的选择
// 结束条件：row 超过 board 的最后一行
void backtrack(vector<string>& board, int row) {
    // 触发结束条件
    if (row == board.size()) 
    {
        res.push_back(board);
        return;
    }
    
    for (int col = 0; col < board[row].size(); col++) 
    {
        // 排除不合法选择
        if (!isValid(board, row, col)) 
            continue;
        // 做选择
        board[row][col] = 'Q';
        // 进入下一行决策
        backtrack(board, row + 1);
        // 撤销选择
        board[row][col] = '.';
    }
}

bool isValid(vector<string>& board, int row, int col)
{
    int n = board.size();
    // 检查【列】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后）
    for (int i = 0; i <= row; i++) {
        if (board[i][col] == 'Q')
            return false;
    }

    // 检查【右上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后）
    for (int i = row - 1, j = col + 1; 
            i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q')
            return false;
    }

    // 检查【左上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后）
    for (int i = row - 1, j = col - 1;
            i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q')
            return false;
    }
    return true;
}
```

## 字母大小全排列
[784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation)

```cpp
vector<string> ret;

void backtrack(string path, string S)
{
    if (path.size() == S.size())
    {
        ret.push_back(path);
        return;
    }

    char c = S[path.size()];
    path += c;
    backtrack(path, S);
    // 字母需要回溯，数字不需要
    if (isalpha(c))
    {
        // 回退再选择一次
        path = path.substr(0, path.size()-1);
        // 大写转小写；小写转大写
        if (c >= 'A' && c <= 'Z')
        {
            path += tolower(c);
        }
        else    
        {
            path += toupper(c);
        }
        backtrack(path, S);
    }
}

vector<string> letterCasePermutation(string S) 
{
    ret = {};
    if (S.size() == 0) return ret;

    string path;
    backtrack(path, S);
    return ret;
}

```

## 参考
+ [回溯算法详解](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/)