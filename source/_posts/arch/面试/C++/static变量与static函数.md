今天遇到一个 crash，追溯到最后竟然是因为在两个 .cpp 文件中声明了2个相同名称的全局变量，改用 staitc 修饰它们为静态全局变量就解决问题

```cpp
pair<string, VN_CSS_TYPE_ALIAS_PAESER> pairArray[] = {
    make_pair("src", VN_RICH_CSS_VIDEO_SRC_ALIAS_PARSER)
};

ClassA::fun()
{
}
```

改为

```cpp
static pair<string, VN_CSS_TYPE_ALIAS_PAESER> pairArray[] = {
    make_pair("src", VN_RICH_CSS_VIDEO_SRC_ALIAS_PARSER)
};

ClassA::fun()
{
}
```



## static 变量的特征：

1. static 变量被放在程序的全局存储区中，这样在下一次调用的时候还可以保持原来的赋值

2. static 变量仅在其作用范围内可见。这一点是它与全局变量的区别。

## Tips:

1. 若全局变量仅在单个文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；

2. 若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；

3. 函数前加 static 使得函数成为静态函数。是指对函数的作用域仅局限于本文件(所以又称内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名

## 全局变量、静态全局变量、静态局部变量和局部变量的区别
变量可以分为

+ 全局变量（外部变量）
+ 静态全局变量
+ 静态局部变量
+ 局部变量

按存储区域分，全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。

按作用域分，全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，并且程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效

全局变量前再冠以 static 就构成了静态全局变量。

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数用，因此可以避免在其它源文件中引起错误

从以上分析可以看出，把局部变量改变为静态局部变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态全局变量后是改变了它的作用域，限制了它的使用范围

全局变量、静态局部变量和静态全局变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知
