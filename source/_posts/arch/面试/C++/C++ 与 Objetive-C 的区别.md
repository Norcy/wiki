## 重载
在 C++ 中，重载指的是函数名相同，但是参数类型或参数个数不同的函数；而在 OC 中是不支持重载的

+ C++ 区别函数是通过函数签名，函数签名包括函数名、参数类型和参数个数（注意没有返回值，因为只有返回值不同的函数编译器是无法确定应该调用哪个函数）
+ OC 中 Method 的 key 是 Selector，这个只有方法名，不含参数类型和参数个数，因此无法支持重载

## 多态（重写）
+ C++：子类的函数覆盖了父类的 virtual 同名函数；通过虚函数表、虚函数指针来实现，子类和父类有不同的虚函数表。单纯创建一个子类对象时，其类的内存布局是子类的，虚函数指针会指向子类虚函数表；而创建一个父类指针指向的子类对象时，其类的内存布局是父类的，其虚函数指针会指向子类的虚函数表
+ OC：`objc_msgSend` 过程中通过 isa 指针找到对应的类对象/元类对象，查找其方法列表，如果找不到则往继承链向上找

如果真的要联系对比，那么 C++ 中父类的虚函数表就好比 OC 中父类类对象的方法列表，表明其内存结构；而 C++ 中的虚函数指针就好比 OC 中的 isa 指针，表明真正指向的类

延伸阅读 [C++多态](../C++多态/)

## 重定义
+ C++：子类的函数覆盖了父类的非 virtual 函数；此时子类的函数中将会屏蔽父类的同名函数
+ OC：同多态小节，OC 中的重写和重定义本质上都是消息发送，都是通过 isa 指针查找方法

在 C++ 中，区分重写和重定义的关键是看父类同名函数是否声明了 virtual，而由于在 OC 中没有 virtual 关键字，因此 OC 中没有重写和重定义的概念，只有在消息发送的时候利用 isa 指针去查找类/元类的方法列表

## 多重继承
+ C++ 支持多继承
+ OC 不支持多重继承，可以实现多个协议来完成多重继承的效果

## 虚基类
+ C++ 中的虚基类是为了消除多重继承时的歧义 [C++虚继承和虚基类](http://c.biancheng.net/cpp/biancheng/view/238.html)
+ OC 没有虚基类，因为不需要