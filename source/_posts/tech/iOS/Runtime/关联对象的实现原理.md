## 提问
+ 关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？
+ 为什么 AssociationsHashMap 是使用 `unordered_map`，而 ObjectAssociationMap 使用 `map`
+ 使用关联对象有什么需要注意的地方
+ 为什么内存管理策略中没有 weak 选项，即 `OBJC_ASSOCIATION_WEAK`


## 阅读本文的前提
```objc
objc_setAssociatedObject(self, @selector(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
```

其中 self 我们称之为**被关联对象**，proxy 我们称之为 **关联对象**


## 关键数据结构
**理解好以下几个结构之后，几乎不需要看源码就能推测 set/get 的原理**

### AssociationsManager
单例，全局唯一
### AssociationsHashMap
AssociationsManager 的属性，全局唯一

`std::unordered_map`，存放对象与 ObjectAssociationMap（这里的对象指的是添加属性的分类）

### ObjectAssociationMap
`std::map`，存放 key 与 ObjcAssociation

### ObjcAssociation
存放 value 和 policy


## 源码
```objc
void _object_set_associative_reference(id object, void *key, id value,
    uintptr_t policy)
{
    // 初始化一个旧值
    ObjcAssociation old_association(0, nil);

    // acquireValue 会对新的值进行 retain or copy，可以看下下面的源码
    id new_value = value ? acquireValue(value, policy) : nil;

    {
        // 全局单例
        AssociationsManager manager;
        // 全局的 unordered_map
        AssociationsHashMap &associations(manager.associations());
        // 将被关联对象转化一下，DISGUISE 仅仅对 object 做了位运算
        disguised_ptr_t disguised_object = DISGUISE(object);

        if (new_value)
        {
            // 新值不为空，则开始插入
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i != associations.end())
            {
                // 如果被关联对象已经在全局的 unordered_map 注册过，则找到对应的 map
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end())
                {
                    // map 找到了则记录旧值以备释放，并更新新值
                    old_association = j->second;
                    j->second = ObjcAssociation(policy, new_value);
                }
                else
                {
                    // map 找不到则直接插入
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            }
            else
            {
                // 如果被关联对象没有在全局的 unordered_map 注册过，则创建 map 并注册
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                // 将值插入到新的 map 中
                (*refs)[key] = ObjcAssociation(policy, new_value);
                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));
            }
        }
        else
        {
            // 新的值为空，准备删除旧值（如果有的话）
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i != associations.end())
            {
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end())
                {
                    // 记录旧值等待释放并从 map 中移除
                    old_association = j->second;
                    refs->erase(j);
                }
            }
        }
    }

    // 释放旧值（如果需要的话）
    if (old_association.hasValue())
        ReleaseValue()(old_association);
}
```

```cpp
static id acquireValue(id value, uintptr_t policy) 
{
    switch (policy & 0xFF) 
    {
        case OBJC_ASSOCIATION_SETTER_RETAIN:
            return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
        case OBJC_ASSOCIATION_SETTER_COPY:
            return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy);
    }
    return value;
}
```

```cpp
// DISGUISE 仅仅对 object 做了位运算
inline disguised_ptr_t DISGUISE(id value) { return ~uintptr_t(value); }
```

## 解答
+ 关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？

    关联对象并不是存放在被关联对象本身的内存中，而是存放在一个全局的 `unordered_map` 中

    其中 `unordered_map` 存储着被关联的对象与 `map`，其中 map 存放着关联对象的 key 和关联对象
    
    获取关联对象时，首先通过被关联对象的地址找到 `map`，然后通过关联对象的 key 找到关联对象并返回

+ 为什么 AssociationsHashMap 是使用 `unordered_map`，而 ObjectAssociationMap 使用 `map`

    `unordered_map` 查找更加高效，大多数情况下应该选择 `unordered_map`，而 ObjectAssociationMap 使用 `map` 应该是出于内存考虑

    详细可参考 [`unordered_map` 与 `map` 的区别](https://norcy.github.io/wiki/arch/面试/C++/unordered_map%20与%20map%20的区别)


+ 为什么内存管理策略中没有 weak 选项，即 `OBJC_ASSOCIATION_WEAK`

    可参考 [如何为分类添加属性](../如何为分类添加属性/)

+ 关联对象如果真的有需要使用 weak 的话，怎么办？

    可参考 [如何为分类添加属性](../如何为分类添加属性/)

    


## 更多阅读
+ [如何为分类添加属性](../如何为分类添加属性/)
+ [Objective-C Associated Objects 的实现原理](https://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/)
+ [源码](https://opensource.apple.com/source/objc4/objc4-532/runtime/objc-references.mm.auto.html)