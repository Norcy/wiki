## Runtime 原理
```objc
struct category_t { 
    const char *name;                           // 原类名，而不是分类名
    // 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象
    classref_t cls;                             
    struct method_list_t *instanceMethods;      // 分类中新增的对象方法列表
    struct method_list_t *classMethods;         // 分类中新增的类方法列表
    struct protocol_list_t *protocols;          // 分类中新增的协议列表
    struct property_list_t *instanceProperties; // 分类中新增的属性列表
};
```

可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，但不可以添加成员变量

instanceProperties 的存在是我们可以通过 `objc_setAssociatedObject` 和 `objc_getAssociatedObject` 向分类中增加实例变量的原因，不过这个和一般的实例变量是不一样的

所以，Category 可以使用 `@property`，但不会生成带下划线的成员变量，也不会生成 getter 和 setter（`@property` 只是帮助声明了 setter/getter，并没有提供实现）。我们可以使用 Runtime 为已有的类添加新的属性并生成 getter 和 setter 方法

## 语法
```objc
void objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy);

id objc_getAssociatedObject(id object, void *key);

void objc_removeAssociatedObject(id object);    // 移除 object 上的所有关联对象

```

参数说明

+ id object：被关联的对象（一般为 self）
+ const void `*key`：关联的key，要求唯一，因此避免使用 @""（一般为新增属性的 getter）
+ id value：关联的对象（一般为新增的属性）
+ objc_AssociationPolicy policy：内存管理的策略

### key
关联的 key 值有三种推荐值

1. 声明 `static char kAssociatedObjectKey;`，使用 &kAssociatedObjectKey 作为 key 值
2. 声明 `static void *kAssociatedObjectKey = &kAssociatedObjectKey;` ，使用 kAssociatedObjectKey 作为 key 值
3. 用 selector ，使用 getter 方法的名称作为 key 值（推荐）

设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。

所以 key 值最好定义为一个全局静态变量，而不能每次都用 @"xxx"

推荐使用 selector，因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性

### 内存管理策略
其中 objc_AssociationPolicy 是关联对象的属性，如下

```objc
OBJC_ASSOCIATION_ASSIGN             --- assign
OBJC_ASSOCIATION_RETAIN_NONATOMIC   --- nonatomic, retain
OBJC_ASSOCIATION_COPY_NONATOMIC     --- nonatomic, copy
OBJC_ASSOCIATION_RETAIN             --- retain(strong)
OBJC_ASSOCIATION_COPY               --- copy
```

## 例子
```objc
@interface UIView (VN_ShortCut)
@property (nonatomic, weak) UICollectionView *vn_cellCollectionView;
@end
```

```objc
@implementation UIView (VN_ShortCut)
- (UICollectionView *)vn_cellCollectionView 
{
    return objc_getAssociatedObject(self, @selector(vn_cellCollectionView));
}

- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView 
{
    objc_setAssociatedObject(self, @selector(vn_cellCollectionView), cellCollectionView, OBJC_ASSOCIATION_ASSIGN);
}
@end
```

## `OBJC_ASSOCIATION_ASSIGN` 可能引发 crash
注意 `OBJC_ASSOCIATION_ASSIGN` 的作用是 assign 而不是 weak，所以当关联的对象被释放的时候并不会被自动置为 nil，因此获取到的对象将会是一个野指针。

### 直观的方法 1
如果要实现 weak 的效果，解决方法是新建一个替身，weak 引用住该对象，然后使用 `OBJC_ASSOCIATION_RETAIN_NONATOMIC` 存储该替身。

以上面的例子为例，代码如下

```objc
- (UICollectionView *)vn_cellCollectionView
{
    QVNWeakProxy *proxy = objc_getAssociatedObject(self, @selector(vn_cellCollectionView));
    return (UICollectionView *)proxy.target;
}

- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView
{
    QVNWeakProxy *proxy = [[QVNWeakProxy alloc] initWithTarget:cellCollectionView];
    objc_setAssociatedObject(self, @selector(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
```

其中 QVNWeakProxy 只要继承自 NSObject 并实现 target 的存取方法即可

### 优雅的方法 2
变量用 `__weak` 修饰，因此被 block 捕获的时候不会增加引用计数；block 使用 copy 修饰，可以将栈 block 转为堆 block，防止被释放

```objc
- (UICollectionView *)vn_cellCollectionView
{
    id (^block)(void) = objc_getAssociatedObject(self, @selector(vn_cellCollectionView));
    return (block ? block() : nil);
}

- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView
{
    id __weak weakObject = cellCollectionView;
    id (^block)(void) = ^{return weakObject;};
    objc_setAssociatedObject(self, @selector(vn_cellCollectionView), block, OBJC_ASSOCIATION_COPY);
}
```


## 引申思考：为什么内存管理没有 weak 选项