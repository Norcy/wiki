# 区块链记账原理

## 哈希函数

1. 特点:
	+ 同样的原始信息用同一个哈希函数总能得到相同的摘要信息
	+ 原始信息任何微小的变化都会哈希出面目全非的摘要信息
	+ 从摘要信息无法逆向推算出原始信息

2. 作用：
	+ 简化信息：很好理解，哈希后的信息变短了。
	+ 标识信息：可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。
	+ 隐匿信息：账本是AC4635D34DEF这样一条记录，原始信息被隐匿。
	+ 验证信息：假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证原始信息

## 区块链记账方法
第一个区块：
	
	Hash(序号0、记账时间、交易记录) = 787635ACD

第二个区块：

	Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD


第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。即最新的区块总是间接包含了所有之前的账页信息。

所有这些区块组合起来就形成了一个总账本，叫做区块链，其特点是：

+ 便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本）
+ 不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）


# 比特币所有权及隐私问题-非对称加密应用

## 地址与私钥
交易信息：

```
{
    "付款地址"："2A39CBa2390FDe"
    "收款地址"："AAC9CBa239aFcc"
    "金额"："0.2btc"
}
```

比特币的账户是用地址来表示

谁拥有某个地址的私钥，谁就能用这个地址进行支付。

比特币地址和私钥是一个非对称的关系，私钥经过一序列运算（其中有两次Hash）之后，可以得到地址, 但是无法从地址反推得到私钥。

## 比特币交易过程

1. 发送方对交易信息进行签名

	1. 对交易进行hash，得到一个摘要信息（Hash值）

		```
		hash('
		    {"付款地址"："2A39CBa2390FDe",
		    "收款地址"："AAC9CBa239aFcc",
		    "金额"："0.2btc"
		    }') -> 8aDB23CDEA6
	   ```
   
	2. 用私钥对交易摘要进行签名
	
		```
		#参数1为交易摘要
		#参数2为私钥
		#返回签名信息
		sign("8aDB23CDEA6", "J78sknJhidhLIqdngalket") -> "3cdferdadgadg"
		```
2. 发送方广播

	广播的信息包含了交易原始信息（付款地址、收款地址、金额、代表交易摘要的 hash 值）和签名信息（即"3cdferdadgadg"）
	
3. 所有接收方验证

	验证过程实际是签名过程的逆运算
	
	```
	#参数1为签名信息
	#参数2为付款方地址
	#返回交易摘要
	verify("3cdferdadgadg", "2A39CBa2390FDe") -> "8aDB23CDEA6"
	```
	
	简单理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程
	

# 比特币如何挖矿（挖矿原理）
记账是把上一个Hash值、账本序号、交易时间、交易记录等信息计算Hash打包的过程

```
Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD
```

计算是需要消耗计算机资源的，完成记账的节点可以获得系统给与的一定数量的比特币奖励（给自己凭空增加一定数量的比特币），这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”

## 记账的规则

由于记账是有奖励的，因此就出现大家争相记账，大家一起记账就会出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：

+ 一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功
+ 通过解决密码学难题（即工作量证明）竞争获得唯一记账权
+ 其他节点复制记账结果

## 工作量证明

为了保证一段时间内只有一个人可以记账，就必须要提高记账的难度，提高难度的方法是要求Hash的结果必须以若干个0开头。为了满足这个条件，在进行Hash时会引入一个随机数变量

```
# 没有难度时为：Hash(上一个Hash值，交易记录集) = 456635BCD
Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD
```

挖矿其实就是不断寻找随机数以满足条件，率先找到随机数的节点就获得此次记账的唯一记账权

## 挖矿成功
在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块

网络的节点收到广播打包区块，会立刻对其进行验证，如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜

网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性

# 比特币如何达成共识
## 去中心化共识
实际上，比特币的共识由所有节点的4个独立过程相互作用而产生：

+ 每个节点（挖矿节点）依据标准对每个交易进行独立验证
+ 挖矿节点通过完成工作量证明，将交易记录独立打包进新区块
+ 每个节点独立的对新区块进行校验并组装进区块链
+ 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链（最长链的选择）

## 最长链的选择
两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的“获胜”区块到网络中

两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为备用链保存（保存是因为备用链将来可能会超过主链难度称为新主链）

如果该节点收到了第三个区块，是属于备用链的，那么备用链的长度超过主链，则原来的备用链变成主链

比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协：

+ 如果挖矿的难度很低（即找随机数的难度很简单），则所有交易会确认得更快，但是同时算出的节点必然更多，导致分叉的概率就会增加
+ 如果挖矿的难度很高（即找随机数的难度很难），则同时算出的节点会更少，即分叉的概率降低，但是这个会导致每次交易的确认时间更长

# UTXO
未花费的交易输出：交易的输出是一笔钱，这笔钱从没有被花费过。因为这是找零得来的。

>
一个钱包中有一个 10 元、一个 5 元，一共 15 元。当花 5 元买东西时，我们其实是要把 10 元和 5 元拿出去，然后得到找零的 10 元， 那这个时候之前的 10 元和 5 元因为已经花出去了就不再是 UTXO 了，新找零的 10 元成为新的 UTXO。因为找零的 10 元从没被花费过，所以称之为未花费的交易输出

+ [其实并没有什么比特币，只有 UTXO](http://8btc.com/article-4381-1.html)

